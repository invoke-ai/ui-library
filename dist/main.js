import * as ie from "react";
import At, { Children as yr, isValidElement as ao, createContext as an, useContext as at, useRef as se, useEffect as ge, useCallback as R, useState as ue, useId as Xt, useLayoutEffect as os, useMemo as be, forwardRef as _t, useReducer as Qk, useInsertionEffect as A0, createElement as eh, cloneElement as Lt, memo as T0, useSyncExternalStore as E0, Fragment as Hi, PureComponent as eA, Component as tA, useImperativeHandle as nA } from "react";
import { jsx as b, jsxs as Ae, Fragment as Vr } from "react/jsx-runtime";
import { createPortal as va } from "react-dom";
function rA(e, t, n, r) {
  return e.addEventListener(t, n, r), () => {
    e.removeEventListener(t, n, r);
  };
}
function zl(e) {
  return e != null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
function oA() {
  return !!globalThis?.document;
}
function R0(e) {
  return e.parentElement && R0(e.parentElement) ? !0 : e.hidden;
}
function iA(e) {
  const t = e.getAttribute("contenteditable");
  return t !== "false" && t != null;
}
function sA(e) {
  return !!e.getAttribute("disabled") || !!e.getAttribute("aria-disabled");
}
function aA(e) {
  return _0(e)?.defaultView ?? window;
}
function _0(e) {
  return zl(e) ? e.ownerDocument : document;
}
function cA(e) {
  return e.view ?? window;
}
function lA(e) {
  return _0(e).activeElement;
}
function uA(e) {
  const t = cA(e);
  return typeof t.PointerEvent < "u" && e instanceof t.PointerEvent ? e.pointerType === "mouse" : e instanceof t.MouseEvent;
}
function O0(e) {
  return !!e.touches;
}
function dA(e) {
  return O0(e) && e.touches.length > 1;
}
function fA(e, t = "page") {
  const n = e.touches[0] || e.changedTouches[0];
  return { x: n[`${t}X`], y: n[`${t}Y`] };
}
function pA(e, t = "page") {
  return {
    x: e[`${t}X`],
    y: e[`${t}Y`]
  };
}
function N0(e, t = "page") {
  return O0(e) ? fA(e, t) : pA(e, t);
}
function hA(e) {
  return (t) => {
    const n = uA(t);
    (!n || n && t.button === 0) && e(t);
  };
}
function mA(e, t = !1) {
  function n(o) {
    e(o, { point: N0(o) });
  }
  return t ? hA(n) : n;
}
function kc(e, t, n, r) {
  return rA(e, t, mA(n, t === "pointerdown"), r);
}
function gA(e, ...t) {
  if (e == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const n = { ...e };
  for (const r of t)
    if (r != null)
      for (const o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (o in n && delete n[o], n[o] = r[o]);
  return n;
}
const ye = (e) => e ? "" : void 0, Vt = (e) => e ? !0 : void 0;
function Tf(e) {
  return Array.isArray(e);
}
function Mt(e) {
  const t = typeof e;
  return e != null && (t === "object" || t === "function") && !Tf(e);
}
function bA(e) {
  const t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function vA(e) {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}
function Ef(e) {
  if (e == null)
    return e;
  const { unitless: t } = vA(e);
  return t || typeof e == "number" ? `${e}px` : e;
}
const M0 = (e, t) => parseInt(e[1], 10) > parseInt(t[1], 10) ? 1 : -1, th = (e) => Object.fromEntries(Object.entries(e).sort(M0));
function wg(e) {
  const t = th(e);
  return Object.assign(Object.values(t), t);
}
function yA(e) {
  const t = Object.keys(th(e));
  return new Set(t);
}
function Pg(e) {
  if (!e)
    return e;
  e = Ef(e) ?? e;
  const t = -0.02;
  return typeof e == "number" ? `${e + t}` : e.replace(/(\d+\.?\d*)/u, (n) => `${parseFloat(n) + t}`);
}
function ks(e, t) {
  const n = ["@media screen"];
  return e && n.push("and", `(min-width: ${Ef(e)})`), t && n.push("and", `(max-width: ${Ef(t)})`), n.join(" ");
}
function SA(e) {
  if (!e)
    return null;
  e.base = e.base ?? "0px";
  const t = wg(e), n = Object.entries(e).sort(M0).map(([i, s], a, c) => {
    let [, l] = c[a + 1] ?? [];
    return l = parseFloat(l) > 0 ? Pg(l) : void 0, {
      _minW: Pg(s),
      breakpoint: i,
      minW: s,
      maxW: l,
      maxWQuery: ks(null, l),
      minWQuery: ks(s),
      minMaxQuery: ks(s, l)
    };
  }), r = yA(e), o = Array.from(r.values());
  return {
    keys: r,
    normalized: t,
    isResponsive(i) {
      const s = Object.keys(i);
      return s.length > 0 && s.every((a) => r.has(a));
    },
    asObject: th(e),
    asArray: wg(e),
    details: n,
    get(i) {
      return n.find((s) => s.breakpoint === i);
    },
    media: [
      null,
      ...t.map((i) => ks(i)).slice(1)
    ],
    /**
     * Converts the object responsive syntax to array syntax
     *
     * @example
     * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
     */
    toArrayValue(i) {
      if (!Mt(i))
        throw new Error("toArrayValue: value must be an object");
      const s = o.map((a) => i[a] ?? null);
      for (; bA(s) === null; )
        s.pop();
      return s;
    },
    /**
     * Converts the array responsive syntax to object syntax
     *
     * @example
     * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
     */
    toObjectValue(i) {
      if (!Array.isArray(i))
        throw new Error("toObjectValue: value must be an array");
      return i.reduce(
        (s, a, c) => {
          const l = o[c];
          return l != null && a != null && (s[l] = a), s;
        },
        {}
      );
    }
  };
}
function Gl(...e) {
  return function(...n) {
    e.forEach((r) => r?.(...n));
  };
}
function fe(...e) {
  return function(n) {
    e.some((r) => (r?.(n), n?.defaultPrevented));
  };
}
function Hr(e) {
  return yr.toArray(e).filter(
    (t) => ao(t)
  );
}
function is(e) {
  const t = Object.assign({}, e);
  for (let n in t)
    t[n] === void 0 && delete t[n];
  return t;
}
function xA(e, t) {
  return `${e} returned \`undefined\`. Seems you forgot to wrap component within ${t}`;
}
function De(e = {}) {
  const {
    name: t,
    strict: n = !0,
    hookName: r = "useContext",
    providerName: o = "Provider",
    errorMessage: i,
    defaultValue: s
  } = e, a = an(s);
  a.displayName = t;
  function c() {
    const l = at(a);
    if (!l && n) {
      const u = new Error(
        i ?? xA(r, o)
      );
      throw u.name = "ContextError", Error.captureStackTrace?.(u, c), u;
    }
    return l;
  }
  return [a.Provider, c, a];
}
const oe = (...e) => e.filter(Boolean).join(" "), B0 = (e) => e.hasAttribute("tabindex"), CA = (e) => B0(e) && e.tabIndex === -1;
function tl(e) {
  if (!zl(e) || R0(e) || sA(e))
    return !1;
  const { localName: t } = e;
  if (["input", "select", "textarea", "button"].indexOf(t) >= 0)
    return !0;
  const r = {
    a: () => e.hasAttribute("href"),
    audio: () => e.hasAttribute("controls"),
    video: () => e.hasAttribute("controls")
  };
  return t in r ? r[t]() : iA(e) ? !0 : B0(e);
}
function IA(e) {
  return e ? zl(e) && tl(e) && !CA(e) : !1;
}
const wA = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
], PA = wA.join(), kA = (e) => e.offsetWidth > 0 && e.offsetHeight > 0;
function F0(e) {
  const t = Array.from(
    e.querySelectorAll(PA)
  );
  return t.unshift(e), t.filter((n) => tl(n) && kA(n));
}
function AA(e, t, n, r) {
  const o = typeof t == "string" ? t.split(".") : [t];
  for (r = 0; r < o.length && e; r += 1)
    e = e[o[r]];
  return e === void 0 ? n : e;
}
const TA = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, o, i, s) => {
    if (typeof r > "u")
      return e(r, o, i);
    t.has(r) || t.set(r, /* @__PURE__ */ new Map());
    const a = t.get(r);
    if (a.has(o))
      return a.get(o);
    const c = e(r, o, i, s);
    return a.set(o, c), c;
  };
}, D0 = TA(AA), EA = (e) => e.default || e;
function nh(e) {
  const { wasSelected: t, enabled: n, isSelected: r, mode: o = "unmount" } = e;
  return !!(!n || r || o === "keepMounted" && t);
}
function RA(e) {
  const t = parseFloat(e);
  return typeof t != "number" || Number.isNaN(t) ? 0 : t;
}
function rh(e, t) {
  let n = RA(e);
  const r = 10 ** (t ?? 10);
  return n = Math.round(n * r) / r, t ? n.toFixed(t) : n.toString();
}
function Rf(e) {
  if (!Number.isFinite(e))
    return 0;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n += 1;
  return n;
}
function nl(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function $0(e, t, n) {
  return (n - t) * e + t;
}
function _f(e, t, n) {
  const r = Math.round((e - t) / n) * n + t, o = Rf(n);
  return rh(r, o);
}
function _i(e, t, n) {
  return e == null ? e : (n < t && console.warn("clamp: max cannot be less than min"), Math.min(Math.max(e, t), n));
}
function ya(e, t = []) {
  const n = Object.assign({}, e);
  for (const r of t)
    r in n && delete n[r];
  return n;
}
function V0(e, t) {
  const n = {};
  for (const r of t)
    r in e && (n[r] = e[r]);
  return n;
}
const L0 = Object.freeze([
  "base",
  "sm",
  "md",
  "lg",
  "xl",
  "2xl"
]);
function Sa(e, t) {
  return Array.isArray(e) ? e.map((n) => n === null ? null : t(n)) : Mt(e) ? Object.keys(e).reduce((n, r) => (n[r] = t(e[r]), n), {}) : e != null ? t(e) : null;
}
function _A(e, t = L0) {
  const n = {};
  return e.forEach((r, o) => {
    const i = t[o];
    r != null && (n[i] = r);
  }), n;
}
const OA = (e) => typeof e == "function";
function jt(e, ...t) {
  return OA(e) ? e(...t) : e;
}
function NA(e) {
  const t = e.ownerDocument.defaultView || window, { overflow: n, overflowX: r, overflowY: o } = t.getComputedStyle(e);
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function MA(e) {
  return e.localName === "html" ? e : e.assignedSlot || e.parentElement || e.ownerDocument.documentElement;
}
function z0(e) {
  return ["html", "body", "#document"].includes(e.localName) ? e.ownerDocument.body : zl(e) && NA(e) ? e : z0(MA(e));
}
function G0(e, t) {
  const n = {}, r = {};
  for (const [o, i] of Object.entries(e))
    t.includes(o) ? n[o] = i : r[o] = i;
  return [n, r];
}
function BA(e, ...t) {
  const n = Object.getOwnPropertyDescriptors(e), r = Object.keys(n), o = (s) => {
    const a = {};
    for (let c = 0; c < s.length; c++) {
      const l = s[c];
      n[l] && (Object.defineProperty(a, l, n[l]), delete n[l]);
    }
    return a;
  }, i = (s) => o(Array.isArray(s) ? s : r.filter(s));
  return t.map(i).concat(o(r));
}
function kg(e, t, n = {}) {
  const { stop: r, getKey: o } = n;
  function i(s, a = []) {
    if (Mt(s) || Array.isArray(s)) {
      const c = {};
      for (const [l, u] of Object.entries(s)) {
        const d = o?.(l) ?? l, f = [...a, d];
        if (r?.(s, f))
          return t(s, a);
        c[d] = i(u, f);
      }
      return c;
    }
    return t(s, a);
  }
  return i(e);
}
const xa = (e) => {
  const { condition: t, message: n } = e;
  t && process.env.NODE_ENV !== "production" && console.warn(n);
};
var ja = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var As = { exports: {} };
As.exports;
var Ag;
function FA() {
  return Ag || (Ag = 1, (function(e, t) {
    var n = 200, r = "__lodash_hash_undefined__", o = 800, i = 16, s = 9007199254740991, a = "[object Arguments]", c = "[object Array]", l = "[object AsyncFunction]", u = "[object Boolean]", d = "[object Date]", f = "[object Error]", p = "[object Function]", m = "[object GeneratorFunction]", h = "[object Map]", g = "[object Number]", v = "[object Null]", y = "[object Object]", x = "[object Proxy]", S = "[object RegExp]", C = "[object Set]", w = "[object String]", I = "[object Undefined]", P = "[object WeakMap]", k = "[object ArrayBuffer]", A = "[object DataView]", N = "[object Float32Array]", B = "[object Float64Array]", L = "[object Int8Array]", Z = "[object Int16Array]", ne = "[object Int32Array]", W = "[object Uint8Array]", O = "[object Uint8ClampedArray]", J = "[object Uint16Array]", ee = "[object Uint32Array]", H = /[\\^$.*+?()[\]{}|]/g, _ = /^\[object .+?Constructor\]$/, j = /^(?:0|[1-9]\d*)$/, E = {};
    E[N] = E[B] = E[L] = E[Z] = E[ne] = E[W] = E[O] = E[J] = E[ee] = !0, E[a] = E[c] = E[k] = E[u] = E[A] = E[d] = E[f] = E[p] = E[h] = E[g] = E[y] = E[S] = E[C] = E[w] = E[P] = !1;
    var M = typeof ja == "object" && ja && ja.Object === Object && ja, F = typeof self == "object" && self && self.Object === Object && self, G = M || F || Function("return this")(), q = t && !t.nodeType && t, te = q && !0 && e && !e.nodeType && e, U = te && te.exports === q, K = U && M.process, ae = (function() {
      try {
        var T = te && te.require && te.require("util").types;
        return T || K && K.binding && K.binding("util");
      } catch {
      }
    })(), Y = ae && ae.isTypedArray;
    function ce(T, V, Q) {
      switch (Q.length) {
        case 0:
          return T.call(V);
        case 1:
          return T.call(V, Q[0]);
        case 2:
          return T.call(V, Q[0], Q[1]);
        case 3:
          return T.call(V, Q[0], Q[1], Q[2]);
      }
      return T.apply(V, Q);
    }
    function re(T, V) {
      for (var Q = -1, xe = Array(T); ++Q < T; )
        xe[Q] = V(Q);
      return xe;
    }
    function Ce(T) {
      return function(V) {
        return T(V);
      };
    }
    function Ve(T, V) {
      return T?.[V];
    }
    function le(T, V) {
      return function(Q) {
        return T(V(Q));
      };
    }
    var Pe = Array.prototype, ve = Function.prototype, he = Object.prototype, _e = G["__core-js_shared__"], Oe = ve.toString, ze = he.hasOwnProperty, Ye = (function() {
      var T = /[^.]+$/.exec(_e && _e.keys && _e.keys.IE_PROTO || "");
      return T ? "Symbol(src)_1." + T : "";
    })(), Yt = he.toString, Kt = Oe.call(Object), tn = RegExp(
      "^" + Oe.call(ze).replace(H, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), de = U ? G.Buffer : void 0, Ue = G.Symbol, pe = G.Uint8Array;
    de && de.allocUnsafe;
    var Se = le(Object.getPrototypeOf, Object), vt = Object.create, cn = he.propertyIsEnumerable, me = Pe.splice, ke = Ue ? Ue.toStringTag : void 0, Re = (function() {
      try {
        var T = Ku(Object, "defineProperty");
        return T({}, "", {}), T;
      } catch {
      }
    })(), Le = de ? de.isBuffer : void 0, Je = Math.max, qt = Date.now, Wt = Ku(G, "Map"), nn = Ku(Object, "create"), Qo = /* @__PURE__ */ (function() {
      function T() {
      }
      return function(V) {
        if (!go(V))
          return {};
        if (vt)
          return vt(V);
        T.prototype = V;
        var Q = new T();
        return T.prototype = void 0, Q;
      };
    })();
    function vn(T) {
      var V = -1, Q = T == null ? 0 : T.length;
      for (this.clear(); ++V < Q; ) {
        var xe = T[V];
        this.set(xe[0], xe[1]);
      }
    }
    function mo() {
      this.__data__ = nn ? nn(null) : {}, this.size = 0;
    }
    function ei(T) {
      var V = this.has(T) && delete this.__data__[T];
      return this.size -= V ? 1 : 0, V;
    }
    function nr(T) {
      var V = this.__data__;
      if (nn) {
        var Q = V[T];
        return Q === r ? void 0 : Q;
      }
      return ze.call(V, T) ? V[T] : void 0;
    }
    function Xu(T) {
      var V = this.__data__;
      return nn ? V[T] !== void 0 : ze.call(V, T);
    }
    function Yu(T, V) {
      var Q = this.__data__;
      return this.size += this.has(T) ? 0 : 1, Q[T] = nn && V === void 0 ? r : V, this;
    }
    vn.prototype.clear = mo, vn.prototype.delete = ei, vn.prototype.get = nr, vn.prototype.has = Xu, vn.prototype.set = Yu;
    function Rn(T) {
      var V = -1, Q = T == null ? 0 : T.length;
      for (this.clear(); ++V < Q; ) {
        var xe = T[V];
        this.set(xe[0], xe[1]);
      }
    }
    function ti() {
      this.__data__ = [], this.size = 0;
    }
    function ni(T) {
      var V = this.__data__, Q = za(V, T);
      if (Q < 0)
        return !1;
      var xe = V.length - 1;
      return Q == xe ? V.pop() : me.call(V, Q, 1), --this.size, !0;
    }
    function ri(T) {
      var V = this.__data__, Q = za(V, T);
      return Q < 0 ? void 0 : V[Q][1];
    }
    function oi(T) {
      return za(this.__data__, T) > -1;
    }
    function Zu(T, V) {
      var Q = this.__data__, xe = za(Q, T);
      return xe < 0 ? (++this.size, Q.push([T, V])) : Q[xe][1] = V, this;
    }
    Rn.prototype.clear = ti, Rn.prototype.delete = ni, Rn.prototype.get = ri, Rn.prototype.has = oi, Rn.prototype.set = Zu;
    function Ir(T) {
      var V = -1, Q = T == null ? 0 : T.length;
      for (this.clear(); ++V < Q; ) {
        var xe = T[V];
        this.set(xe[0], xe[1]);
      }
    }
    function uk() {
      this.size = 0, this.__data__ = {
        hash: new vn(),
        map: new (Wt || Rn)(),
        string: new vn()
      };
    }
    function dk(T) {
      var V = Wa(this, T).delete(T);
      return this.size -= V ? 1 : 0, V;
    }
    function fk(T) {
      return Wa(this, T).get(T);
    }
    function pk(T) {
      return Wa(this, T).has(T);
    }
    function hk(T, V) {
      var Q = Wa(this, T), xe = Q.size;
      return Q.set(T, V), this.size += Q.size == xe ? 0 : 1, this;
    }
    Ir.prototype.clear = uk, Ir.prototype.delete = dk, Ir.prototype.get = fk, Ir.prototype.has = pk, Ir.prototype.set = hk;
    function ii(T) {
      var V = this.__data__ = new Rn(T);
      this.size = V.size;
    }
    function mk() {
      this.__data__ = new Rn(), this.size = 0;
    }
    function gk(T) {
      var V = this.__data__, Q = V.delete(T);
      return this.size = V.size, Q;
    }
    function bk(T) {
      return this.__data__.get(T);
    }
    function vk(T) {
      return this.__data__.has(T);
    }
    function yk(T, V) {
      var Q = this.__data__;
      if (Q instanceof Rn) {
        var xe = Q.__data__;
        if (!Wt || xe.length < n - 1)
          return xe.push([T, V]), this.size = ++Q.size, this;
        Q = this.__data__ = new Ir(xe);
      }
      return Q.set(T, V), this.size = Q.size, this;
    }
    ii.prototype.clear = mk, ii.prototype.delete = gk, ii.prototype.get = bk, ii.prototype.has = vk, ii.prototype.set = yk;
    function Sk(T, V) {
      var Q = ed(T), xe = !Q && Qu(T), Xe = !Q && !xe && vg(T), dt = !Q && !xe && !Xe && Sg(T), yt = Q || xe || Xe || dt, Ke = yt ? re(T.length, String) : [], St = Ke.length;
      for (var Gn in T)
        yt && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Gn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        Xe && (Gn == "offset" || Gn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        dt && (Gn == "buffer" || Gn == "byteLength" || Gn == "byteOffset") || // Skip index properties.
        gg(Gn, St)) || Ke.push(Gn);
      return Ke;
    }
    function Uu(T, V, Q) {
      (Q !== void 0 && !Ha(T[V], Q) || Q === void 0 && !(V in T)) && Ju(T, V, Q);
    }
    function xk(T, V, Q) {
      var xe = T[V];
      (!(ze.call(T, V) && Ha(xe, Q)) || Q === void 0 && !(V in T)) && Ju(T, V, Q);
    }
    function za(T, V) {
      for (var Q = T.length; Q--; )
        if (Ha(T[Q][0], V))
          return Q;
      return -1;
    }
    function Ju(T, V, Q) {
      V == "__proto__" && Re ? Re(T, V, {
        configurable: !0,
        enumerable: !0,
        value: Q,
        writable: !0
      }) : T[V] = Q;
    }
    var Ck = Bk();
    function Ga(T) {
      return T == null ? T === void 0 ? I : v : ke && ke in Object(T) ? Fk(T) : Gk(T);
    }
    function hg(T) {
      return ds(T) && Ga(T) == a;
    }
    function Ik(T) {
      if (!go(T) || Lk(T))
        return !1;
      var V = nd(T) ? tn : _;
      return V.test(Xk(T));
    }
    function wk(T) {
      return ds(T) && yg(T.length) && !!E[Ga(T)];
    }
    function Pk(T) {
      if (!go(T))
        return zk(T);
      var V = bg(T), Q = [];
      for (var xe in T)
        xe == "constructor" && (V || !ze.call(T, xe)) || Q.push(xe);
      return Q;
    }
    function mg(T, V, Q, xe, Xe) {
      T !== V && Ck(V, function(dt, yt) {
        if (Xe || (Xe = new ii()), go(dt))
          kk(T, V, yt, Q, mg, xe, Xe);
        else {
          var Ke = xe ? xe(qu(T, yt), dt, yt + "", T, V, Xe) : void 0;
          Ke === void 0 && (Ke = dt), Uu(T, yt, Ke);
        }
      }, xg);
    }
    function kk(T, V, Q, xe, Xe, dt, yt) {
      var Ke = qu(T, Q), St = qu(V, Q), Gn = yt.get(St);
      if (Gn) {
        Uu(T, Q, Gn);
        return;
      }
      var yn = dt ? dt(Ke, St, Q + "", T, V, yt) : void 0, fs = yn === void 0;
      if (fs) {
        var rd = ed(St), od = !rd && vg(St), Ig = !rd && !od && Sg(St);
        yn = St, rd || od || Ig ? ed(Ke) ? yn = Ke : Yk(Ke) ? yn = Ok(Ke) : od ? (fs = !1, yn = Ek(St)) : Ig ? (fs = !1, yn = _k(St)) : yn = [] : Zk(St) || Qu(St) ? (yn = Ke, Qu(Ke) ? yn = Uk(Ke) : (!go(Ke) || nd(Ke)) && (yn = Dk(St))) : fs = !1;
      }
      fs && (yt.set(St, yn), Xe(yn, St, xe, dt, yt), yt.delete(St)), Uu(T, Q, yn);
    }
    function Ak(T, V) {
      return Hk(Wk(T, V, Cg), T + "");
    }
    var Tk = Re ? function(T, V) {
      return Re(T, "toString", {
        configurable: !0,
        enumerable: !1,
        value: Kk(V),
        writable: !0
      });
    } : Cg;
    function Ek(T, V) {
      return T.slice();
    }
    function Rk(T) {
      var V = new T.constructor(T.byteLength);
      return new pe(V).set(new pe(T)), V;
    }
    function _k(T, V) {
      var Q = Rk(T.buffer);
      return new T.constructor(Q, T.byteOffset, T.length);
    }
    function Ok(T, V) {
      var Q = -1, xe = T.length;
      for (V || (V = Array(xe)); ++Q < xe; )
        V[Q] = T[Q];
      return V;
    }
    function Nk(T, V, Q, xe) {
      var Xe = !Q;
      Q || (Q = {});
      for (var dt = -1, yt = V.length; ++dt < yt; ) {
        var Ke = V[dt], St = void 0;
        St === void 0 && (St = T[Ke]), Xe ? Ju(Q, Ke, St) : xk(Q, Ke, St);
      }
      return Q;
    }
    function Mk(T) {
      return Ak(function(V, Q) {
        var xe = -1, Xe = Q.length, dt = Xe > 1 ? Q[Xe - 1] : void 0, yt = Xe > 2 ? Q[2] : void 0;
        for (dt = T.length > 3 && typeof dt == "function" ? (Xe--, dt) : void 0, yt && $k(Q[0], Q[1], yt) && (dt = Xe < 3 ? void 0 : dt, Xe = 1), V = Object(V); ++xe < Xe; ) {
          var Ke = Q[xe];
          Ke && T(V, Ke, xe, dt);
        }
        return V;
      });
    }
    function Bk(T) {
      return function(V, Q, xe) {
        for (var Xe = -1, dt = Object(V), yt = xe(V), Ke = yt.length; Ke--; ) {
          var St = yt[++Xe];
          if (Q(dt[St], St, dt) === !1)
            break;
        }
        return V;
      };
    }
    function Wa(T, V) {
      var Q = T.__data__;
      return Vk(V) ? Q[typeof V == "string" ? "string" : "hash"] : Q.map;
    }
    function Ku(T, V) {
      var Q = Ve(T, V);
      return Ik(Q) ? Q : void 0;
    }
    function Fk(T) {
      var V = ze.call(T, ke), Q = T[ke];
      try {
        T[ke] = void 0;
        var xe = !0;
      } catch {
      }
      var Xe = Yt.call(T);
      return xe && (V ? T[ke] = Q : delete T[ke]), Xe;
    }
    function Dk(T) {
      return typeof T.constructor == "function" && !bg(T) ? Qo(Se(T)) : {};
    }
    function gg(T, V) {
      var Q = typeof T;
      return V = V ?? s, !!V && (Q == "number" || Q != "symbol" && j.test(T)) && T > -1 && T % 1 == 0 && T < V;
    }
    function $k(T, V, Q) {
      if (!go(Q))
        return !1;
      var xe = typeof V;
      return (xe == "number" ? td(Q) && gg(V, Q.length) : xe == "string" && V in Q) ? Ha(Q[V], T) : !1;
    }
    function Vk(T) {
      var V = typeof T;
      return V == "string" || V == "number" || V == "symbol" || V == "boolean" ? T !== "__proto__" : T === null;
    }
    function Lk(T) {
      return !!Ye && Ye in T;
    }
    function bg(T) {
      var V = T && T.constructor, Q = typeof V == "function" && V.prototype || he;
      return T === Q;
    }
    function zk(T) {
      var V = [];
      if (T != null)
        for (var Q in Object(T))
          V.push(Q);
      return V;
    }
    function Gk(T) {
      return Yt.call(T);
    }
    function Wk(T, V, Q) {
      return V = Je(V === void 0 ? T.length - 1 : V, 0), function() {
        for (var xe = arguments, Xe = -1, dt = Je(xe.length - V, 0), yt = Array(dt); ++Xe < dt; )
          yt[Xe] = xe[V + Xe];
        Xe = -1;
        for (var Ke = Array(V + 1); ++Xe < V; )
          Ke[Xe] = xe[Xe];
        return Ke[V] = Q(yt), ce(T, this, Ke);
      };
    }
    function qu(T, V) {
      if (!(V === "constructor" && typeof T[V] == "function") && V != "__proto__")
        return T[V];
    }
    var Hk = jk(Tk);
    function jk(T) {
      var V = 0, Q = 0;
      return function() {
        var xe = qt(), Xe = i - (xe - Q);
        if (Q = xe, Xe > 0) {
          if (++V >= o)
            return arguments[0];
        } else
          V = 0;
        return T.apply(void 0, arguments);
      };
    }
    function Xk(T) {
      if (T != null) {
        try {
          return Oe.call(T);
        } catch {
        }
        try {
          return T + "";
        } catch {
        }
      }
      return "";
    }
    function Ha(T, V) {
      return T === V || T !== T && V !== V;
    }
    var Qu = hg(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? hg : function(T) {
      return ds(T) && ze.call(T, "callee") && !cn.call(T, "callee");
    }, ed = Array.isArray;
    function td(T) {
      return T != null && yg(T.length) && !nd(T);
    }
    function Yk(T) {
      return ds(T) && td(T);
    }
    var vg = Le || qk;
    function nd(T) {
      if (!go(T))
        return !1;
      var V = Ga(T);
      return V == p || V == m || V == l || V == x;
    }
    function yg(T) {
      return typeof T == "number" && T > -1 && T % 1 == 0 && T <= s;
    }
    function go(T) {
      var V = typeof T;
      return T != null && (V == "object" || V == "function");
    }
    function ds(T) {
      return T != null && typeof T == "object";
    }
    function Zk(T) {
      if (!ds(T) || Ga(T) != y)
        return !1;
      var V = Se(T);
      if (V === null)
        return !0;
      var Q = ze.call(V, "constructor") && V.constructor;
      return typeof Q == "function" && Q instanceof Q && Oe.call(Q) == Kt;
    }
    var Sg = Y ? Ce(Y) : wk;
    function Uk(T) {
      return Nk(T, xg(T));
    }
    function xg(T) {
      return td(T) ? Sk(T) : Pk(T);
    }
    var Jk = Mk(function(T, V, Q, xe) {
      mg(T, V, Q, xe);
    });
    function Kk(T) {
      return function() {
        return T;
      };
    }
    function Cg(T) {
      return T;
    }
    function qk() {
      return !1;
    }
    e.exports = Jk;
  })(As, As.exports)), As.exports;
}
var DA = FA();
const Ot = /* @__PURE__ */ Wl(DA);
function pt(e, t = []) {
  const n = se(e);
  return ge(() => {
    n.current = e;
  }), R((...r) => n.current?.(...r), t);
}
function Qr(e, t, n, r) {
  const o = pt(n);
  return ge(() => {
    const i = typeof e == "function" ? e() : e ?? document;
    if (!(!n || !i))
      return i.addEventListener(t, o, r), () => {
        i.removeEventListener(t, o, r);
      };
  }, [t, e, r, o, n]), () => {
    (typeof e == "function" ? e() : e ?? document)?.removeEventListener(t, o, r);
  };
}
function W0(e) {
  const { isOpen: t, ref: n } = e, [r, o] = ue(t), [i, s] = ue(!1);
  return ge(() => {
    i || (o(t), s(!0));
  }, [t, i, r]), Qr(
    () => n.current,
    "animationend",
    () => {
      o(t);
    }
  ), {
    present: !(t ? !1 : !r),
    onComplete() {
      const c = aA(n.current), l = new c.CustomEvent("animationend", { bubbles: !0 });
      n.current?.dispatchEvent(l);
    }
  };
}
function co(e) {
  const {
    value: t,
    defaultValue: n,
    onChange: r,
    shouldUpdate: o = (f, p) => f !== p
  } = e, i = pt(r), s = pt(o), [a, c] = ue(n), l = t !== void 0, u = l ? t : a, d = pt(
    (f) => {
      const m = typeof f == "function" ? f(u) : f;
      s(u, m) && (l || c(m), i(m));
    },
    [l, i, u, s]
  );
  return [u, d];
}
function $A(e = {}) {
  const {
    onChange: t,
    precision: n,
    defaultValue: r,
    value: o,
    step: i = 1,
    min: s = Number.MIN_SAFE_INTEGER,
    max: a = Number.MAX_SAFE_INTEGER,
    keepWithinRange: c = !0
  } = e, l = pt(t), [u, d] = ue(() => r == null ? "" : id(r, i, n) ?? ""), f = typeof o < "u", p = f ? o : u, m = H0(Ur(p), i), h = n ?? m, g = R(
    (A) => {
      A !== p && (f || d(A.toString()), l?.(A.toString(), Ur(A)));
    },
    [l, f, p]
  ), v = R(
    (A) => {
      let N = A;
      return c && (N = _i(N, s, a)), rh(N, h);
    },
    [h, c, a, s]
  ), y = R(
    (A = i) => {
      let N;
      p === "" ? N = Ur(A) : N = Ur(p) + A, N = v(N), g(N);
    },
    [v, i, g, p]
  ), x = R(
    (A = i) => {
      let N;
      p === "" ? N = Ur(-A) : N = Ur(p) - A, N = v(N), g(N);
    },
    [v, i, g, p]
  ), S = R(() => {
    let A;
    r == null ? A = "" : A = id(r, i, n) ?? s, g(A);
  }, [r, n, i, g, s]), C = R(
    (A) => {
      const N = id(A, i, h) ?? s;
      g(N);
    },
    [h, i, g, s]
  ), w = Ur(p);
  return {
    isOutOfRange: w > a || w < s,
    isAtMax: w === a,
    isAtMin: w === s,
    precision: h,
    value: p,
    valueAsNumber: w,
    update: g,
    reset: S,
    increment: y,
    decrement: x,
    clamp: v,
    cast: C,
    setValue: d
  };
}
function Ur(e) {
  return parseFloat(e.toString().replace(/[^\w.-]+/g, ""));
}
function H0(e, t) {
  return Math.max(Rf(t), Rf(e));
}
function id(e, t, n) {
  const r = Ur(e);
  if (Number.isNaN(r))
    return;
  const o = H0(r, t);
  return rh(r, n ?? o);
}
function Hl(e = {}) {
  const {
    onClose: t,
    onOpen: n,
    isOpen: r,
    id: o
  } = e, i = pt(n), s = pt(t), [a, c] = ue(e.defaultIsOpen || !1), l = r !== void 0 ? r : a, u = r !== void 0, d = Xt(), f = o ?? `disclosure-${d}`, p = R(() => {
    u || c(!1), s?.();
  }, [u, s]), m = R(() => {
    u || c(!0), i?.();
  }, [u, i]), h = R(() => {
    l ? p() : m();
  }, [l, m, p]);
  function g(y = {}) {
    return {
      ...y,
      "aria-expanded": l,
      "aria-controls": f,
      onClick(x) {
        y.onClick?.(x), h();
      }
    };
  }
  function v(y = {}) {
    return {
      ...y,
      hidden: !l,
      id: f
    };
  }
  return {
    isOpen: l,
    onOpen: m,
    onClose: p,
    onToggle: h,
    isControlled: u,
    getButtonProps: g,
    getDisclosureProps: v
  };
}
const Dn = globalThis?.document ? os : ge, Jn = (e, t) => {
  const n = se(!1), r = se(!1);
  ge(() => {
    if (n.current && r.current)
      return e();
    r.current = !0;
  }, t), ge(() => (n.current = !0, () => {
    n.current = !1;
  }), []);
};
function VA(e) {
  const t = e.current;
  if (!t)
    return !1;
  const n = lA(t);
  return !n || t.contains(n) ? !1 : !!IA(n);
}
function j0(e, t) {
  const { shouldFocus: n, visible: r, focusRef: o } = t, i = n && !r;
  Jn(() => {
    if (!i || VA(e))
      return;
    const s = o?.current || e.current;
    let a;
    if (s)
      return a = requestAnimationFrame(() => {
        s.focus({ preventScroll: !0 });
      }), () => {
        cancelAnimationFrame(a);
      };
  }, [i, e, o]);
}
const LA = {
  preventScroll: !0,
  shouldFocus: !1
};
function zA(e, t = LA) {
  const { focusRef: n, preventScroll: r, shouldFocus: o, visible: i } = t, s = GA(e) ? e.current : e, a = o && i, c = se(a), l = se(i);
  Dn(() => {
    !l.current && i && (c.current = a), l.current = i;
  }, [i, a]);
  const u = R(() => {
    if (!(!i || !s || !c.current) && (c.current = !1, !s.contains(document.activeElement)))
      if (n?.current)
        requestAnimationFrame(() => {
          n.current?.focus({ preventScroll: r });
        });
      else {
        const d = F0(s);
        d.length > 0 && requestAnimationFrame(() => {
          d[0].focus({ preventScroll: r });
        });
      }
  }, [i, r, s, n]);
  Jn(() => {
    u();
  }, [u]), Qr(s, "transitionend", u);
}
function GA(e) {
  return "current" in e;
}
function WA(e) {
  return "current" in e;
}
const X0 = () => typeof window < "u";
function HA() {
  return navigator.userAgentData?.platform ?? navigator.platform;
}
const jA = (e) => X0() && e.test(navigator.vendor), XA = (e) => X0() && e.test(HA()), YA = () => XA(/mac|iphone|ipad|ipod/i), ZA = () => YA() && jA(/apple/i);
function Y0(e) {
  const { ref: t, elements: n, enabled: r } = e, o = () => t.current?.ownerDocument ?? document;
  Qr(o, "pointerdown", (i) => {
    if (!ZA() || !r)
      return;
    const s = i.composedPath?.()?.[0] ?? i.target, c = (n ?? [t]).some((l) => {
      const u = WA(l) ? l.current : l;
      return u?.contains(s) || u === s;
    });
    o().activeElement !== s && c && (i.preventDefault(), s.focus());
  });
}
function UA(e, t) {
  const n = Xt();
  return be(
    () => e || [t, n].filter(Boolean).join("-"),
    [e, t, n]
  );
}
function JA(e, ...t) {
  const n = UA(e);
  return be(() => t.map((r) => `${r}-${n}`), [n, t]);
}
function KA(e, t) {
  const n = pt(e);
  ge(() => {
    let r = null;
    const o = () => n();
    return t !== null && (r = window.setInterval(o, t)), () => {
      r && window.clearInterval(r);
    };
  }, [t, n]);
}
function Z0(e) {
  const t = se(null);
  return t.current = e, t;
}
function qA(e, t) {
  if (e != null) {
    if (typeof e == "function") {
      e(t);
      return;
    }
    try {
      e.current = t;
    } catch {
      throw new Error(`Cannot assign value '${t}' to ref '${e}'`);
    }
  }
}
function Ge(...e) {
  return (t) => {
    e.forEach((n) => {
      qA(n, t);
    });
  };
}
function QA(...e) {
  return be(() => Ge(...e), e);
}
function U0(e) {
  const { ref: t, handler: n, enabled: r = !0 } = e, o = pt(n), s = se({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }).current;
  ge(() => {
    if (!r)
      return;
    const a = (d) => {
      sd(d, t) && (s.isPointerDown = !0);
    }, c = (d) => {
      if (s.ignoreEmulatedMouseEvents) {
        s.ignoreEmulatedMouseEvents = !1;
        return;
      }
      s.isPointerDown && n && sd(d, t) && (s.isPointerDown = !1, o(d));
    }, l = (d) => {
      s.ignoreEmulatedMouseEvents = !0, n && s.isPointerDown && sd(d, t) && (s.isPointerDown = !1, o(d));
    }, u = J0(t.current);
    return u.addEventListener("mousedown", a, !0), u.addEventListener("mouseup", c, !0), u.addEventListener("touchstart", a, !0), u.addEventListener("touchend", l, !0), () => {
      u.removeEventListener("mousedown", a, !0), u.removeEventListener("mouseup", c, !0), u.removeEventListener("touchstart", a, !0), u.removeEventListener("touchend", l, !0);
    };
  }, [n, t, o, s, r]);
}
function sd(e, t) {
  const n = e.composedPath?.()[0] ?? e.target;
  return n && !J0(n).contains(n) ? !1 : !t.current?.contains(n);
}
function J0(e) {
  return e?.ownerDocument ?? document;
}
function eT(e) {
  const t = se(void 0);
  return ge(() => {
    t.current = e;
  }, [e]), t.current;
}
function tT(e, t) {
  const n = pt(e);
  ge(() => {
    if (t == null)
      return;
    let r = null;
    return r = window.setTimeout(() => {
      n();
    }, t), () => {
      r && window.clearTimeout(r);
    };
  }, [t, n]);
}
const K0 = 1 / 60 * 1e3, nT = typeof performance < "u" ? () => performance.now() : () => Date.now(), q0 = typeof window < "u" ? (e) => window.requestAnimationFrame(e) : (e) => setTimeout(() => e(nT()), K0);
function rT(e) {
  let t = [], n = [], r = 0, o = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet(), a = {
    schedule: (c, l = !1, u = !1) => {
      const d = u && o, f = d ? t : n;
      return l && s.add(c), f.indexOf(c) === -1 && (f.push(c), d && o && (r = t.length)), c;
    },
    cancel: (c) => {
      const l = n.indexOf(c);
      l !== -1 && n.splice(l, 1), s.delete(c);
    },
    process: (c) => {
      if (o) {
        i = !0;
        return;
      }
      if (o = !0, [t, n] = [n, t], n.length = 0, r = t.length, r)
        for (let l = 0; l < r; l++) {
          const u = t[l];
          u(c), s.has(u) && (a.schedule(u), e());
        }
      o = !1, i && (i = !1, a.process(c));
    }
  };
  return a;
}
const oT = 40;
let Of = !0, Ks = !1, Nf = !1;
const Oi = {
  delta: 0,
  timestamp: 0
}, Ca = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], jl = Ca.reduce((e, t) => (e[t] = rT(() => Ks = !0), e), {}), iT = Ca.reduce((e, t) => {
  const n = jl[t];
  return e[t] = (r, o = !1, i = !1) => (Ks || cT(), n.schedule(r, o, i)), e;
}, {}), sT = Ca.reduce((e, t) => (e[t] = jl[t].cancel, e), {});
Ca.reduce((e, t) => (e[t] = () => jl[t].process(Oi), e), {});
const aT = (e) => jl[e].process(Oi), Q0 = (e) => {
  Ks = !1, Oi.delta = Of ? K0 : Math.max(Math.min(e - Oi.timestamp, oT), 1), Oi.timestamp = e, Nf = !0, Ca.forEach(aT), Nf = !1, Ks && (Of = !1, q0(Q0));
}, cT = () => {
  Ks = !0, Of = !0, Nf || q0(Q0);
}, Tg = () => Oi;
var lT = Object.defineProperty, uT = (e, t, n) => t in e ? lT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Wn = (e, t, n) => (uT(e, typeof t != "symbol" ? t + "" : t, n), n);
class dT {
  constructor(t, n, r) {
    if (Wn(this, "history", []), Wn(this, "startEvent", null), Wn(this, "lastEvent", null), Wn(this, "lastEventInfo", null), Wn(this, "handlers", {}), Wn(this, "removeListeners", () => {
    }), Wn(this, "threshold", 3), Wn(this, "win"), Wn(this, "updatePoint", () => {
      if (!(this.lastEvent && this.lastEventInfo))
        return;
      const a = ad(this.lastEventInfo, this.history), c = this.startEvent !== null, l = mT(a.offset, { x: 0, y: 0 }) >= this.threshold;
      if (!c && !l)
        return;
      const { timestamp: u } = Tg();
      this.history.push({ ...a.point, timestamp: u });
      const { onStart: d, onMove: f } = this.handlers;
      c || (d?.(this.lastEvent, a), this.startEvent = this.lastEvent), f?.(this.lastEvent, a);
    }), Wn(this, "onPointerMove", (a, c) => {
      this.lastEvent = a, this.lastEventInfo = c, iT.update(this.updatePoint, !0);
    }), Wn(this, "onPointerUp", (a, c) => {
      const l = ad(c, this.history), { onEnd: u, onSessionEnd: d } = this.handlers;
      d?.(a, l), this.end(), !(!u || !this.startEvent) && u?.(a, l);
    }), this.win = t.view ?? window, dA(t))
      return;
    this.handlers = n, r && (this.threshold = r), t.stopPropagation(), t.preventDefault();
    const o = { point: N0(t) }, { timestamp: i } = Tg();
    this.history = [{ ...o.point, timestamp: i }];
    const { onSessionStart: s } = n;
    s?.(t, ad(o, this.history)), this.removeListeners = hT(
      kc(this.win, "pointermove", this.onPointerMove),
      kc(this.win, "pointerup", this.onPointerUp),
      kc(this.win, "pointercancel", this.onPointerUp)
    );
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners?.(), sT.update(this.updatePoint);
  }
}
function Eg(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function ad(e, t) {
  return {
    point: e.point,
    delta: Eg(e.point, t[t.length - 1]),
    offset: Eg(e.point, t[0]),
    velocity: pT(t, 0.1)
  };
}
const fT = (e) => e * 1e3;
function pT(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const o = e[e.length - 1];
  for (; n >= 0 && (r = e[n], !(o.timestamp - r.timestamp > fT(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const i = (o.timestamp - r.timestamp) / 1e3;
  if (i === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (o.x - r.x) / i,
    y: (o.y - r.y) / i
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function hT(...e) {
  return (t) => e.reduce((n, r) => r(n), t);
}
function cd(e, t) {
  return Math.abs(e - t);
}
function Rg(e) {
  return "x" in e && "y" in e;
}
function mT(e, t) {
  if (typeof e == "number" && typeof t == "number")
    return cd(e, t);
  if (Rg(e) && Rg(t)) {
    const n = cd(e.x, t.x), r = cd(e.y, t.y);
    return Math.sqrt(n ** 2 + r ** 2);
  }
  return 0;
}
function e1(e, t) {
  const {
    onPan: n,
    onPanStart: r,
    onPanEnd: o,
    onPanSessionStart: i,
    onPanSessionEnd: s,
    threshold: a
  } = t, c = !!(n || r || o || i || s), l = se(null), u = Z0({
    onSessionStart: i,
    onSessionEnd: s,
    onStart: r,
    onMove: n,
    onEnd(d, f) {
      l.current = null, o?.(d, f);
    }
  });
  ge(() => {
    l.current?.updateHandlers(u.current);
  }), ge(() => {
    const d = e.current;
    if (!d || !c)
      return;
    function f(p) {
      l.current = new dT(p, u.current, a);
    }
    return kc(d, "pointerdown", f);
  }, [e, c, u, a]), ge(() => () => {
    l.current?.end(), l.current = null;
  }, []);
}
const $t = {
  open: (e, t) => `${e}[data-open], ${e}[open], ${e}[data-state=open] ${t}`,
  closed: (e, t) => `${e}[data-closed], ${e}[data-state=closed] ${t}`,
  hover: (e, t) => `${e}:hover ${t}, ${e}[data-hover] ${t}`,
  focus: (e, t) => `${e}:focus ${t}, ${e}[data-focus] ${t}`,
  focusVisible: (e, t) => `${e}:focus-visible ${t}`,
  focusWithin: (e, t) => `${e}:focus-within ${t}`,
  active: (e, t) => `${e}:active ${t}, ${e}[data-active] ${t}`,
  disabled: (e, t) => `${e}:disabled ${t}, ${e}[data-disabled] ${t}`,
  invalid: (e, t) => `${e}:invalid ${t}, ${e}[data-invalid] ${t}`,
  checked: (e, t) => `${e}:checked ${t}, ${e}[data-checked] ${t}`,
  placeholderShown: (e, t) => `${e}:placeholder-shown ${t}`
}, rr = (e) => t1((t) => e(t, "&"), "[role=group]", "[data-group]", ".group"), wr = (e) => t1((t) => e(t, "~ &"), "[data-peer]", ".peer"), t1 = (e, ...t) => t.map(e).join(", "), Xl = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within, &[data-focus-within]",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty, &[data-empty]",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is open
   */
  _groupOpen: rr($t.open),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is closed
   */
  _groupClosed: rr($t.closed),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: rr($t.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: wr($t.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: rr($t.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: wr($t.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: rr($t.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: wr($t.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: rr($t.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: wr($t.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: rr($t.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: wr($t.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: rr($t.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: wr($t.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: rr($t.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: wr($t.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: rr($t.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: wr($t.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: wr($t.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder, &[data-placeholder]",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen, &[data-fullscreen]",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]",
  /**
   * Styles for the CSS Selector `&[data-open], &[open], &[data-state=open]`
   */
  _open: "&[data-open], &[open], &[data-state=open]",
  /**
   * Styles for the CSS Selector `&[data-closed], &[data-state=closed]`
   */
  _closed: "&[data-closed], &[data-state=closed]",
  /**
   * Styles for the CSS Selector `&[data-complete]`
   */
  _complete: "&[data-complete]",
  /**
   * Styles for the CSS Selector `&[data-incomplete]`
   */
  _incomplete: "&[data-incomplete]",
  /**
   * Styles for the CSS Selector `&[data-current]`
   */
  _current: "&[data-current]"
}, n1 = Object.keys(
  Xl
), gT = (e) => /!(important)?$/.test(e), _g = (e) => typeof e == "string" ? e.replace(/!(important)?$/, "").trim() : e, bT = (e, t) => (n) => {
  const r = String(t), o = gT(r), i = _g(r), s = e ? `${e}.${i}` : i;
  let a = Mt(n.__cssMap) && s in n.__cssMap ? n.__cssMap[s].varRef : t;
  return a = _g(a), o ? `${a} !important` : a;
};
function oh(e) {
  const { scale: t, transform: n, compose: r } = e;
  return (i, s) => {
    const a = bT(t, i)(s);
    let c = n?.(a, s) ?? a;
    return r && (c = r(c, s)), c;
  };
}
const Xa = (...e) => (t) => e.reduce((n, r) => r(n), t);
function _n(e, t) {
  return (n) => {
    const r = { property: n, scale: e };
    return r.transform = oh({
      scale: e,
      transform: t
    }), r;
  };
}
const vT = ({ rtl: e, ltr: t }) => (n) => n.direction === "rtl" ? e : t;
function yT(e) {
  const { property: t, scale: n, transform: r } = e;
  return {
    scale: n,
    property: vT(t),
    transform: n ? oh({
      scale: n,
      compose: r
    }) : r
  };
}
const r1 = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function ST() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...r1
  ].join(" ");
}
function xT() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...r1
  ].join(" ");
}
const CT = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
}, IT = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function wT(e) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": e,
    boxShadow: [
      "var(--chakra-ring-offset-shadow)",
      "var(--chakra-ring-shadow)",
      "var(--chakra-shadow, 0 0 #0000)"
    ].join(", ")
  };
}
const PT = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
}, Mf = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
}, kT = new Set(Object.values(Mf)), Bf = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]), AT = (e) => e.trim();
function TT(e, t) {
  if (e == null || Bf.has(e))
    return e;
  if (!(Ff(e) || Bf.has(e)))
    return `url('${e}')`;
  const o = /(^[a-z-A-Z]+)\((.*)\)/g.exec(e), i = o?.[1], s = o?.[2];
  if (!i || !s)
    return e;
  const a = i.includes("-gradient") ? i : `${i}-gradient`, [c, ...l] = s.split(",").map(AT).filter(Boolean);
  if (l?.length === 0)
    return e;
  const u = c in Mf ? Mf[c] : c;
  l.unshift(u);
  const d = l.map((f) => {
    if (kT.has(f))
      return f;
    const p = f.indexOf(" "), [m, h] = p !== -1 ? [f.substr(0, p), f.substr(p + 1)] : [f], g = Ff(h) ? h : h && h.split(" "), v = `colors.${m}`, y = v in t.__cssMap ? t.__cssMap[v].varRef : m;
    return g ? [
      y,
      ...Array.isArray(g) ? g : [g]
    ].join(" ") : y;
  });
  return `${a}(${d.join(", ")})`;
}
const Ff = (e) => typeof e == "string" && e.includes("(") && e.includes(")"), ET = (e, t) => TT(e, t ?? {});
function RT(e) {
  return /^var\(--.+\)$/.test(e);
}
const _T = (e) => {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}, or = (e) => (t) => `${e}(${t})`, He = {
  filter(e) {
    return e !== "auto" ? e : CT;
  },
  backdropFilter(e) {
    return e !== "auto" ? e : IT;
  },
  ring(e) {
    return wT(He.px(e));
  },
  bgClip(e) {
    return e === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: e };
  },
  transform(e) {
    return e === "auto" ? ST() : e === "auto-gpu" ? xT() : e;
  },
  vh(e) {
    return e === "$100vh" ? "var(--chakra-vh)" : e;
  },
  px(e) {
    if (e == null)
      return e;
    const { unitless: t } = _T(e);
    return t || typeof e == "number" ? `${e}px` : e;
  },
  fraction(e) {
    return typeof e != "number" || e > 1 ? e : `${e * 100}%`;
  },
  float(e, t) {
    const n = { left: "right", right: "left" };
    return t.direction === "rtl" ? n[e] : e;
  },
  degree(e) {
    if (RT(e) || e == null)
      return e;
    const t = typeof e == "string" && !e.endsWith("deg");
    return typeof e == "number" || t ? `${e}deg` : e;
  },
  gradient: ET,
  blur: or("blur"),
  opacity: or("opacity"),
  brightness: or("brightness"),
  contrast: or("contrast"),
  dropShadow: or("drop-shadow"),
  grayscale: or("grayscale"),
  hueRotate: (e) => or("hue-rotate")(He.degree(e)),
  invert: or("invert"),
  saturate: or("saturate"),
  sepia: or("sepia"),
  bgImage(e) {
    return e == null || Ff(e) || Bf.has(e) ? e : `url(${e})`;
  },
  outline(e) {
    const t = String(e) === "0" || String(e) === "none";
    return e !== null && t ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: e };
  },
  flexDirection(e) {
    const { space: t, divide: n } = PT[e] ?? {}, r = { flexDirection: e };
    return t && (r[t] = 1), n && (r[n] = 1), r;
  }
}, D = {
  borderWidths: _n("borderWidths"),
  borderStyles: _n("borderStyles"),
  colors: _n("colors"),
  borders: _n("borders"),
  gradients: _n("gradients", He.gradient),
  radii: _n("radii", He.px),
  space: _n("space", Xa(He.vh, He.px)),
  spaceT: _n("space", Xa(He.vh, He.px)),
  degreeT(e) {
    return { property: e, transform: He.degree };
  },
  prop(e, t, n) {
    return {
      property: e,
      scale: t,
      ...t && {
        transform: oh({ scale: t, transform: n })
      }
    };
  },
  propT(e, t) {
    return { property: e, transform: t };
  },
  sizes: _n("sizes", Xa(He.vh, He.px)),
  sizesT: _n("sizes", Xa(He.vh, He.fraction)),
  shadows: _n("shadows"),
  logical: yT,
  blur: _n("blur", He.blur)
}, Ac = {
  background: D.colors("background"),
  backgroundColor: D.colors("backgroundColor"),
  backgroundImage: D.gradients("backgroundImage"),
  backgroundSize: !0,
  backgroundPosition: !0,
  backgroundRepeat: !0,
  backgroundAttachment: !0,
  backgroundClip: { transform: He.bgClip },
  bgSize: D.prop("backgroundSize"),
  bgPosition: D.prop("backgroundPosition"),
  bg: D.colors("background"),
  bgColor: D.colors("backgroundColor"),
  bgPos: D.prop("backgroundPosition"),
  bgRepeat: D.prop("backgroundRepeat"),
  bgAttachment: D.prop("backgroundAttachment"),
  bgGradient: D.gradients("backgroundImage"),
  bgClip: { transform: He.bgClip }
};
Object.assign(Ac, {
  bgImage: Ac.backgroundImage,
  bgImg: Ac.backgroundImage
});
const qe = {
  border: D.borders("border"),
  borderWidth: D.borderWidths("borderWidth"),
  borderStyle: D.borderStyles("borderStyle"),
  borderColor: D.colors("borderColor"),
  borderRadius: D.radii("borderRadius"),
  borderTop: D.borders("borderTop"),
  borderBlockStart: D.borders("borderBlockStart"),
  borderTopLeftRadius: D.radii("borderTopLeftRadius"),
  borderStartStartRadius: D.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: D.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: D.radii("borderTopRightRadius"),
  borderStartEndRadius: D.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: D.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: D.borders("borderRight"),
  borderInlineEnd: D.borders("borderInlineEnd"),
  borderBottom: D.borders("borderBottom"),
  borderBlockEnd: D.borders("borderBlockEnd"),
  borderBottomLeftRadius: D.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: D.radii("borderBottomRightRadius"),
  borderLeft: D.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: D.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: D.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: D.borders(["borderLeft", "borderRight"]),
  borderInline: D.borders("borderInline"),
  borderY: D.borders(["borderTop", "borderBottom"]),
  borderBlock: D.borders("borderBlock"),
  borderTopWidth: D.borderWidths("borderTopWidth"),
  borderBlockStartWidth: D.borderWidths("borderBlockStartWidth"),
  borderTopColor: D.colors("borderTopColor"),
  borderBlockStartColor: D.colors("borderBlockStartColor"),
  borderTopStyle: D.borderStyles("borderTopStyle"),
  borderBlockStartStyle: D.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: D.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: D.borderWidths("borderBlockEndWidth"),
  borderBottomColor: D.colors("borderBottomColor"),
  borderBlockEndColor: D.colors("borderBlockEndColor"),
  borderBottomStyle: D.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: D.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: D.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: D.borderWidths("borderInlineStartWidth"),
  borderLeftColor: D.colors("borderLeftColor"),
  borderInlineStartColor: D.colors("borderInlineStartColor"),
  borderLeftStyle: D.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: D.borderStyles("borderInlineStartStyle"),
  borderRightWidth: D.borderWidths("borderRightWidth"),
  borderInlineEndWidth: D.borderWidths("borderInlineEndWidth"),
  borderRightColor: D.colors("borderRightColor"),
  borderInlineEndColor: D.colors("borderInlineEndColor"),
  borderRightStyle: D.borderStyles("borderRightStyle"),
  borderInlineEndStyle: D.borderStyles("borderInlineEndStyle"),
  borderTopRadius: D.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: D.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: D.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: D.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(qe, {
  rounded: qe.borderRadius,
  roundedTop: qe.borderTopRadius,
  roundedTopLeft: qe.borderTopLeftRadius,
  roundedTopRight: qe.borderTopRightRadius,
  roundedTopStart: qe.borderStartStartRadius,
  roundedTopEnd: qe.borderStartEndRadius,
  roundedBottom: qe.borderBottomRadius,
  roundedBottomLeft: qe.borderBottomLeftRadius,
  roundedBottomRight: qe.borderBottomRightRadius,
  roundedBottomStart: qe.borderEndStartRadius,
  roundedBottomEnd: qe.borderEndEndRadius,
  roundedLeft: qe.borderLeftRadius,
  roundedRight: qe.borderRightRadius,
  roundedStart: qe.borderInlineStartRadius,
  roundedEnd: qe.borderInlineEndRadius,
  borderStart: qe.borderInlineStart,
  borderEnd: qe.borderInlineEnd,
  borderTopStartRadius: qe.borderStartStartRadius,
  borderTopEndRadius: qe.borderStartEndRadius,
  borderBottomStartRadius: qe.borderEndStartRadius,
  borderBottomEndRadius: qe.borderEndEndRadius,
  borderStartRadius: qe.borderInlineStartRadius,
  borderEndRadius: qe.borderInlineEndRadius,
  borderStartWidth: qe.borderInlineStartWidth,
  borderEndWidth: qe.borderInlineEndWidth,
  borderStartColor: qe.borderInlineStartColor,
  borderEndColor: qe.borderInlineEndColor,
  borderStartStyle: qe.borderInlineStartStyle,
  borderEndStyle: qe.borderInlineEndStyle
});
const OT = {
  color: D.colors("color"),
  textColor: D.colors("color"),
  fill: D.colors("fill"),
  stroke: D.colors("stroke"),
  accentColor: D.colors("accentColor"),
  textFillColor: D.colors("textFillColor")
}, rl = {
  alignItems: !0,
  alignContent: !0,
  justifyItems: !0,
  justifyContent: !0,
  flexWrap: !0,
  flexDirection: { transform: He.flexDirection },
  flex: !0,
  flexFlow: !0,
  flexGrow: !0,
  flexShrink: !0,
  flexBasis: D.sizes("flexBasis"),
  justifySelf: !0,
  alignSelf: !0,
  order: !0,
  placeItems: !0,
  placeContent: !0,
  placeSelf: !0,
  gap: D.space("gap"),
  rowGap: D.space("rowGap"),
  columnGap: D.space("columnGap")
};
Object.assign(rl, {
  flexDir: rl.flexDirection
});
const Mn = {
  width: D.sizesT("width"),
  inlineSize: D.sizesT("inlineSize"),
  height: D.sizes("height"),
  blockSize: D.sizes("blockSize"),
  boxSize: D.sizes(["width", "height"]),
  minWidth: D.sizes("minWidth"),
  minInlineSize: D.sizes("minInlineSize"),
  minHeight: D.sizes("minHeight"),
  minBlockSize: D.sizes("minBlockSize"),
  maxWidth: D.sizes("maxWidth"),
  maxInlineSize: D.sizes("maxInlineSize"),
  maxHeight: D.sizes("maxHeight"),
  maxBlockSize: D.sizes("maxBlockSize"),
  overflow: !0,
  overflowX: !0,
  overflowY: !0,
  overscrollBehavior: !0,
  overscrollBehaviorX: !0,
  overscrollBehaviorY: !0,
  display: !0,
  aspectRatio: !0,
  hideFrom: {
    scale: "breakpoints",
    transform: (e, t) => ({ [`@media screen and (min-width: ${t.__breakpoints?.get(e)?.minW ?? e})`]: { display: "none" } })
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (e, t) => ({ [`@media screen and (max-width: ${t.__breakpoints?.get(e)?._minW ?? e})`]: { display: "none" } })
  },
  verticalAlign: !0,
  boxSizing: !0,
  boxDecorationBreak: !0,
  float: D.propT("float", He.float),
  objectFit: !0,
  objectPosition: !0,
  visibility: !0,
  isolation: !0
};
Object.assign(Mn, {
  w: Mn.width,
  h: Mn.height,
  minW: Mn.minWidth,
  maxW: Mn.maxWidth,
  minH: Mn.minHeight,
  maxH: Mn.maxHeight,
  overscroll: Mn.overscrollBehavior,
  overscrollX: Mn.overscrollBehaviorX,
  overscrollY: Mn.overscrollBehaviorY
});
const NT = {
  filter: { transform: He.filter },
  blur: D.blur("--chakra-blur"),
  brightness: D.propT("--chakra-brightness", He.brightness),
  contrast: D.propT("--chakra-contrast", He.contrast),
  hueRotate: D.propT("--chakra-hue-rotate", He.hueRotate),
  invert: D.propT("--chakra-invert", He.invert),
  saturate: D.propT("--chakra-saturate", He.saturate),
  dropShadow: D.propT("--chakra-drop-shadow", He.dropShadow),
  backdropFilter: { transform: He.backdropFilter },
  backdropBlur: D.blur("--chakra-backdrop-blur"),
  backdropBrightness: D.propT(
    "--chakra-backdrop-brightness",
    He.brightness
  ),
  backdropContrast: D.propT("--chakra-backdrop-contrast", He.contrast),
  backdropHueRotate: D.propT(
    "--chakra-backdrop-hue-rotate",
    He.hueRotate
  ),
  backdropInvert: D.propT("--chakra-backdrop-invert", He.invert),
  backdropSaturate: D.propT("--chakra-backdrop-saturate", He.saturate)
}, MT = {
  ring: { transform: He.ring },
  ringColor: D.colors("--chakra-ring-color"),
  ringOffset: D.prop("--chakra-ring-offset-width"),
  ringOffsetColor: D.colors("--chakra-ring-offset-color"),
  ringInset: D.prop("--chakra-ring-inset")
}, BT = {
  appearance: !0,
  cursor: !0,
  resize: !0,
  userSelect: !0,
  pointerEvents: !0,
  outline: { transform: He.outline },
  outlineOffset: !0,
  outlineColor: D.colors("outlineColor")
}, o1 = {
  gridGap: D.space("gridGap"),
  gridColumnGap: D.space("gridColumnGap"),
  gridRowGap: D.space("gridRowGap"),
  gridColumn: !0,
  gridRow: !0,
  gridAutoFlow: !0,
  gridAutoColumns: !0,
  gridColumnStart: !0,
  gridColumnEnd: !0,
  gridRowStart: !0,
  gridRowEnd: !0,
  gridAutoRows: !0,
  gridTemplate: !0,
  gridTemplateColumns: !0,
  gridTemplateRows: !0,
  gridTemplateAreas: !0,
  gridArea: !0
};
function FT(e, t, n, r) {
  const o = typeof t == "string" ? t.split(".") : [t];
  for (r = 0; r < o.length && e; r += 1)
    e = e[o[r]];
  return e === void 0 ? n : e;
}
const DT = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, o, i, s) => {
    if (typeof r > "u")
      return e(r, o, i);
    t.has(r) || t.set(r, /* @__PURE__ */ new Map());
    const a = t.get(r);
    if (a.has(o))
      return a.get(o);
    const c = e(r, o, i, s);
    return a.set(o, c), c;
  };
}, $T = DT(FT), VT = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
}, LT = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
}, ld = (e, t, n) => {
  const r = {}, o = $T(e, t, {});
  for (const i in o)
    i in n && n[i] != null || (r[i] = o[i]);
  return r;
}, zT = {
  srOnly: {
    transform(e) {
      return e === !0 ? VT : e === "focusable" ? LT : {};
    }
  },
  layerStyle: {
    processResult: !0,
    transform: (e, t, n) => ld(t, `layerStyles.${e}`, n)
  },
  textStyle: {
    processResult: !0,
    transform: (e, t, n) => ld(t, `textStyles.${e}`, n)
  },
  apply: {
    processResult: !0,
    transform: (e, t, n) => ld(t, e, n)
  }
}, $s = {
  position: !0,
  pos: D.prop("position"),
  zIndex: D.prop("zIndex", "zIndices"),
  inset: D.spaceT("inset"),
  insetX: D.spaceT(["left", "right"]),
  insetInline: D.spaceT("insetInline"),
  insetY: D.spaceT(["top", "bottom"]),
  insetBlock: D.spaceT("insetBlock"),
  top: D.spaceT("top"),
  insetBlockStart: D.spaceT("insetBlockStart"),
  bottom: D.spaceT("bottom"),
  insetBlockEnd: D.spaceT("insetBlockEnd"),
  left: D.spaceT("left"),
  insetInlineStart: D.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: D.spaceT("right"),
  insetInlineEnd: D.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign($s, {
  insetStart: $s.insetInlineStart,
  insetEnd: $s.insetInlineEnd
});
const Df = {
  boxShadow: D.shadows("boxShadow"),
  mixBlendMode: !0,
  blendMode: D.prop("mixBlendMode"),
  backgroundBlendMode: !0,
  bgBlendMode: D.prop("backgroundBlendMode"),
  opacity: !0
};
Object.assign(Df, {
  shadow: Df.boxShadow
});
const mt = {
  margin: D.spaceT("margin"),
  marginTop: D.spaceT("marginTop"),
  marginBlockStart: D.spaceT("marginBlockStart"),
  marginRight: D.spaceT("marginRight"),
  marginInlineEnd: D.spaceT("marginInlineEnd"),
  marginBottom: D.spaceT("marginBottom"),
  marginBlockEnd: D.spaceT("marginBlockEnd"),
  marginLeft: D.spaceT("marginLeft"),
  marginInlineStart: D.spaceT("marginInlineStart"),
  marginX: D.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: D.spaceT("marginInline"),
  marginY: D.spaceT(["marginTop", "marginBottom"]),
  marginBlock: D.spaceT("marginBlock"),
  padding: D.space("padding"),
  paddingTop: D.space("paddingTop"),
  paddingBlockStart: D.space("paddingBlockStart"),
  paddingRight: D.space("paddingRight"),
  paddingBottom: D.space("paddingBottom"),
  paddingBlockEnd: D.space("paddingBlockEnd"),
  paddingLeft: D.space("paddingLeft"),
  paddingInlineStart: D.space("paddingInlineStart"),
  paddingInlineEnd: D.space("paddingInlineEnd"),
  paddingX: D.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: D.space("paddingInline"),
  paddingY: D.space(["paddingTop", "paddingBottom"]),
  paddingBlock: D.space("paddingBlock")
};
Object.assign(mt, {
  m: mt.margin,
  mt: mt.marginTop,
  mr: mt.marginRight,
  me: mt.marginInlineEnd,
  marginEnd: mt.marginInlineEnd,
  mb: mt.marginBottom,
  ml: mt.marginLeft,
  ms: mt.marginInlineStart,
  marginStart: mt.marginInlineStart,
  mx: mt.marginX,
  my: mt.marginY,
  p: mt.padding,
  pt: mt.paddingTop,
  py: mt.paddingY,
  px: mt.paddingX,
  pb: mt.paddingBottom,
  pl: mt.paddingLeft,
  ps: mt.paddingInlineStart,
  paddingStart: mt.paddingInlineStart,
  pr: mt.paddingRight,
  pe: mt.paddingInlineEnd,
  paddingEnd: mt.paddingInlineEnd
});
const GT = {
  scrollBehavior: !0,
  scrollSnapAlign: !0,
  scrollSnapStop: !0,
  scrollSnapType: !0,
  // scroll margin
  scrollMargin: D.spaceT("scrollMargin"),
  scrollMarginTop: D.spaceT("scrollMarginTop"),
  scrollMarginBottom: D.spaceT("scrollMarginBottom"),
  scrollMarginLeft: D.spaceT("scrollMarginLeft"),
  scrollMarginRight: D.spaceT("scrollMarginRight"),
  scrollMarginX: D.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: D.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: D.spaceT("scrollPadding"),
  scrollPaddingTop: D.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: D.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: D.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: D.spaceT("scrollPaddingRight"),
  scrollPaddingX: D.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: D.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
}, WT = {
  fontFamily: D.prop("fontFamily", "fonts"),
  fontSize: D.prop("fontSize", "fontSizes", He.px),
  fontWeight: D.prop("fontWeight", "fontWeights"),
  lineHeight: D.prop("lineHeight", "lineHeights"),
  letterSpacing: D.prop("letterSpacing", "letterSpacings"),
  textAlign: !0,
  fontStyle: !0,
  textIndent: !0,
  wordBreak: !0,
  overflowWrap: !0,
  textOverflow: !0,
  textTransform: !0,
  whiteSpace: !0,
  isTruncated: {
    transform(e) {
      if (e === !0)
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
}, HT = {
  textDecorationColor: D.colors("textDecorationColor"),
  textDecoration: !0,
  textDecor: { property: "textDecoration" },
  textDecorationLine: !0,
  textDecorationStyle: !0,
  textDecorationThickness: !0,
  textUnderlineOffset: !0,
  textShadow: D.shadows("textShadow")
}, jT = {
  clipPath: !0,
  transform: D.propT("transform", He.transform),
  transformOrigin: !0,
  translateX: D.spaceT("--chakra-translate-x"),
  translateY: D.spaceT("--chakra-translate-y"),
  skewX: D.degreeT("--chakra-skew-x"),
  skewY: D.degreeT("--chakra-skew-y"),
  scaleX: D.prop("--chakra-scale-x"),
  scaleY: D.prop("--chakra-scale-y"),
  scale: D.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: D.degreeT("--chakra-rotate")
}, XT = {
  listStyleType: !0,
  listStylePosition: !0,
  listStylePos: D.prop("listStylePosition"),
  listStyleImage: !0,
  listStyleImg: D.prop("listStyleImage")
}, YT = {
  transition: !0,
  transitionDelay: !0,
  animation: !0,
  willChange: !0,
  transitionDuration: D.prop("transitionDuration", "transition.duration"),
  transitionProperty: D.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: D.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
}, ih = Ot(
  {},
  Ac,
  qe,
  OT,
  rl,
  Mn,
  NT,
  MT,
  BT,
  o1,
  zT,
  $s,
  Df,
  mt,
  GT,
  WT,
  HT,
  jT,
  XT,
  YT
), ZT = Object.assign({}, mt, Mn, rl, o1, $s), i1 = Object.keys(
  ZT
), UT = [...Object.keys(ih), ...n1], JT = { ...ih, ...Xl }, KT = (e) => e in JT, qT = (e) => (t) => {
  if (!t.__breakpoints)
    return e;
  const { isResponsive: n, toArrayValue: r, media: o } = t.__breakpoints, i = {};
  for (const s in e) {
    let a = jt(e[s], t);
    if (a == null)
      continue;
    if (a = Mt(a) && n(a) ? r(a) : a, !Array.isArray(a)) {
      i[s] = a;
      continue;
    }
    const c = a.slice(0, o.length).length;
    for (let l = 0; l < c; l += 1) {
      const u = o?.[l];
      if (!u) {
        i[s] = a[l];
        continue;
      }
      i[u] = i[u] || {}, a[l] != null && (i[u][s] = a[l]);
    }
  }
  return i;
};
function QT(e) {
  const t = [];
  let n = "", r = !1;
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    i === "(" ? (r = !0, n += i) : i === ")" ? (r = !1, n += i) : i === "," && !r ? (t.push(n), n = "") : n += i;
  }
  return n = n.trim(), n && t.push(n), t;
}
function eE(e) {
  return /^var\(--.+\)$/.test(e);
}
const tE = (e, t) => e.startsWith("--") && typeof t == "string" && !eE(t), nE = (e, t) => {
  if (t == null)
    return t;
  const n = (s) => e.__cssMap?.[s]?.varRef, r = (s) => n(s) ?? s, [o, i] = QT(t);
  return t = n(o) ?? r(i) ?? r(t), t;
};
function rE(e) {
  const { configs: t = {}, pseudos: n = {}, theme: r } = e, o = (i, s = !1) => {
    const a = jt(i, r), c = qT(a)(r);
    let l = {};
    for (let u in c) {
      const d = c[u];
      let f = jt(d, r);
      u in n && (u = n[u]), tE(u, f) && (f = nE(r, f));
      let p = t[u];
      if (p === !0 && (p = { property: u }), Mt(f)) {
        l[u] = l[u] ?? {}, l[u] = Ot(
          {},
          l[u],
          o(f, !0)
        );
        continue;
      }
      let m = p?.transform?.(f, r, a) ?? f;
      m = p?.processResult ? o(m, !0) : m;
      const h = jt(p?.property, r);
      if (!s && p?.static) {
        const g = jt(p.static, r);
        l = Ot({}, l, g);
      }
      if (h && Array.isArray(h)) {
        for (const g of h)
          l[g] = m;
        continue;
      }
      if (h) {
        h === "&" && Mt(m) ? l = Ot({}, l, m) : l[h] = m;
        continue;
      }
      if (Mt(m)) {
        l = Ot({}, l, m);
        continue;
      }
      l[u] = m;
    }
    return l;
  };
  return o;
}
const s1 = (e) => (t) => rE({
  theme: t,
  pseudos: Xl,
  configs: ih
})(e);
function ct(e) {
  return {
    definePartsStyle(t) {
      return t;
    },
    defineMultiStyleConfig(t) {
      return { parts: e, ...t };
    }
  };
}
function oE(e, t, n) {
  return e.__cssMap?.[`${t}.${n}`]?.varRef ?? n;
}
function iE(e, t) {
  if (Array.isArray(e))
    return e;
  if (Mt(e))
    return t(e);
  if (e != null)
    return [e];
}
function sE(e, t) {
  for (let n = t + 1; n < e.length; n++)
    if (e[n] != null)
      return n;
  return -1;
}
function aE(e) {
  const t = e.__breakpoints;
  return function(r, o, i, s) {
    if (!t)
      return;
    const a = {}, c = iE(i, t.toArrayValue);
    if (!c)
      return a;
    const l = c.length, u = l === 1, d = !!r.parts;
    for (let f = 0; f < l; f++) {
      const p = t.details[f], m = t.details[sE(c, f)], h = ks(p.minW, m?._minW), g = jt(r[o]?.[c[f]], s);
      if (g) {
        if (d) {
          r.parts?.forEach((v) => {
            Ot(a, {
              [v]: u ? g[v] : { [h]: g[v] }
            });
          });
          continue;
        }
        if (!d) {
          u ? Ot(a, g) : a[h] = g;
          continue;
        }
        a[h] = g;
      }
    }
    return a;
  };
}
function cE(e) {
  return (t) => {
    const { variant: n, size: r, theme: o } = t, i = aE(o);
    return Ot(
      {},
      jt(e.baseStyle ?? {}, t),
      i(e, "sizes", r, t),
      i(e, "variants", n, t)
    );
  };
}
function $e(e) {
  return ya(e, ["styleConfig", "size", "variant", "colorScheme"]);
}
function a1(e) {
  return Mt(e) && e.reference ? e.reference : String(e);
}
const Yl = (e, ...t) => t.map(a1).join(` ${e} `).replace(/calc/g, ""), Og = (...e) => `calc(${Yl("+", ...e)})`, Ng = (...e) => `calc(${Yl("-", ...e)})`, $f = (...e) => `calc(${Yl("*", ...e)})`, Mg = (...e) => `calc(${Yl("/", ...e)})`, Bg = (e) => {
  const t = a1(e);
  return t != null && !Number.isNaN(parseFloat(t)) ? String(t).startsWith("-") ? String(t).slice(1) : `-${t}` : $f(t, -1);
}, Er = Object.assign(
  (e) => ({
    add: (...t) => Er(Og(e, ...t)),
    subtract: (...t) => Er(Ng(e, ...t)),
    multiply: (...t) => Er($f(e, ...t)),
    divide: (...t) => Er(Mg(e, ...t)),
    negate: () => Er(Bg(e)),
    toString: () => e.toString()
  }),
  {
    add: Og,
    subtract: Ng,
    multiply: $f,
    divide: Mg,
    negate: Bg
  }
);
function lE(e, t = "-") {
  return e.replace(/\s+/g, t);
}
function uE(e) {
  const t = lE(e.toString());
  return fE(dE(t));
}
function dE(e) {
  return e.includes("\\.") ? e : !Number.isInteger(parseFloat(e.toString())) ? e.replace(".", "\\.") : e;
}
function fE(e) {
  return e.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function pE(e, t = "") {
  return [t, e].filter(Boolean).join("-");
}
function hE(e, t) {
  return `var(${e}${t ? `, ${t}` : ""})`;
}
function mE(e, t = "") {
  return uE(`--${pE(e, t)}`);
}
function Te(e, t, n) {
  const r = mE(e, n);
  return {
    variable: r,
    reference: hE(r, t)
  };
}
function gE(e, t) {
  const n = {};
  for (const r of t) {
    if (Array.isArray(r)) {
      const [o, i] = r;
      n[o] = Te(`${e}-${o}`, i);
      continue;
    }
    n[r] = Te(`${e}-${r}`);
  }
  return n;
}
const bE = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function vE(e) {
  return V0(e, bE);
}
function yE(e) {
  return e.semanticTokens;
}
function SE(e) {
  const { __cssMap: t, __cssVars: n, __breakpoints: r, ...o } = e;
  return o;
}
function xE(e) {
  const t = vE(e), n = yE(e), r = (i) => (
    // @ts-ignore
    n1.includes(i) || i === "default"
  ), o = {};
  return kg(t, (i, s) => {
    i != null && (o[s.join(".")] = { isSemantic: !1, value: i });
  }), kg(
    n,
    (i, s) => {
      i != null && (o[s.join(".")] = { isSemantic: !0, value: i });
    },
    {
      stop: (i) => Object.keys(i).every(r)
    }
  ), o;
}
function Fg(e, t) {
  return Te(String(e).replace(/\./g, "-"), void 0, t);
}
function CE(e) {
  const t = xE(e), n = e.config?.cssVarPrefix;
  let r = {};
  const o = {};
  function i(s, a) {
    const l = [String(s).split(".")[0], a].join(".");
    if (!t[l])
      return a;
    const { reference: d } = Fg(l, n);
    return d;
  }
  for (const [s, a] of Object.entries(t)) {
    const { isSemantic: c, value: l } = a, { variable: u, reference: d } = Fg(s, n);
    if (!c) {
      if (s.startsWith("space")) {
        const p = s.split("."), [m, ...h] = p, g = `${m}.-${h.join(".")}`, v = Er.negate(l), y = Er.negate(d);
        o[g] = {
          value: v,
          var: u,
          varRef: y
        };
      }
      r[u] = l, o[s] = {
        value: l,
        var: u,
        varRef: d
      };
      continue;
    }
    const f = Mt(l) ? l : { default: l };
    r = Ot(
      r,
      Object.entries(f).reduce(
        (p, [m, h]) => {
          if (!h)
            return p;
          const g = i(s, `${h}`);
          if (m === "default")
            return p[u] = g, p;
          const v = Xl?.[m] ?? m;
          return p[v] = { [u]: g }, p;
        },
        {}
      )
    ), o[s] = {
      value: d,
      var: u,
      varRef: d
    };
  }
  return {
    cssVars: r,
    cssMap: o
  };
}
function IE(e) {
  const t = SE(e), {
    /**
     * This is more like a dictionary of tokens users will type `green.500`,
     * and their equivalent css variable.
     */
    cssMap: n,
    /**
     * The extracted css variables will be stored here, and used in
     * the emotion's <Global/> component to attach variables to `:root`
     */
    cssVars: r
  } = CE(t);
  return Object.assign(t, {
    __cssVars: { ...{
      "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-ring-offset-width": "0px",
      "--chakra-ring-offset-color": "#fff",
      "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
      "--chakra-ring-offset-shadow": "0 0 #0000",
      "--chakra-ring-shadow": "0 0 #0000",
      "--chakra-space-x-reverse": "0",
      "--chakra-space-y-reverse": "0"
    }, ...r },
    __cssMap: n,
    __breakpoints: SA(t.breakpoints)
  }), t;
}
function rt(e, t = {}) {
  let n = !1;
  function r() {
    if (!n) {
      n = !0;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function o(...u) {
    r();
    for (const d of u)
      t[d] = c(d);
    return rt(e, t);
  }
  function i(...u) {
    for (const d of u)
      d in t || (t[d] = c(d));
    return rt(e, t);
  }
  function s() {
    return Object.fromEntries(
      Object.entries(t).map(([d, f]) => [d, f.selector])
    );
  }
  function a() {
    return Object.fromEntries(
      Object.entries(t).map(([d, f]) => [d, f.className])
    );
  }
  function c(u) {
    const p = `chakra-${(["container", "root"].includes(u ?? "") ? [e] : [e, u]).filter(Boolean).join("__")}`;
    return {
      className: p,
      selector: `.${p}`,
      toString: () => u
    };
  }
  return {
    parts: o,
    toPart: c,
    extend: i,
    selectors: s,
    classnames: a,
    get keys() {
      return Object.keys(t);
    },
    __type: {}
  };
}
const wE = rt("accordion").parts(
  "root",
  "container",
  "button",
  "panel",
  "icon"
), PE = rt("alert").parts(
  "title",
  "description",
  "container",
  "icon",
  "spinner"
), kE = rt("avatar").parts(
  "label",
  "badge",
  "container",
  "excessLabel",
  "group"
), AE = rt("breadcrumb").parts(
  "link",
  "item",
  "container",
  "separator"
);
rt("button").parts();
const TE = rt("checkbox").parts(
  "control",
  "icon",
  "container",
  "label"
);
rt("progress").parts(
  "track",
  "filledTrack",
  "label"
);
const EE = rt("drawer").parts(
  "overlay",
  "dialogContainer",
  "dialog",
  "header",
  "closeButton",
  "body",
  "footer"
), RE = rt("editable").parts(
  "preview",
  "input",
  "textarea"
), _E = rt("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
), OE = rt("formError").parts("text", "icon"), NE = rt("input").parts(
  "addon",
  "field",
  "element",
  "group"
), ME = rt("list").parts("container", "item", "icon"), BE = rt("menu").parts(
  "button",
  "list",
  "item",
  "groupTitle",
  "icon",
  "command",
  "divider"
), FE = rt("modal").parts(
  "overlay",
  "dialogContainer",
  "dialog",
  "header",
  "closeButton",
  "body",
  "footer"
), DE = rt("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
rt("pininput").parts("field");
const $E = rt("popover").parts(
  "content",
  "header",
  "body",
  "footer",
  "popper",
  "arrow",
  "closeButton"
), VE = rt("progress").parts(
  "label",
  "filledTrack",
  "track"
), LE = rt("radio").parts(
  "container",
  "control",
  "label"
), zE = rt("select").parts("field", "icon"), GE = rt("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
), WE = rt("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
), HE = rt("switch").parts(
  "container",
  "track",
  "thumb",
  "label"
), jE = rt("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
), XE = rt("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
), YE = rt("tag").parts(
  "container",
  "label",
  "closeButton"
), ZE = rt("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
rt("stepper").parts(
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
);
const { definePartsStyle: UE, defineMultiStyleConfig: JE } = ct(wE.keys), KE = {
  borderTopWidth: "1px",
  borderColor: "inherit",
  _last: {
    borderBottomWidth: "1px"
  }
}, qE = {
  transitionProperty: "common",
  transitionDuration: "normal",
  fontSize: "md",
  _focusVisible: {
    boxShadow: "outline"
  },
  _hover: {
    bg: "blackAlpha.50"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  px: "4",
  py: "2"
}, QE = {
  pt: "2",
  px: "4",
  pb: "5"
}, e2 = {
  fontSize: "1.25em"
}, t2 = UE({
  container: KE,
  button: qE,
  panel: QE,
  icon: e2
}), n2 = JE({ baseStyle: t2 });
function wo(e, t, n) {
  return Math.min(Math.max(e, n), t);
}
class r2 extends Error {
  constructor(t) {
    super(`Failed to parse color: "${t}"`);
  }
}
var Ts = r2;
function sh(e) {
  if (typeof e != "string") throw new Ts(e);
  if (e.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
  let t = e.trim();
  t = d2.test(e) ? s2(e) : e;
  const n = a2.exec(t);
  if (n) {
    const s = Array.from(n).slice(1);
    return [...s.slice(0, 3).map((a) => parseInt(qs(a, 2), 16)), parseInt(qs(s[3] || "f", 2), 16) / 255];
  }
  const r = c2.exec(t);
  if (r) {
    const s = Array.from(r).slice(1);
    return [...s.slice(0, 3).map((a) => parseInt(a, 16)), parseInt(s[3] || "ff", 16) / 255];
  }
  const o = l2.exec(t);
  if (o) {
    const s = Array.from(o).slice(1);
    return [...s.slice(0, 3).map((a) => parseInt(a, 10)), parseFloat(s[3] || "1")];
  }
  const i = u2.exec(t);
  if (i) {
    const [s, a, c, l] = Array.from(i).slice(1).map(parseFloat);
    if (wo(0, 100, a) !== a) throw new Ts(e);
    if (wo(0, 100, c) !== c) throw new Ts(e);
    return [...f2(s, a, c), Number.isNaN(l) ? 1 : l];
  }
  throw new Ts(e);
}
function o2(e) {
  let t = 5381, n = e.length;
  for (; n; )
    t = t * 33 ^ e.charCodeAt(--n);
  return (t >>> 0) % 2341;
}
const Dg = (e) => parseInt(e.replace(/_/g, ""), 36), i2 = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((e, t) => {
  const n = Dg(t.substring(0, 3)), r = Dg(t.substring(3)).toString(16);
  let o = "";
  for (let i = 0; i < 6 - r.length; i++)
    o += "0";
  return e[n] = `${o}${r}`, e;
}, {});
function s2(e) {
  const t = e.toLowerCase().trim(), n = i2[o2(t)];
  if (!n) throw new Ts(e);
  return `#${n}`;
}
const qs = (e, t) => Array.from(Array(t)).map(() => e).join(""), a2 = new RegExp(`^#${qs("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), c2 = new RegExp(`^#${qs("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), l2 = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${qs(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), u2 = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, d2 = /^[a-z]+$/i, $g = (e) => Math.round(e * 255), f2 = (e, t, n) => {
  let r = n / 100;
  if (t === 0)
    return [r, r, r].map($g);
  const o = (e % 360 + 360) % 360 / 60, i = (1 - Math.abs(2 * r - 1)) * (t / 100), s = i * (1 - Math.abs(o % 2 - 1));
  let a = 0, c = 0, l = 0;
  o >= 0 && o < 1 ? (a = i, c = s) : o >= 1 && o < 2 ? (a = s, c = i) : o >= 2 && o < 3 ? (c = i, l = s) : o >= 3 && o < 4 ? (c = s, l = i) : o >= 4 && o < 5 ? (a = s, l = i) : o >= 5 && o < 6 && (a = i, l = s);
  const u = r - i / 2, d = a + u, f = c + u, p = l + u;
  return [d, f, p].map($g);
};
function p2(e, t, n, r) {
  return `rgba(${wo(0, 255, e).toFixed()}, ${wo(0, 255, t).toFixed()}, ${wo(0, 255, n).toFixed()}, ${parseFloat(wo(0, 1, r).toFixed(3))})`;
}
function h2(e, t) {
  const [n, r, o, i] = sh(e);
  return p2(n, r, o, i - t);
}
function m2(e) {
  const [t, n, r, o] = sh(e);
  let i = (s) => {
    const a = wo(0, 255, s).toString(16);
    return a.length === 1 ? `0${a}` : a;
  };
  return `#${i(t)}${i(n)}${i(r)}${o < 1 ? i(Math.round(o * 255)) : ""}`;
}
const g2 = (e) => Object.keys(e).length === 0;
function b2(e, t, n, r, o) {
  for (t = t.split ? t.split(".") : t, r = 0; r < t.length; r++)
    e = e ? e[t[r]] : o;
  return e === o ? n : e;
}
const on = (e, t, n) => {
  const r = b2(e, `colors.${t}`, t);
  try {
    return m2(r), r;
  } catch {
    return n ?? "#000000";
  }
}, v2 = (e) => {
  const [t, n, r] = sh(e);
  return (t * 299 + n * 587 + r * 114) / 1e3;
}, y2 = (e) => (t) => {
  const n = on(t, e);
  return v2(n) < 128 ? "dark" : "light";
}, S2 = (e) => (t) => y2(e)(t) === "dark", ji = (e, t) => (n) => {
  const r = on(n, e);
  return h2(r, 1 - t);
};
function Vg(e = "1rem", t = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${t} 25%,
    transparent 25%,
    transparent 50%,
    ${t} 50%,
    ${t} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${e} ${e}`
  };
}
const x2 = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
function C2(e) {
  const t = x2();
  return !e || g2(e) ? t : e.string && e.colors ? w2(e.string, e.colors) : e.string && !e.colors ? I2(e.string) : e.colors && !e.string ? P2(e.colors) : t;
}
function I2(e) {
  let t = 0;
  if (e.length === 0)
    return t.toString();
  for (let r = 0; r < e.length; r += 1)
    t = e.charCodeAt(r) + ((t << 5) - t), t = t & t;
  let n = "#";
  for (let r = 0; r < 3; r += 1) {
    const o = t >> r * 8 & 255;
    n += `00${o.toString(16)}`.substr(-2);
  }
  return n;
}
function w2(e, t) {
  let n = 0;
  if (e.length === 0)
    return t[0];
  for (let r = 0; r < e.length; r += 1)
    n = e.charCodeAt(r) + ((n << 5) - n), n = n & n;
  return n = (n % t.length + t.length) % t.length, t[n];
}
function P2(e) {
  return e[Math.floor(Math.random() * e.length)];
}
function Ne(e, t) {
  return (n) => n.colorMode === "dark" ? t : e;
}
function ah(e) {
  const { orientation: t, vertical: n, horizontal: r } = e;
  return t ? t === "vertical" ? n : r : {};
}
function c1(e) {
  return Mt(e) && e.reference ? e.reference : String(e);
}
const Zl = (e, ...t) => t.map(c1).join(` ${e} `).replace(/calc/g, ""), Lg = (...e) => `calc(${Zl("+", ...e)})`, zg = (...e) => `calc(${Zl("-", ...e)})`, Vf = (...e) => `calc(${Zl("*", ...e)})`, Gg = (...e) => `calc(${Zl("/", ...e)})`, Wg = (e) => {
  const t = c1(e);
  return t != null && !Number.isNaN(parseFloat(t)) ? String(t).startsWith("-") ? String(t).slice(1) : `-${t}` : Vf(t, -1);
}, Rr = Object.assign(
  (e) => ({
    add: (...t) => Rr(Lg(e, ...t)),
    subtract: (...t) => Rr(zg(e, ...t)),
    multiply: (...t) => Rr(Vf(e, ...t)),
    divide: (...t) => Rr(Gg(e, ...t)),
    negate: () => Rr(Wg(e)),
    toString: () => e.toString()
  }),
  {
    add: Lg,
    subtract: zg,
    multiply: Vf,
    divide: Gg,
    negate: Wg
  }
);
function k2(e) {
  return !Number.isInteger(parseFloat(e.toString()));
}
function A2(e, t = "-") {
  return e.replace(/\s+/g, t);
}
function l1(e) {
  const t = A2(e.toString());
  return t.includes("\\.") ? e : k2(e) ? t.replace(".", "\\.") : e;
}
function T2(e, t = "") {
  return [t, l1(e)].filter(Boolean).join("-");
}
function E2(e, t) {
  return `var(${l1(e)}${t ? `, ${t}` : ""})`;
}
function R2(e, t = "") {
  return `--${T2(e, t)}`;
}
function zt(e, t) {
  const n = R2(e, t?.prefix);
  return {
    variable: n,
    reference: E2(n, _2(t?.fallback))
  };
}
function _2(e) {
  return e?.reference;
}
const { definePartsStyle: Ia, defineMultiStyleConfig: O2 } = ct(PE.keys), Cn = Te("alert-fg"), Lr = Te("alert-bg"), N2 = Ia({
  container: {
    bg: Lr.reference,
    px: "4",
    py: "3"
  },
  title: {
    fontWeight: "bold",
    lineHeight: "6",
    marginEnd: "2"
  },
  description: {
    lineHeight: "6"
  },
  icon: {
    color: Cn.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "6"
  },
  spinner: {
    color: Cn.reference,
    flexShrink: 0,
    marginEnd: "3",
    w: "5",
    h: "5"
  }
});
function ch(e) {
  const { theme: t, colorScheme: n } = e, r = ji(`${n}.200`, 0.16)(t);
  return {
    light: `colors.${n}.100`,
    dark: r
  };
}
const M2 = Ia((e) => {
  const { colorScheme: t } = e, n = ch(e);
  return {
    container: {
      [Cn.variable]: `colors.${t}.600`,
      [Lr.variable]: n.light,
      _dark: {
        [Cn.variable]: `colors.${t}.200`,
        [Lr.variable]: n.dark
      }
    }
  };
}), B2 = Ia((e) => {
  const { colorScheme: t } = e, n = ch(e);
  return {
    container: {
      [Cn.variable]: `colors.${t}.600`,
      [Lr.variable]: n.light,
      _dark: {
        [Cn.variable]: `colors.${t}.200`,
        [Lr.variable]: n.dark
      },
      paddingStart: "3",
      borderStartWidth: "4px",
      borderStartColor: Cn.reference
    }
  };
}), F2 = Ia((e) => {
  const { colorScheme: t } = e, n = ch(e);
  return {
    container: {
      [Cn.variable]: `colors.${t}.600`,
      [Lr.variable]: n.light,
      _dark: {
        [Cn.variable]: `colors.${t}.200`,
        [Lr.variable]: n.dark
      },
      pt: "2",
      borderTopWidth: "4px",
      borderTopColor: Cn.reference
    }
  };
}), D2 = Ia((e) => {
  const { colorScheme: t } = e;
  return {
    container: {
      [Cn.variable]: "colors.white",
      [Lr.variable]: `colors.${t}.600`,
      _dark: {
        [Cn.variable]: "colors.gray.900",
        [Lr.variable]: `colors.${t}.200`
      },
      color: Cn.reference
    }
  };
}), $2 = {
  subtle: M2,
  "left-accent": B2,
  "top-accent": F2,
  solid: D2
}, V2 = O2({
  baseStyle: N2,
  variants: $2,
  defaultProps: {
    variant: "subtle",
    colorScheme: "blue"
  }
}), u1 = {
  px: "1px",
  0.5: "0.125rem",
  1: "0.25rem",
  1.5: "0.375rem",
  2: "0.5rem",
  2.5: "0.625rem",
  3: "0.75rem",
  3.5: "0.875rem",
  4: "1rem",
  5: "1.25rem",
  6: "1.5rem",
  7: "1.75rem",
  8: "2rem",
  9: "2.25rem",
  10: "2.5rem",
  12: "3rem",
  14: "3.5rem",
  16: "4rem",
  20: "5rem",
  24: "6rem",
  28: "7rem",
  32: "8rem",
  36: "9rem",
  40: "10rem",
  44: "11rem",
  48: "12rem",
  52: "13rem",
  56: "14rem",
  60: "15rem",
  64: "16rem",
  72: "18rem",
  80: "20rem",
  96: "24rem"
}, L2 = {
  max: "max-content",
  min: "min-content",
  full: "100%",
  "3xs": "14rem",
  "2xs": "16rem",
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  "2xl": "42rem",
  "3xl": "48rem",
  "4xl": "56rem",
  "5xl": "64rem",
  "6xl": "72rem",
  "7xl": "80rem",
  "8xl": "90rem",
  prose: "60ch"
}, z2 = {
  sm: "640px",
  md: "768px",
  lg: "1024px",
  xl: "1280px"
}, d1 = {
  ...u1,
  ...L2,
  container: z2
}, G2 = (e) => typeof e == "function";
function sn(e, ...t) {
  return G2(e) ? e(...t) : e;
}
const { definePartsStyle: f1, defineMultiStyleConfig: W2 } = ct(kE.keys), Ni = Te("avatar-border-color"), Vs = Te("avatar-bg"), Qs = Te("avatar-font-size"), Xi = Te("avatar-size"), H2 = {
  borderRadius: "full",
  border: "0.2em solid",
  borderColor: Ni.reference,
  [Ni.variable]: "white",
  _dark: {
    [Ni.variable]: "colors.gray.800"
  }
}, j2 = {
  bg: Vs.reference,
  fontSize: Qs.reference,
  width: Xi.reference,
  height: Xi.reference,
  lineHeight: "1",
  [Vs.variable]: "colors.gray.200",
  _dark: {
    [Vs.variable]: "colors.whiteAlpha.400"
  }
}, X2 = (e) => {
  const { name: t, theme: n } = e, r = t ? C2({ string: t }) : "colors.gray.400", o = S2(r)(n);
  let i = "white";
  return o || (i = "gray.800"), {
    bg: Vs.reference,
    fontSize: Qs.reference,
    color: i,
    borderColor: Ni.reference,
    verticalAlign: "top",
    width: Xi.reference,
    height: Xi.reference,
    "&:not([data-loaded])": {
      [Vs.variable]: r
    },
    [Ni.variable]: "colors.white",
    _dark: {
      [Ni.variable]: "colors.gray.800"
    }
  };
}, Y2 = {
  fontSize: Qs.reference,
  lineHeight: "1"
}, Z2 = f1((e) => ({
  badge: sn(H2, e),
  excessLabel: sn(j2, e),
  container: sn(X2, e),
  label: Y2
}));
function jr(e) {
  const t = e !== "100%" ? d1[e] : void 0;
  return f1({
    container: {
      [Xi.variable]: t ?? e,
      [Qs.variable]: `calc(${t ?? e} / 2.5)`
    },
    excessLabel: {
      [Xi.variable]: t ?? e,
      [Qs.variable]: `calc(${t ?? e} / 2.5)`
    }
  });
}
const U2 = {
  "2xs": jr(4),
  xs: jr(6),
  sm: jr(8),
  md: jr(12),
  lg: jr(16),
  xl: jr(24),
  "2xl": jr(32),
  full: jr("100%")
}, J2 = W2({
  baseStyle: Z2,
  sizes: U2,
  defaultProps: {
    size: "md"
  }
}), Nt = gE("badge", ["bg", "color", "shadow"]), K2 = {
  px: 1,
  textTransform: "uppercase",
  fontSize: "xs",
  borderRadius: "sm",
  fontWeight: "bold",
  bg: Nt.bg.reference,
  color: Nt.color.reference,
  boxShadow: Nt.shadow.reference
}, q2 = (e) => {
  const { colorScheme: t, theme: n } = e, r = ji(`${t}.500`, 0.6)(n);
  return {
    [Nt.bg.variable]: `colors.${t}.500`,
    [Nt.color.variable]: "colors.white",
    _dark: {
      [Nt.bg.variable]: r,
      [Nt.color.variable]: "colors.whiteAlpha.800"
    }
  };
}, Q2 = (e) => {
  const { colorScheme: t, theme: n } = e, r = ji(`${t}.200`, 0.16)(n);
  return {
    [Nt.bg.variable]: `colors.${t}.100`,
    [Nt.color.variable]: `colors.${t}.800`,
    _dark: {
      [Nt.bg.variable]: r,
      [Nt.color.variable]: `colors.${t}.200`
    }
  };
}, eR = (e) => {
  const { colorScheme: t, theme: n } = e, r = ji(`${t}.200`, 0.8)(n);
  return {
    [Nt.color.variable]: `colors.${t}.500`,
    _dark: {
      [Nt.color.variable]: r
    },
    [Nt.shadow.variable]: `inset 0 0 0px 1px ${Nt.color.reference}`
  };
}, tR = {
  solid: q2,
  subtle: Q2,
  outline: eR
}, Ls = {
  baseStyle: K2,
  variants: tR,
  defaultProps: {
    variant: "subtle",
    colorScheme: "gray"
  }
}, { defineMultiStyleConfig: nR, definePartsStyle: rR } = ct(AE.keys), ud = Te("breadcrumb-link-decor"), oR = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  outline: "none",
  color: "inherit",
  textDecoration: ud.reference,
  [ud.variable]: "none",
  "&:not([aria-current=page])": {
    cursor: "pointer",
    _hover: {
      [ud.variable]: "underline"
    },
    _focusVisible: {
      boxShadow: "outline"
    }
  }
}, iR = rR({
  link: oR
}), sR = nR({
  baseStyle: iR
}), aR = {
  lineHeight: "1.2",
  borderRadius: "md",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  _focusVisible: {
    boxShadow: "outline"
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    _disabled: {
      bg: "initial"
    }
  }
}, p1 = (e) => {
  const { colorScheme: t, theme: n } = e;
  if (t === "gray")
    return {
      color: Ne("gray.800", "whiteAlpha.900")(e),
      _hover: {
        bg: Ne("gray.100", "whiteAlpha.200")(e)
      },
      _active: { bg: Ne("gray.200", "whiteAlpha.300")(e) }
    };
  const r = ji(`${t}.200`, 0.12)(n), o = ji(`${t}.200`, 0.24)(n);
  return {
    color: Ne(`${t}.600`, `${t}.200`)(e),
    bg: "transparent",
    _hover: {
      bg: Ne(`${t}.50`, r)(e)
    },
    _active: {
      bg: Ne(`${t}.100`, o)(e)
    }
  };
}, cR = (e) => {
  const { colorScheme: t } = e, n = Ne("gray.200", "whiteAlpha.300")(e);
  return {
    border: "1px solid",
    borderColor: t === "gray" ? n : "currentColor",
    ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
    ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
    ...sn(p1, e)
  };
}, lR = {
  yellow: {
    bg: "yellow.400",
    color: "black",
    hoverBg: "yellow.500",
    activeBg: "yellow.600"
  },
  cyan: {
    bg: "cyan.400",
    color: "black",
    hoverBg: "cyan.500",
    activeBg: "cyan.600"
  }
}, uR = (e) => {
  const { colorScheme: t } = e;
  if (t === "gray") {
    const a = Ne("gray.100", "whiteAlpha.200")(e);
    return {
      bg: a,
      color: Ne("gray.800", "whiteAlpha.900")(e),
      _hover: {
        bg: Ne("gray.200", "whiteAlpha.300")(e),
        _disabled: {
          bg: a
        }
      },
      _active: { bg: Ne("gray.300", "whiteAlpha.400")(e) }
    };
  }
  const {
    bg: n = `${t}.500`,
    color: r = "white",
    hoverBg: o = `${t}.600`,
    activeBg: i = `${t}.700`
  } = lR[t] ?? {}, s = Ne(n, `${t}.200`)(e);
  return {
    bg: s,
    color: Ne(r, "gray.800")(e),
    _hover: {
      bg: Ne(o, `${t}.300`)(e),
      _disabled: {
        bg: s
      }
    },
    _active: { bg: Ne(i, `${t}.400`)(e) }
  };
}, dR = (e) => {
  const { colorScheme: t } = e;
  return {
    padding: 0,
    height: "auto",
    lineHeight: "normal",
    verticalAlign: "baseline",
    color: Ne(`${t}.500`, `${t}.200`)(e),
    _hover: {
      textDecoration: "underline",
      _disabled: {
        textDecoration: "none"
      }
    },
    _active: {
      color: Ne(`${t}.700`, `${t}.500`)(e)
    }
  };
}, fR = {
  bg: "none",
  color: "inherit",
  display: "inline",
  lineHeight: "inherit",
  m: "0",
  p: "0"
}, pR = {
  ghost: p1,
  outline: cR,
  solid: uR,
  link: dR,
  unstyled: fR
}, hR = {
  lg: {
    h: "12",
    minW: "12",
    fontSize: "lg",
    px: "6"
  },
  md: {
    h: "10",
    minW: "10",
    fontSize: "md",
    px: "4"
  },
  sm: {
    h: "8",
    minW: "8",
    fontSize: "sm",
    px: "3"
  },
  xs: {
    h: "6",
    minW: "6",
    fontSize: "xs",
    px: "2"
  }
}, mR = {
  baseStyle: aR,
  variants: pR,
  sizes: hR,
  defaultProps: {
    variant: "solid",
    size: "md",
    colorScheme: "gray"
  }
}, { definePartsStyle: Ro, defineMultiStyleConfig: gR } = ct(ZE.keys), ol = Te("card-bg"), Br = Te("card-padding"), h1 = Te("card-shadow"), Tc = Te("card-radius"), m1 = Te("card-border-width", "0"), g1 = Te("card-border-color"), bR = Ro({
  container: {
    [ol.variable]: "colors.chakra-body-bg",
    backgroundColor: ol.reference,
    boxShadow: h1.reference,
    borderRadius: Tc.reference,
    color: "chakra-body-text",
    borderWidth: m1.reference,
    borderColor: g1.reference
  },
  body: {
    padding: Br.reference,
    flex: "1 1 0%"
  },
  header: {
    padding: Br.reference
  },
  footer: {
    padding: Br.reference
  }
}), vR = {
  sm: Ro({
    container: {
      [Tc.variable]: "radii.base",
      [Br.variable]: "space.3"
    }
  }),
  md: Ro({
    container: {
      [Tc.variable]: "radii.md",
      [Br.variable]: "space.5"
    }
  }),
  lg: Ro({
    container: {
      [Tc.variable]: "radii.xl",
      [Br.variable]: "space.7"
    }
  })
}, yR = {
  elevated: Ro({
    container: {
      [h1.variable]: "shadows.base",
      _dark: {
        [ol.variable]: "colors.gray.700"
      }
    }
  }),
  outline: Ro({
    container: {
      [m1.variable]: "1px",
      [g1.variable]: "colors.chakra-border-color"
    }
  }),
  filled: Ro({
    container: {
      [ol.variable]: "colors.chakra-subtle-bg"
    }
  }),
  unstyled: {
    body: {
      [Br.variable]: 0
    },
    header: {
      [Br.variable]: 0
    },
    footer: {
      [Br.variable]: 0
    }
  }
}, SR = gR({
  baseStyle: bR,
  variants: yR,
  sizes: vR,
  defaultProps: {
    variant: "elevated",
    size: "md"
  }
}), { definePartsStyle: Ec, defineMultiStyleConfig: xR } = ct(TE.keys), zs = Te("checkbox-size"), CR = (e) => {
  const { colorScheme: t } = e;
  return {
    w: zs.reference,
    h: zs.reference,
    transitionProperty: "box-shadow",
    transitionDuration: "normal",
    border: "2px solid",
    borderRadius: "sm",
    borderColor: "inherit",
    color: "white",
    _checked: {
      bg: Ne(`${t}.500`, `${t}.200`)(e),
      borderColor: Ne(`${t}.500`, `${t}.200`)(e),
      color: Ne("white", "gray.900")(e),
      _hover: {
        bg: Ne(`${t}.600`, `${t}.300`)(e),
        borderColor: Ne(`${t}.600`, `${t}.300`)(e)
      },
      _disabled: {
        borderColor: Ne("gray.200", "transparent")(e),
        bg: Ne("gray.200", "whiteAlpha.300")(e),
        color: Ne("gray.500", "whiteAlpha.500")(e)
      }
    },
    _indeterminate: {
      bg: Ne(`${t}.500`, `${t}.200`)(e),
      borderColor: Ne(`${t}.500`, `${t}.200`)(e),
      color: Ne("white", "gray.900")(e)
    },
    _disabled: {
      bg: Ne("gray.100", "whiteAlpha.100")(e),
      borderColor: Ne("gray.100", "transparent")(e)
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _invalid: {
      borderColor: Ne("red.500", "red.300")(e)
    }
  };
}, IR = {
  _disabled: { cursor: "not-allowed" }
}, wR = {
  userSelect: "none",
  _disabled: { opacity: 0.4 }
}, PR = {
  transitionProperty: "transform",
  transitionDuration: "normal"
}, kR = Ec((e) => ({
  icon: PR,
  container: IR,
  control: sn(CR, e),
  label: wR
})), AR = {
  sm: Ec({
    control: { [zs.variable]: "sizes.3" },
    label: { fontSize: "sm" },
    icon: { fontSize: "3xs" }
  }),
  md: Ec({
    control: { [zs.variable]: "sizes.4" },
    label: { fontSize: "md" },
    icon: { fontSize: "2xs" }
  }),
  lg: Ec({
    control: { [zs.variable]: "sizes.5" },
    label: { fontSize: "lg" },
    icon: { fontSize: "2xs" }
  })
}, il = xR({
  baseStyle: kR,
  sizes: AR,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), Gs = zt("close-button-size"), ps = zt("close-button-bg"), TR = {
  w: [Gs.reference],
  h: [Gs.reference],
  borderRadius: "md",
  transitionProperty: "common",
  transitionDuration: "normal",
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed",
    boxShadow: "none"
  },
  _hover: {
    [ps.variable]: "colors.blackAlpha.100",
    _dark: {
      [ps.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [ps.variable]: "colors.blackAlpha.200",
    _dark: {
      [ps.variable]: "colors.whiteAlpha.200"
    }
  },
  _focusVisible: {
    boxShadow: "outline"
  },
  bg: ps.reference
}, ER = {
  lg: {
    [Gs.variable]: "sizes.10",
    fontSize: "md"
  },
  md: {
    [Gs.variable]: "sizes.8",
    fontSize: "xs"
  },
  sm: {
    [Gs.variable]: "sizes.6",
    fontSize: "2xs"
  }
}, RR = {
  baseStyle: TR,
  sizes: ER,
  defaultProps: {
    size: "md"
  }
}, { variants: _R, defaultProps: OR } = Ls, NR = {
  fontFamily: "mono",
  fontSize: "sm",
  px: "0.2em",
  borderRadius: "sm",
  bg: Nt.bg.reference,
  color: Nt.color.reference,
  boxShadow: Nt.shadow.reference
}, MR = {
  baseStyle: NR,
  variants: _R,
  defaultProps: OR
}, BR = {
  w: "100%",
  mx: "auto",
  maxW: "prose",
  px: "4"
}, FR = {
  baseStyle: BR
}, DR = {
  opacity: 0.6,
  borderColor: "inherit"
}, $R = {
  borderStyle: "solid"
}, VR = {
  borderStyle: "dashed"
}, LR = {
  solid: $R,
  dashed: VR
}, zR = {
  baseStyle: DR,
  variants: LR,
  defaultProps: {
    variant: "solid"
  }
}, { definePartsStyle: Lf, defineMultiStyleConfig: GR } = ct(EE.keys), dd = Te("drawer-bg"), fd = Te("drawer-box-shadow");
function si(e) {
  return Lf(e === "full" ? {
    dialog: { maxW: "100vw", h: "100vh" }
  } : {
    dialog: { maxW: e }
  });
}
const WR = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, HR = {
  display: "flex",
  zIndex: "modal",
  justifyContent: "center"
}, jR = (e) => {
  const { isFullHeight: t } = e;
  return {
    ...t && { height: "100vh" },
    zIndex: "modal",
    maxH: "100vh",
    color: "inherit",
    [dd.variable]: "colors.white",
    [fd.variable]: "shadows.lg",
    _dark: {
      [dd.variable]: "colors.gray.700",
      [fd.variable]: "shadows.dark-lg"
    },
    bg: dd.reference,
    boxShadow: fd.reference
  };
}, XR = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, YR = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, ZR = {
  px: "6",
  py: "2",
  flex: "1",
  overflow: "auto"
}, UR = {
  px: "6",
  py: "4"
}, JR = Lf((e) => ({
  overlay: WR,
  dialogContainer: HR,
  dialog: sn(jR, e),
  header: XR,
  closeButton: YR,
  body: ZR,
  footer: UR
})), KR = {
  xs: si("xs"),
  sm: si("md"),
  md: si("lg"),
  lg: si("2xl"),
  xl: si("4xl"),
  full: si("full")
}, qR = GR({
  baseStyle: JR,
  sizes: KR,
  defaultProps: {
    size: "xs"
  }
}), { definePartsStyle: QR, defineMultiStyleConfig: e_ } = ct(RE.keys), t_ = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal"
}, n_ = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, r_ = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, o_ = QR({
  preview: t_,
  input: n_,
  textarea: r_
}), i_ = e_({
  baseStyle: o_
}), { definePartsStyle: s_, defineMultiStyleConfig: a_ } = ct(_E.keys), Mi = Te("form-control-color"), c_ = {
  marginStart: "1",
  [Mi.variable]: "colors.red.500",
  _dark: {
    [Mi.variable]: "colors.red.300"
  },
  color: Mi.reference
}, l_ = {
  mt: "2",
  [Mi.variable]: "colors.gray.600",
  _dark: {
    [Mi.variable]: "colors.whiteAlpha.600"
  },
  color: Mi.reference,
  lineHeight: "normal",
  fontSize: "sm"
}, u_ = s_({
  container: {
    width: "100%",
    position: "relative"
  },
  requiredIndicator: c_,
  helperText: l_
}), d_ = a_({
  baseStyle: u_
}), { definePartsStyle: f_, defineMultiStyleConfig: p_ } = ct(OE.keys), Bi = Te("form-error-color"), h_ = {
  [Bi.variable]: "colors.red.500",
  _dark: {
    [Bi.variable]: "colors.red.300"
  },
  color: Bi.reference,
  mt: "2",
  fontSize: "sm",
  lineHeight: "normal"
}, m_ = {
  marginEnd: "0.5em",
  [Bi.variable]: "colors.red.500",
  _dark: {
    [Bi.variable]: "colors.red.300"
  },
  color: Bi.reference
}, g_ = f_({
  text: h_,
  icon: m_
}), b_ = p_({
  baseStyle: g_
}), v_ = {
  fontSize: "md",
  marginEnd: "3",
  mb: "2",
  fontWeight: "medium",
  transitionProperty: "common",
  transitionDuration: "normal",
  opacity: 1,
  _disabled: {
    opacity: 0.4
  }
}, y_ = {
  baseStyle: v_
}, S_ = {
  fontFamily: "heading",
  fontWeight: "bold"
}, x_ = {
  "4xl": {
    fontSize: ["6xl", null, "7xl"],
    lineHeight: 1
  },
  "3xl": {
    fontSize: ["5xl", null, "6xl"],
    lineHeight: 1
  },
  "2xl": {
    fontSize: ["4xl", null, "5xl"],
    lineHeight: [1.2, null, 1]
  },
  xl: {
    fontSize: ["3xl", null, "4xl"],
    lineHeight: [1.33, null, 1.2]
  },
  lg: {
    fontSize: ["2xl", null, "3xl"],
    lineHeight: [1.33, null, 1.2]
  },
  md: {
    fontSize: "xl",
    lineHeight: 1.2
  },
  sm: {
    fontSize: "md",
    lineHeight: 1.2
  },
  xs: {
    fontSize: "sm",
    lineHeight: 1.2
  }
}, C_ = {
  baseStyle: S_,
  sizes: x_,
  defaultProps: {
    size: "xl"
  }
}, { definePartsStyle: Nr, defineMultiStyleConfig: I_ } = ct(NE.keys), mi = Te("input-height"), gi = Te("input-font-size"), bi = Te("input-padding"), vi = Te("input-border-radius"), w_ = Nr({
  addon: {
    height: mi.reference,
    fontSize: gi.reference,
    px: bi.reference,
    borderRadius: vi.reference
  },
  field: {
    width: "100%",
    height: mi.reference,
    fontSize: gi.reference,
    px: bi.reference,
    borderRadius: vi.reference,
    minWidth: 0,
    outline: 0,
    position: "relative",
    appearance: "none",
    transitionProperty: "common",
    transitionDuration: "normal",
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    }
  }
}), Xr = {
  lg: {
    [gi.variable]: "fontSizes.lg",
    [bi.variable]: "space.4",
    [vi.variable]: "radii.md",
    [mi.variable]: "sizes.12"
  },
  md: {
    [gi.variable]: "fontSizes.md",
    [bi.variable]: "space.4",
    [vi.variable]: "radii.md",
    [mi.variable]: "sizes.10"
  },
  sm: {
    [gi.variable]: "fontSizes.sm",
    [bi.variable]: "space.3",
    [vi.variable]: "radii.sm",
    [mi.variable]: "sizes.8"
  },
  xs: {
    [gi.variable]: "fontSizes.xs",
    [bi.variable]: "space.2",
    [vi.variable]: "radii.sm",
    [mi.variable]: "sizes.6"
  }
}, P_ = {
  lg: Nr({
    field: Xr.lg,
    group: Xr.lg
  }),
  md: Nr({
    field: Xr.md,
    group: Xr.md
  }),
  sm: Nr({
    field: Xr.sm,
    group: Xr.sm
  }),
  xs: Nr({
    field: Xr.xs,
    group: Xr.xs
  })
};
function lh(e) {
  const { focusBorderColor: t, errorBorderColor: n } = e;
  return {
    focusBorderColor: t || Ne("blue.500", "blue.300")(e),
    errorBorderColor: n || Ne("red.500", "red.300")(e)
  };
}
const k_ = Nr((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: r } = lh(e);
  return {
    field: {
      border: "1px solid",
      borderColor: "inherit",
      bg: "inherit",
      _hover: {
        borderColor: Ne("gray.300", "whiteAlpha.400")(e)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: on(t, r),
        boxShadow: `0 0 0 1px ${on(t, r)}`
      },
      _focusVisible: {
        zIndex: 1,
        borderColor: on(t, n),
        boxShadow: `0 0 0 1px ${on(t, n)}`
      }
    },
    addon: {
      border: "1px solid",
      borderColor: Ne("inherit", "whiteAlpha.50")(e),
      bg: Ne("gray.100", "whiteAlpha.300")(e)
    }
  };
}), A_ = Nr((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: r } = lh(e);
  return {
    field: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Ne("gray.100", "whiteAlpha.50")(e),
      _hover: {
        bg: Ne("gray.200", "whiteAlpha.100")(e)
      },
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: on(t, r)
      },
      _focusVisible: {
        bg: "transparent",
        borderColor: on(t, n)
      }
    },
    addon: {
      border: "2px solid",
      borderColor: "transparent",
      bg: Ne("gray.100", "whiteAlpha.50")(e)
    }
  };
}), T_ = Nr((e) => {
  const { theme: t } = e, { focusBorderColor: n, errorBorderColor: r } = lh(e);
  return {
    field: {
      borderBottom: "1px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent",
      _readOnly: {
        boxShadow: "none !important",
        userSelect: "all"
      },
      _invalid: {
        borderColor: on(t, r),
        boxShadow: `0px 1px 0px 0px ${on(t, r)}`
      },
      _focusVisible: {
        borderColor: on(t, n),
        boxShadow: `0px 1px 0px 0px ${on(t, n)}`
      }
    },
    addon: {
      borderBottom: "2px solid",
      borderColor: "inherit",
      borderRadius: "0",
      px: "0",
      bg: "transparent"
    }
  };
}), E_ = Nr({
  field: {
    bg: "transparent",
    px: "0",
    height: "auto"
  },
  addon: {
    bg: "transparent",
    px: "0",
    height: "auto"
  }
}), R_ = {
  outline: k_,
  filled: A_,
  flushed: T_,
  unstyled: E_
}, nt = I_({
  baseStyle: w_,
  sizes: P_,
  variants: R_,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}), pd = Te("kbd-bg"), __ = {
  [pd.variable]: "colors.gray.100",
  _dark: {
    [pd.variable]: "colors.whiteAlpha.100"
  },
  bg: pd.reference,
  borderRadius: "md",
  borderWidth: "1px",
  borderBottomWidth: "3px",
  fontSize: "0.8em",
  fontWeight: "bold",
  lineHeight: "normal",
  px: "0.4em",
  whiteSpace: "nowrap"
}, O_ = {
  baseStyle: __
}, N_ = {
  transitionProperty: "common",
  transitionDuration: "fast",
  transitionTimingFunction: "ease-out",
  cursor: "pointer",
  textDecoration: "none",
  outline: "none",
  color: "inherit",
  _hover: {
    textDecoration: "underline"
  },
  _focusVisible: {
    boxShadow: "outline"
  }
}, M_ = {
  baseStyle: N_
}, { defineMultiStyleConfig: B_, definePartsStyle: F_ } = ct(ME.keys), D_ = {
  marginEnd: "2",
  display: "inline",
  verticalAlign: "text-bottom"
}, $_ = F_({
  icon: D_
}), V_ = B_({
  baseStyle: $_
}), { defineMultiStyleConfig: L_, definePartsStyle: z_ } = ct(BE.keys), ar = Te("menu-bg"), hd = Te("menu-shadow"), G_ = {
  [ar.variable]: "#fff",
  [hd.variable]: "shadows.sm",
  _dark: {
    [ar.variable]: "colors.gray.700",
    [hd.variable]: "shadows.dark-lg"
  },
  color: "inherit",
  minW: "3xs",
  py: "2",
  zIndex: "dropdown",
  borderRadius: "md",
  borderWidth: "1px",
  bg: ar.reference,
  boxShadow: hd.reference
}, W_ = {
  py: "1.5",
  px: "3",
  transitionProperty: "background",
  transitionDuration: "ultra-fast",
  transitionTimingFunction: "ease-in",
  _focus: {
    [ar.variable]: "colors.gray.100",
    _dark: {
      [ar.variable]: "colors.whiteAlpha.100"
    }
  },
  _active: {
    [ar.variable]: "colors.gray.200",
    _dark: {
      [ar.variable]: "colors.whiteAlpha.200"
    }
  },
  _expanded: {
    [ar.variable]: "colors.gray.100",
    _dark: {
      [ar.variable]: "colors.whiteAlpha.100"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  },
  bg: ar.reference
}, H_ = {
  mx: 4,
  my: 2,
  fontWeight: "semibold",
  fontSize: "sm"
}, j_ = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0
}, X_ = {
  opacity: 0.6
}, Y_ = {
  border: 0,
  borderBottom: "1px solid",
  borderColor: "inherit",
  my: "2",
  opacity: 0.6
}, Z_ = {
  transitionProperty: "common",
  transitionDuration: "normal"
}, U_ = z_({
  button: Z_,
  list: G_,
  item: W_,
  groupTitle: H_,
  icon: j_,
  command: X_,
  divider: Y_
}), J_ = L_({
  baseStyle: U_
}), { defineMultiStyleConfig: K_, definePartsStyle: zf } = ct(FE.keys), md = Te("modal-bg"), gd = Te("modal-shadow"), q_ = {
  bg: "blackAlpha.600",
  zIndex: "modal"
}, Q_ = (e) => {
  const { isCentered: t, scrollBehavior: n } = e;
  return {
    display: "flex",
    zIndex: "modal",
    justifyContent: "center",
    alignItems: t ? "center" : "flex-start",
    overflow: n === "inside" ? "hidden" : "auto",
    overscrollBehaviorY: "none"
  };
}, eO = (e) => {
  const { isCentered: t, scrollBehavior: n } = e;
  return {
    borderRadius: "md",
    color: "inherit",
    my: t ? "auto" : "16",
    mx: t ? "auto" : void 0,
    zIndex: "modal",
    maxH: n === "inside" ? "calc(100% - 7.5rem)" : void 0,
    [md.variable]: "colors.white",
    [gd.variable]: "shadows.lg",
    _dark: {
      [md.variable]: "colors.gray.700",
      [gd.variable]: "shadows.dark-lg"
    },
    bg: md.reference,
    boxShadow: gd.reference
  };
}, tO = {
  px: "6",
  py: "4",
  fontSize: "xl",
  fontWeight: "semibold"
}, nO = {
  position: "absolute",
  top: "2",
  insetEnd: "3"
}, rO = (e) => {
  const { scrollBehavior: t } = e;
  return {
    px: "6",
    py: "2",
    flex: "1",
    overflow: t === "inside" ? "auto" : void 0
  };
}, oO = {
  px: "6",
  py: "4"
}, iO = zf((e) => ({
  overlay: q_,
  dialogContainer: sn(Q_, e),
  dialog: sn(eO, e),
  header: tO,
  closeButton: nO,
  body: sn(rO, e),
  footer: oO
}));
function Hn(e) {
  return zf(e === "full" ? {
    dialog: {
      maxW: "100vw",
      minH: "$100vh",
      my: "0",
      borderRadius: "0"
    }
  } : {
    dialog: { maxW: e }
  });
}
const sO = {
  xs: Hn("xs"),
  sm: Hn("sm"),
  md: Hn("md"),
  lg: Hn("lg"),
  xl: Hn("xl"),
  "2xl": Hn("2xl"),
  "3xl": Hn("3xl"),
  "4xl": Hn("4xl"),
  "5xl": Hn("5xl"),
  "6xl": Hn("6xl"),
  full: Hn("full")
}, aO = K_({
  baseStyle: iO,
  sizes: sO,
  defaultProps: { size: "md" }
}), b1 = {
  letterSpacings: {
    tighter: "-0.05em",
    tight: "-0.025em",
    normal: "0",
    wide: "0.025em",
    wider: "0.05em",
    widest: "0.1em"
  },
  lineHeights: {
    normal: "normal",
    none: 1,
    shorter: 1.25,
    short: 1.375,
    base: 1.5,
    tall: 1.625,
    taller: "2",
    3: ".75rem",
    4: "1rem",
    5: "1.25rem",
    6: "1.5rem",
    7: "1.75rem",
    8: "2rem",
    9: "2.25rem",
    10: "2.5rem"
  },
  fontWeights: {
    hairline: 100,
    thin: 200,
    light: 300,
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  fonts: {
    heading: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    body: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    mono: 'SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  },
  fontSizes: {
    "3xs": "0.45rem",
    "2xs": "0.625rem",
    xs: "0.75rem",
    sm: "0.875rem",
    md: "1rem",
    lg: "1.125rem",
    xl: "1.25rem",
    "2xl": "1.5rem",
    "3xl": "1.875rem",
    "4xl": "2.25rem",
    "5xl": "3rem",
    "6xl": "3.75rem",
    "7xl": "4.5rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
}, { defineMultiStyleConfig: cO, definePartsStyle: v1 } = ct(DE.keys), uh = zt("number-input-stepper-width"), y1 = zt("number-input-input-padding"), lO = Rr(uh).add("0.5rem").toString(), bd = zt("number-input-bg"), vd = zt("number-input-color"), yd = zt("number-input-border-color"), uO = {
  [uh.variable]: "sizes.6",
  [y1.variable]: lO
}, dO = (e) => sn(nt.baseStyle, e)?.field ?? {}, fO = {
  width: uh.reference
}, pO = {
  borderStart: "1px solid",
  borderStartColor: yd.reference,
  color: vd.reference,
  bg: bd.reference,
  [vd.variable]: "colors.chakra-body-text",
  [yd.variable]: "colors.chakra-border-color",
  _dark: {
    [vd.variable]: "colors.whiteAlpha.800",
    [yd.variable]: "colors.whiteAlpha.300"
  },
  _active: {
    [bd.variable]: "colors.gray.200",
    _dark: {
      [bd.variable]: "colors.whiteAlpha.300"
    }
  },
  _disabled: {
    opacity: 0.4,
    cursor: "not-allowed"
  }
}, hO = v1((e) => ({
  root: uO,
  field: sn(dO, e) ?? {},
  stepperGroup: fO,
  stepper: pO
}));
function Ya(e) {
  const t = nt.sizes?.[e], n = {
    lg: "md",
    md: "md",
    sm: "sm",
    xs: "sm"
  }, r = t.field?.fontSize ?? "md", o = b1.fontSizes[r];
  return v1({
    field: {
      ...t.field,
      paddingInlineEnd: y1.reference,
      verticalAlign: "top"
    },
    stepper: {
      fontSize: Rr(o).multiply(0.75).toString(),
      _first: {
        borderTopEndRadius: n[e]
      },
      _last: {
        borderBottomEndRadius: n[e],
        mt: "-1px",
        borderTopWidth: 1
      }
    }
  });
}
const mO = {
  xs: Ya("xs"),
  sm: Ya("sm"),
  md: Ya("md"),
  lg: Ya("lg")
}, gO = cO({
  baseStyle: hO,
  sizes: mO,
  variants: nt.variants,
  defaultProps: nt.defaultProps
}), bO = {
  ...nt.baseStyle?.field,
  textAlign: "center"
}, vO = {
  lg: {
    fontSize: "lg",
    w: 12,
    h: 12,
    borderRadius: "md"
  },
  md: {
    fontSize: "md",
    w: 10,
    h: 10,
    borderRadius: "md"
  },
  sm: {
    fontSize: "sm",
    w: 8,
    h: 8,
    borderRadius: "sm"
  },
  xs: {
    fontSize: "xs",
    w: 6,
    h: 6,
    borderRadius: "sm"
  }
}, yO = {
  outline: (e) => sn(nt.variants?.outline, e)?.field ?? {},
  flushed: (e) => sn(nt.variants?.flushed, e)?.field ?? {},
  filled: (e) => sn(nt.variants?.filled, e)?.field ?? {},
  unstyled: nt.variants?.unstyled.field ?? {}
}, SO = {
  baseStyle: bO,
  sizes: vO,
  variants: yO,
  defaultProps: nt.defaultProps
}, { defineMultiStyleConfig: xO, definePartsStyle: CO } = ct($E.keys), Za = zt("popper-bg"), IO = zt("popper-arrow-bg"), Hg = zt("popper-arrow-shadow-color"), wO = {
  zIndex: "popover"
}, PO = {
  [Za.variable]: "colors.white",
  bg: Za.reference,
  [IO.variable]: Za.reference,
  [Hg.variable]: "colors.gray.200",
  _dark: {
    [Za.variable]: "colors.gray.700",
    [Hg.variable]: "colors.whiteAlpha.300"
  },
  width: "xs",
  border: "1px solid",
  borderColor: "inherit",
  borderRadius: "md",
  boxShadow: "sm",
  zIndex: "inherit",
  _focusVisible: {
    outline: 0,
    boxShadow: "outline"
  }
}, kO = {
  px: 3,
  py: 2,
  borderBottomWidth: "1px"
}, AO = {
  px: 3,
  py: 2
}, TO = {
  px: 3,
  py: 2,
  borderTopWidth: "1px"
}, EO = {
  position: "absolute",
  borderRadius: "md",
  top: 1,
  insetEnd: 2,
  padding: 2
}, RO = CO({
  popper: wO,
  content: PO,
  header: kO,
  body: AO,
  footer: TO,
  closeButton: EO
}), _O = xO({
  baseStyle: RO
}), { defineMultiStyleConfig: OO, definePartsStyle: Es } = ct(VE.keys), NO = (e) => {
  const { colorScheme: t, theme: n, isIndeterminate: r, hasStripe: o } = e, i = Ne(
    Vg(),
    Vg("1rem", "rgba(0,0,0,0.1)")
  )(e), s = Ne(`${t}.500`, `${t}.200`)(e), a = `linear-gradient(
    to right,
    transparent 0%,
    ${on(n, s)} 50%,
    transparent 100%
  )`;
  return {
    ...!r && o && i,
    ...r ? { bgImage: a } : { bgColor: s }
  };
}, MO = {
  lineHeight: "1",
  fontSize: "0.25em",
  fontWeight: "bold",
  color: "white"
}, BO = (e) => ({
  bg: Ne("gray.100", "whiteAlpha.300")(e)
}), FO = (e) => ({
  transitionProperty: "common",
  transitionDuration: "slow",
  ...NO(e)
}), DO = Es((e) => ({
  label: MO,
  filledTrack: FO(e),
  track: BO(e)
})), $O = {
  xs: Es({
    track: { h: "1" }
  }),
  sm: Es({
    track: { h: "2" }
  }),
  md: Es({
    track: { h: "3" }
  }),
  lg: Es({
    track: { h: "4" }
  })
}, VO = OO({
  sizes: $O,
  baseStyle: DO,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: LO, definePartsStyle: Rc } = ct(LE.keys), zO = (e) => {
  const t = sn(il.baseStyle, e)?.control;
  return {
    ...t,
    borderRadius: "full",
    _checked: {
      ...t?._checked,
      _before: {
        content: '""',
        display: "inline-block",
        pos: "relative",
        w: "50%",
        h: "50%",
        borderRadius: "50%",
        bg: "currentColor"
      }
    }
  };
}, GO = Rc((e) => ({
  label: il.baseStyle?.(e).label,
  container: il.baseStyle?.(e).container,
  control: zO(e)
})), WO = {
  md: Rc({
    control: { w: "4", h: "4" },
    label: { fontSize: "md" }
  }),
  lg: Rc({
    control: { w: "5", h: "5" },
    label: { fontSize: "lg" }
  }),
  sm: Rc({
    control: { width: "3", height: "3" },
    label: { fontSize: "sm" }
  })
}, HO = LO({
  baseStyle: GO,
  sizes: WO,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: jO, definePartsStyle: XO } = ct(zE.keys), Ua = Te("select-bg"), YO = {
  ...nt.baseStyle?.field,
  appearance: "none",
  paddingBottom: "1px",
  lineHeight: "normal",
  bg: Ua.reference,
  [Ua.variable]: "colors.white",
  _dark: {
    [Ua.variable]: "colors.gray.700"
  },
  "> option, > optgroup": {
    bg: Ua.reference
  }
}, ZO = {
  width: "6",
  height: "100%",
  insetEnd: "2",
  position: "relative",
  color: "currentColor",
  fontSize: "xl",
  _disabled: {
    opacity: 0.5
  }
}, UO = XO({
  field: YO,
  icon: ZO
}), Ja = {
  paddingInlineEnd: "8"
}, JO = {
  lg: {
    ...nt.sizes?.lg,
    field: {
      ...nt.sizes?.lg.field,
      ...Ja
    }
  },
  md: {
    ...nt.sizes?.md,
    field: {
      ...nt.sizes?.md.field,
      ...Ja
    }
  },
  sm: {
    ...nt.sizes?.sm,
    field: {
      ...nt.sizes?.sm.field,
      ...Ja
    }
  },
  xs: {
    ...nt.sizes?.xs,
    field: {
      ...nt.sizes?.xs.field,
      ...Ja
    },
    icon: {
      insetEnd: "1"
    }
  }
}, KO = jO({
  baseStyle: UO,
  sizes: JO,
  variants: nt.variants,
  defaultProps: nt.defaultProps
}), Sd = Te("skeleton-start-color"), xd = Te("skeleton-end-color"), qO = {
  [Sd.variable]: "colors.gray.100",
  [xd.variable]: "colors.gray.400",
  _dark: {
    [Sd.variable]: "colors.gray.800",
    [xd.variable]: "colors.gray.600"
  },
  background: Sd.reference,
  borderColor: xd.reference,
  opacity: 0.7,
  borderRadius: "sm"
}, QO = {
  baseStyle: qO
}, Cd = Te("skip-link-bg"), eN = {
  borderRadius: "md",
  fontWeight: "semibold",
  _focusVisible: {
    boxShadow: "outline",
    padding: "4",
    position: "fixed",
    top: "6",
    insetStart: "6",
    [Cd.variable]: "colors.white",
    _dark: {
      [Cd.variable]: "colors.gray.700"
    },
    bg: Cd.reference
  }
}, tN = {
  baseStyle: eN
}, { defineMultiStyleConfig: nN, definePartsStyle: Ul } = ct(GE.keys), Vo = Te("slider-thumb-size"), ea = Te("slider-track-size"), qr = Te("slider-bg"), rN = (e) => {
  const { orientation: t } = e;
  return {
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    _disabled: {
      opacity: 0.6,
      cursor: "default",
      pointerEvents: "none"
    },
    ...ah({
      orientation: t,
      vertical: {
        h: "100%",
        px: Er(Vo.reference).divide(2).toString()
      },
      horizontal: {
        w: "100%",
        py: Er(Vo.reference).divide(2).toString()
      }
    })
  };
}, oN = (e) => ({
  ...ah({
    orientation: e.orientation,
    horizontal: { h: ea.reference },
    vertical: { w: ea.reference }
  }),
  overflow: "hidden",
  borderRadius: "sm",
  [qr.variable]: "colors.gray.200",
  _dark: {
    [qr.variable]: "colors.whiteAlpha.200"
  },
  _disabled: {
    [qr.variable]: "colors.gray.300",
    _dark: {
      [qr.variable]: "colors.whiteAlpha.300"
    }
  },
  bg: qr.reference
}), iN = (e) => {
  const { orientation: t } = e;
  return {
    ...ah({
      orientation: t,
      vertical: { left: "50%" },
      horizontal: { top: "50%" }
    }),
    w: Vo.reference,
    h: Vo.reference,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    outline: 0,
    zIndex: 1,
    borderRadius: "full",
    bg: "white",
    boxShadow: "base",
    border: "1px solid",
    borderColor: "transparent",
    transitionProperty: "transform",
    transitionDuration: "normal",
    _focusVisible: {
      boxShadow: "outline"
    },
    _active: {
      "--slider-thumb-scale": "1.15"
    },
    _disabled: {
      bg: "gray.300"
    }
  };
}, sN = (e) => {
  const { colorScheme: t } = e;
  return {
    width: "inherit",
    height: "inherit",
    [qr.variable]: `colors.${t}.500`,
    _dark: {
      [qr.variable]: `colors.${t}.200`
    },
    bg: qr.reference
  };
}, aN = Ul((e) => ({
  container: rN(e),
  track: oN(e),
  thumb: iN(e),
  filledTrack: sN(e)
})), cN = Ul({
  container: {
    [Vo.variable]: "sizes.4",
    [ea.variable]: "sizes.1"
  }
}), lN = Ul({
  container: {
    [Vo.variable]: "sizes.3.5",
    [ea.variable]: "sizes.1"
  }
}), uN = Ul({
  container: {
    [Vo.variable]: "sizes.2.5",
    [ea.variable]: "sizes.0.5"
  }
}), dN = {
  lg: cN,
  md: lN,
  sm: uN
}, fN = nN({
  baseStyle: aN,
  sizes: dN,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), Co = zt("spinner-size"), pN = {
  width: [Co.reference],
  height: [Co.reference]
}, hN = {
  xs: {
    [Co.variable]: "sizes.3"
  },
  sm: {
    [Co.variable]: "sizes.4"
  },
  md: {
    [Co.variable]: "sizes.6"
  },
  lg: {
    [Co.variable]: "sizes.8"
  },
  xl: {
    [Co.variable]: "sizes.12"
  }
}, mN = {
  baseStyle: pN,
  sizes: hN,
  defaultProps: {
    size: "md"
  }
}, { defineMultiStyleConfig: gN, definePartsStyle: S1 } = ct(WE.keys), bN = {
  fontWeight: "medium"
}, vN = {
  opacity: 0.8,
  marginBottom: "2"
}, yN = {
  verticalAlign: "baseline",
  fontWeight: "semibold"
}, SN = {
  marginEnd: 1,
  w: "3.5",
  h: "3.5",
  verticalAlign: "middle"
}, xN = S1({
  container: {},
  label: bN,
  helpText: vN,
  number: yN,
  icon: SN
}), CN = {
  md: S1({
    label: { fontSize: "sm" },
    helpText: { fontSize: "sm" },
    number: { fontSize: "2xl" }
  })
}, IN = gN({
  baseStyle: xN,
  sizes: CN,
  defaultProps: {
    size: "md"
  }
}), { defineMultiStyleConfig: wN, definePartsStyle: Rs } = ct([
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
]), _r = Te("stepper-indicator-size"), yi = Te("stepper-icon-size"), Si = Te("stepper-title-font-size"), _s = Te("stepper-description-font-size"), hs = Te("stepper-accent-color"), PN = Rs(({ colorScheme: e }) => ({
  stepper: {
    display: "flex",
    justifyContent: "space-between",
    gap: "4",
    "&[data-orientation=vertical]": {
      flexDirection: "column",
      alignItems: "flex-start"
    },
    "&[data-orientation=horizontal]": {
      flexDirection: "row",
      alignItems: "center"
    },
    [hs.variable]: `colors.${e}.500`,
    _dark: {
      [hs.variable]: `colors.${e}.200`
    }
  },
  title: {
    fontSize: Si.reference,
    fontWeight: "medium"
  },
  description: {
    fontSize: _s.reference,
    color: "chakra-subtle-text"
  },
  number: {
    fontSize: Si.reference
  },
  step: {
    flexShrink: 0,
    position: "relative",
    display: "flex",
    gap: "2",
    "&[data-orientation=horizontal]": {
      alignItems: "center"
    },
    flex: "1",
    "&:last-of-type:not([data-stretch])": {
      flex: "initial"
    }
  },
  icon: {
    flexShrink: 0,
    width: yi.reference,
    height: yi.reference
  },
  indicator: {
    flexShrink: 0,
    borderRadius: "full",
    width: _r.reference,
    height: _r.reference,
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    "&[data-status=active]": {
      borderWidth: "2px",
      borderColor: hs.reference
    },
    "&[data-status=complete]": {
      bg: hs.reference,
      color: "chakra-inverse-text"
    },
    "&[data-status=incomplete]": {
      borderWidth: "2px"
    }
  },
  separator: {
    bg: "chakra-border-color",
    flex: "1",
    "&[data-status=complete]": {
      bg: hs.reference
    },
    "&[data-orientation=horizontal]": {
      width: "100%",
      height: "2px",
      marginStart: "2"
    },
    "&[data-orientation=vertical]": {
      width: "2px",
      position: "absolute",
      height: "100%",
      maxHeight: `calc(100% - ${_r.reference} - 8px)`,
      top: `calc(${_r.reference} + 4px)`,
      insetStart: `calc(${_r.reference} / 2 - 1px)`
    }
  }
})), kN = wN({
  baseStyle: PN,
  sizes: {
    xs: Rs({
      stepper: {
        [_r.variable]: "sizes.4",
        [yi.variable]: "sizes.3",
        [Si.variable]: "fontSizes.xs",
        [_s.variable]: "fontSizes.xs"
      }
    }),
    sm: Rs({
      stepper: {
        [_r.variable]: "sizes.6",
        [yi.variable]: "sizes.4",
        [Si.variable]: "fontSizes.sm",
        [_s.variable]: "fontSizes.xs"
      }
    }),
    md: Rs({
      stepper: {
        [_r.variable]: "sizes.8",
        [yi.variable]: "sizes.5",
        [Si.variable]: "fontSizes.md",
        [_s.variable]: "fontSizes.sm"
      }
    }),
    lg: Rs({
      stepper: {
        [_r.variable]: "sizes.10",
        [yi.variable]: "sizes.6",
        [Si.variable]: "fontSizes.lg",
        [_s.variable]: "fontSizes.md"
      }
    })
  },
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: AN, definePartsStyle: _c } = ct(HE.keys), Ws = zt("switch-track-width"), _o = zt("switch-track-height"), Id = zt("switch-track-diff"), TN = Rr.subtract(Ws, _o), Gf = zt("switch-thumb-x"), ms = zt("switch-bg"), EN = (e) => {
  const { colorScheme: t } = e;
  return {
    borderRadius: "full",
    p: "0.5",
    width: [Ws.reference],
    height: [_o.reference],
    transitionProperty: "common",
    transitionDuration: "fast",
    [ms.variable]: "colors.gray.300",
    _dark: {
      [ms.variable]: "colors.whiteAlpha.400"
    },
    _focusVisible: {
      boxShadow: "outline"
    },
    _disabled: {
      opacity: 0.4,
      cursor: "not-allowed"
    },
    _checked: {
      [ms.variable]: `colors.${t}.500`,
      _dark: {
        [ms.variable]: `colors.${t}.200`
      }
    },
    bg: ms.reference
  };
}, RN = {
  bg: "white",
  transitionProperty: "transform",
  transitionDuration: "normal",
  borderRadius: "inherit",
  width: [_o.reference],
  height: [_o.reference],
  _checked: {
    transform: `translateX(${Gf.reference})`
  }
}, _N = _c((e) => ({
  container: {
    [Id.variable]: TN,
    [Gf.variable]: Id.reference,
    _rtl: {
      [Gf.variable]: Rr(Id).negate().toString()
    }
  },
  track: EN(e),
  thumb: RN
})), ON = {
  sm: _c({
    container: {
      [Ws.variable]: "1.375rem",
      [_o.variable]: "sizes.3"
    }
  }),
  md: _c({
    container: {
      [Ws.variable]: "1.875rem",
      [_o.variable]: "sizes.4"
    }
  }),
  lg: _c({
    container: {
      [Ws.variable]: "2.875rem",
      [_o.variable]: "sizes.6"
    }
  })
}, NN = AN({
  baseStyle: _N,
  sizes: ON,
  defaultProps: {
    size: "md",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: MN, definePartsStyle: Fi } = ct(jE.keys), BN = Fi({
  table: {
    fontVariantNumeric: "lining-nums tabular-nums",
    borderCollapse: "collapse",
    width: "full"
  },
  th: {
    fontFamily: "heading",
    fontWeight: "bold",
    textTransform: "uppercase",
    letterSpacing: "wider",
    textAlign: "start"
  },
  td: {
    textAlign: "start"
  },
  caption: {
    mt: 4,
    fontFamily: "heading",
    textAlign: "center",
    fontWeight: "medium"
  }
}), sl = {
  "&[data-is-numeric=true]": {
    textAlign: "end"
  }
}, FN = Fi((e) => {
  const { colorScheme: t } = e;
  return {
    th: {
      color: Ne("gray.600", "gray.400")(e),
      borderBottom: "1px",
      borderColor: Ne(`${t}.100`, `${t}.700`)(e),
      ...sl
    },
    td: {
      borderBottom: "1px",
      borderColor: Ne(`${t}.100`, `${t}.700`)(e),
      ...sl
    },
    caption: {
      color: Ne("gray.600", "gray.100")(e)
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), DN = Fi((e) => {
  const { colorScheme: t } = e;
  return {
    th: {
      color: Ne("gray.600", "gray.400")(e),
      borderBottom: "1px",
      borderColor: Ne(`${t}.100`, `${t}.700`)(e),
      ...sl
    },
    td: {
      borderBottom: "1px",
      borderColor: Ne(`${t}.100`, `${t}.700`)(e),
      ...sl
    },
    caption: {
      color: Ne("gray.600", "gray.100")(e)
    },
    tbody: {
      tr: {
        "&:nth-of-type(odd)": {
          "th, td": {
            borderBottomWidth: "1px",
            borderColor: Ne(`${t}.100`, `${t}.700`)(e)
          },
          td: {
            background: Ne(`${t}.100`, `${t}.700`)(e)
          }
        }
      }
    },
    tfoot: {
      tr: {
        "&:last-of-type": {
          th: { borderBottomWidth: 0 }
        }
      }
    }
  };
}), $N = {
  simple: FN,
  striped: DN,
  unstyled: {}
}, VN = {
  sm: Fi({
    th: {
      px: "4",
      py: "1",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "4",
      py: "2",
      fontSize: "sm",
      lineHeight: "4"
    },
    caption: {
      px: "4",
      py: "2",
      fontSize: "xs"
    }
  }),
  md: Fi({
    th: {
      px: "6",
      py: "3",
      lineHeight: "4",
      fontSize: "xs"
    },
    td: {
      px: "6",
      py: "4",
      lineHeight: "5"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "sm"
    }
  }),
  lg: Fi({
    th: {
      px: "8",
      py: "4",
      lineHeight: "5",
      fontSize: "sm"
    },
    td: {
      px: "8",
      py: "5",
      lineHeight: "6"
    },
    caption: {
      px: "6",
      py: "2",
      fontSize: "md"
    }
  })
}, LN = MN({
  baseStyle: BN,
  variants: $N,
  sizes: VN,
  defaultProps: {
    variant: "simple",
    size: "md",
    colorScheme: "gray"
  }
}), un = Te("tabs-color"), Xn = Te("tabs-bg"), Ka = Te("tabs-border-color"), { defineMultiStyleConfig: zN, definePartsStyle: pr } = ct(XE.keys), GN = (e) => {
  const { orientation: t } = e;
  return {
    display: t === "vertical" ? "flex" : "block"
  };
}, WN = (e) => {
  const { isFitted: t } = e;
  return {
    flex: t ? 1 : void 0,
    transitionProperty: "common",
    transitionDuration: "normal",
    _focusVisible: {
      zIndex: 1,
      boxShadow: "outline"
    },
    _disabled: {
      cursor: "not-allowed",
      opacity: 0.4
    }
  };
}, HN = (e) => {
  const { align: t = "start", orientation: n } = e;
  return {
    justifyContent: {
      end: "flex-end",
      center: "center",
      start: "flex-start"
    }[t],
    flexDirection: n === "vertical" ? "column" : "row"
  };
}, jN = {
  p: 4
}, XN = pr((e) => ({
  root: GN(e),
  tab: WN(e),
  tablist: HN(e),
  tabpanel: jN
})), YN = {
  sm: pr({
    tab: {
      py: 1,
      px: 4,
      fontSize: "sm"
    }
  }),
  md: pr({
    tab: {
      fontSize: "md",
      py: 2,
      px: 4
    }
  }),
  lg: pr({
    tab: {
      fontSize: "lg",
      py: 3,
      px: 4
    }
  })
}, ZN = pr((e) => {
  const { colorScheme: t, orientation: n } = e, r = n === "vertical", o = r ? "borderStart" : "borderBottom", i = r ? "marginStart" : "marginBottom";
  return {
    tablist: {
      [o]: "2px solid",
      borderColor: "inherit"
    },
    tab: {
      [o]: "2px solid",
      borderColor: "transparent",
      [i]: "-2px",
      _selected: {
        [un.variable]: `colors.${t}.600`,
        _dark: {
          [un.variable]: `colors.${t}.300`
        },
        borderColor: "currentColor"
      },
      _active: {
        [Xn.variable]: "colors.gray.200",
        _dark: {
          [Xn.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        _active: { bg: "none" }
      },
      color: un.reference,
      bg: Xn.reference
    }
  };
}), UN = pr((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      borderTopRadius: "md",
      border: "1px solid",
      borderColor: "transparent",
      mb: "-1px",
      [Ka.variable]: "transparent",
      _selected: {
        [un.variable]: `colors.${t}.600`,
        [Ka.variable]: "colors.white",
        _dark: {
          [un.variable]: `colors.${t}.300`,
          [Ka.variable]: "colors.gray.800"
        },
        borderColor: "inherit",
        borderBottomColor: Ka.reference
      },
      color: un.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), JN = pr((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      border: "1px solid",
      borderColor: "inherit",
      [Xn.variable]: "colors.gray.50",
      _dark: {
        [Xn.variable]: "colors.whiteAlpha.50"
      },
      mb: "-1px",
      _notLast: {
        marginEnd: "-1px"
      },
      _selected: {
        [Xn.variable]: "colors.white",
        [un.variable]: `colors.${t}.600`,
        _dark: {
          [Xn.variable]: "colors.gray.800",
          [un.variable]: `colors.${t}.300`
        },
        borderColor: "inherit",
        borderTopColor: "currentColor",
        borderBottomColor: "transparent"
      },
      color: un.reference,
      bg: Xn.reference
    },
    tablist: {
      mb: "-1px",
      borderBottom: "1px solid",
      borderColor: "inherit"
    }
  };
}), KN = pr((e) => {
  const { colorScheme: t, theme: n } = e;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      color: "gray.600",
      _selected: {
        color: on(n, `${t}.700`),
        bg: on(n, `${t}.100`)
      }
    }
  };
}), qN = pr((e) => {
  const { colorScheme: t } = e;
  return {
    tab: {
      borderRadius: "full",
      fontWeight: "semibold",
      [un.variable]: "colors.gray.600",
      _dark: {
        [un.variable]: "inherit"
      },
      _selected: {
        [un.variable]: "colors.white",
        [Xn.variable]: `colors.${t}.600`,
        _dark: {
          [un.variable]: "colors.gray.800",
          [Xn.variable]: `colors.${t}.300`
        }
      },
      color: un.reference,
      bg: Xn.reference
    }
  };
}), QN = pr({}), eM = {
  line: ZN,
  enclosed: UN,
  "enclosed-colored": JN,
  "soft-rounded": KN,
  "solid-rounded": qN,
  unstyled: QN
}, tM = zN({
  baseStyle: XN,
  sizes: YN,
  variants: eM,
  defaultProps: {
    size: "md",
    variant: "line",
    colorScheme: "blue"
  }
}), { defineMultiStyleConfig: nM, definePartsStyle: Oo } = ct(YE.keys), jg = Te("tag-bg"), Xg = Te("tag-color"), wd = Te("tag-shadow"), Oc = Te("tag-min-height"), Nc = Te("tag-min-width"), Mc = Te("tag-font-size"), Bc = Te("tag-padding-inline"), rM = {
  fontWeight: "medium",
  lineHeight: 1.2,
  outline: 0,
  [Xg.variable]: Nt.color.reference,
  [jg.variable]: Nt.bg.reference,
  [wd.variable]: Nt.shadow.reference,
  color: Xg.reference,
  bg: jg.reference,
  boxShadow: wd.reference,
  borderRadius: "md",
  minH: Oc.reference,
  minW: Nc.reference,
  fontSize: Mc.reference,
  px: Bc.reference,
  _focusVisible: {
    [wd.variable]: "shadows.outline"
  }
}, oM = {
  lineHeight: 1.2,
  overflow: "visible"
}, iM = {
  fontSize: "lg",
  w: "5",
  h: "5",
  transitionProperty: "common",
  transitionDuration: "normal",
  borderRadius: "full",
  marginStart: "1.5",
  marginEnd: "-1",
  opacity: 0.5,
  _disabled: {
    opacity: 0.4
  },
  _focusVisible: {
    boxShadow: "outline",
    bg: "rgba(0, 0, 0, 0.14)"
  },
  _hover: {
    opacity: 0.8
  },
  _active: {
    opacity: 1
  }
}, sM = Oo({
  container: rM,
  label: oM,
  closeButton: iM
}), aM = {
  sm: Oo({
    container: {
      [Oc.variable]: "sizes.5",
      [Nc.variable]: "sizes.5",
      [Mc.variable]: "fontSizes.xs",
      [Bc.variable]: "space.2"
    },
    closeButton: {
      marginEnd: "-2px",
      marginStart: "0.35rem"
    }
  }),
  md: Oo({
    container: {
      [Oc.variable]: "sizes.6",
      [Nc.variable]: "sizes.6",
      [Mc.variable]: "fontSizes.sm",
      [Bc.variable]: "space.2"
    }
  }),
  lg: Oo({
    container: {
      [Oc.variable]: "sizes.8",
      [Nc.variable]: "sizes.8",
      [Mc.variable]: "fontSizes.md",
      [Bc.variable]: "space.3"
    }
  })
}, cM = {
  subtle: Oo((e) => ({
    container: Ls.variants?.subtle(e)
  })),
  solid: Oo((e) => ({
    container: Ls.variants?.solid(e)
  })),
  outline: Oo((e) => ({
    container: Ls.variants?.outline(e)
  }))
}, lM = nM({
  variants: cM,
  baseStyle: sM,
  sizes: aM,
  defaultProps: {
    size: "md",
    variant: "subtle",
    colorScheme: "gray"
  }
}), uM = {
  ...nt.baseStyle?.field,
  paddingY: "2",
  minHeight: "20",
  lineHeight: "short",
  verticalAlign: "top"
}, dM = {
  outline: (e) => nt.variants?.outline(e).field ?? {},
  flushed: (e) => nt.variants?.flushed(e).field ?? {},
  filled: (e) => nt.variants?.filled(e).field ?? {},
  unstyled: nt.variants?.unstyled.field ?? {}
}, fM = {
  xs: nt.sizes?.xs.field ?? {},
  sm: nt.sizes?.sm.field ?? {},
  md: nt.sizes?.md.field ?? {},
  lg: nt.sizes?.lg.field ?? {}
}, pM = {
  baseStyle: uM,
  sizes: fM,
  variants: dM,
  defaultProps: {
    size: "md",
    variant: "outline"
  }
}, qa = zt("tooltip-bg"), Pd = zt("tooltip-fg"), hM = zt("popper-arrow-bg"), mM = {
  bg: qa.reference,
  color: Pd.reference,
  [qa.variable]: "colors.gray.700",
  [Pd.variable]: "colors.whiteAlpha.900",
  _dark: {
    [qa.variable]: "colors.gray.300",
    [Pd.variable]: "colors.gray.900"
  },
  [hM.variable]: qa.reference,
  px: "2",
  py: "0.5",
  borderRadius: "sm",
  fontWeight: "medium",
  fontSize: "sm",
  boxShadow: "md",
  maxW: "xs",
  zIndex: "tooltip"
}, gM = {
  baseStyle: mM
}, bM = {
  Accordion: n2,
  Alert: V2,
  Avatar: J2,
  Badge: Ls,
  Breadcrumb: sR,
  Button: mR,
  Checkbox: il,
  CloseButton: RR,
  Code: MR,
  Container: FR,
  Divider: zR,
  Drawer: qR,
  Editable: i_,
  Form: d_,
  FormError: b_,
  FormLabel: y_,
  Heading: C_,
  Input: nt,
  Kbd: O_,
  Link: M_,
  List: V_,
  Menu: J_,
  Modal: aO,
  NumberInput: gO,
  PinInput: SO,
  Popover: _O,
  Progress: VO,
  Radio: HO,
  Select: KO,
  Skeleton: QO,
  SkipLink: tN,
  Slider: fN,
  Spinner: mN,
  Stat: IN,
  Switch: NN,
  Table: LN,
  Tabs: tM,
  Tag: lM,
  Textarea: pM,
  Tooltip: gM,
  Card: SR,
  Stepper: kN
}, vM = {
  none: 0,
  "1px": "1px solid",
  "2px": "2px solid",
  "4px": "4px solid",
  "8px": "8px solid"
}, yM = {
  base: "0em",
  sm: "30em",
  md: "48em",
  lg: "62em",
  xl: "80em",
  "2xl": "96em"
}, SM = {
  transparent: "transparent",
  current: "currentColor",
  black: "#000000",
  white: "#FFFFFF",
  whiteAlpha: {
    50: "rgba(255, 255, 255, 0.04)",
    100: "rgba(255, 255, 255, 0.06)",
    200: "rgba(255, 255, 255, 0.08)",
    300: "rgba(255, 255, 255, 0.16)",
    400: "rgba(255, 255, 255, 0.24)",
    500: "rgba(255, 255, 255, 0.36)",
    600: "rgba(255, 255, 255, 0.48)",
    700: "rgba(255, 255, 255, 0.64)",
    800: "rgba(255, 255, 255, 0.80)",
    900: "rgba(255, 255, 255, 0.92)"
  },
  blackAlpha: {
    50: "rgba(0, 0, 0, 0.04)",
    100: "rgba(0, 0, 0, 0.06)",
    200: "rgba(0, 0, 0, 0.08)",
    300: "rgba(0, 0, 0, 0.16)",
    400: "rgba(0, 0, 0, 0.24)",
    500: "rgba(0, 0, 0, 0.36)",
    600: "rgba(0, 0, 0, 0.48)",
    700: "rgba(0, 0, 0, 0.64)",
    800: "rgba(0, 0, 0, 0.80)",
    900: "rgba(0, 0, 0, 0.92)"
  },
  gray: {
    50: "#F7FAFC",
    100: "#EDF2F7",
    200: "#E2E8F0",
    300: "#CBD5E0",
    400: "#A0AEC0",
    500: "#718096",
    600: "#4A5568",
    700: "#2D3748",
    800: "#1A202C",
    900: "#171923"
  },
  red: {
    50: "#FFF5F5",
    100: "#FED7D7",
    200: "#FEB2B2",
    300: "#FC8181",
    400: "#F56565",
    500: "#E53E3E",
    600: "#C53030",
    700: "#9B2C2C",
    800: "#822727",
    900: "#63171B"
  },
  orange: {
    50: "#FFFAF0",
    100: "#FEEBC8",
    200: "#FBD38D",
    300: "#F6AD55",
    400: "#ED8936",
    500: "#DD6B20",
    600: "#C05621",
    700: "#9C4221",
    800: "#7B341E",
    900: "#652B19"
  },
  yellow: {
    50: "#FFFFF0",
    100: "#FEFCBF",
    200: "#FAF089",
    300: "#F6E05E",
    400: "#ECC94B",
    500: "#D69E2E",
    600: "#B7791F",
    700: "#975A16",
    800: "#744210",
    900: "#5F370E"
  },
  green: {
    50: "#F0FFF4",
    100: "#C6F6D5",
    200: "#9AE6B4",
    300: "#68D391",
    400: "#48BB78",
    500: "#38A169",
    600: "#2F855A",
    700: "#276749",
    800: "#22543D",
    900: "#1C4532"
  },
  teal: {
    50: "#E6FFFA",
    100: "#B2F5EA",
    200: "#81E6D9",
    300: "#4FD1C5",
    400: "#38B2AC",
    500: "#319795",
    600: "#2C7A7B",
    700: "#285E61",
    800: "#234E52",
    900: "#1D4044"
  },
  blue: {
    50: "#ebf8ff",
    100: "#bee3f8",
    200: "#90cdf4",
    300: "#63b3ed",
    400: "#4299e1",
    500: "#3182ce",
    600: "#2b6cb0",
    700: "#2c5282",
    800: "#2a4365",
    900: "#1A365D"
  },
  cyan: {
    50: "#EDFDFD",
    100: "#C4F1F9",
    200: "#9DECF9",
    300: "#76E4F7",
    400: "#0BC5EA",
    500: "#00B5D8",
    600: "#00A3C4",
    700: "#0987A0",
    800: "#086F83",
    900: "#065666"
  },
  purple: {
    50: "#FAF5FF",
    100: "#E9D8FD",
    200: "#D6BCFA",
    300: "#B794F4",
    400: "#9F7AEA",
    500: "#805AD5",
    600: "#6B46C1",
    700: "#553C9A",
    800: "#44337A",
    900: "#322659"
  },
  pink: {
    50: "#FFF5F7",
    100: "#FED7E2",
    200: "#FBB6CE",
    300: "#F687B3",
    400: "#ED64A6",
    500: "#D53F8C",
    600: "#B83280",
    700: "#97266D",
    800: "#702459",
    900: "#521B41"
  }
}, xM = {
  none: "0",
  sm: "0.125rem",
  base: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
}, CM = {
  xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
  sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
  base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
  lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
  "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
  outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
  inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
  none: "none",
  "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
}, IM = {
  common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
  colors: "background-color, border-color, color, fill, stroke",
  dimensions: "width, height",
  position: "left, right, top, bottom",
  background: "background-color, background-image, background-position"
}, wM = {
  "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
  "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
}, PM = {
  "ultra-fast": "50ms",
  faster: "100ms",
  fast: "150ms",
  normal: "200ms",
  slow: "300ms",
  slower: "400ms",
  "ultra-slow": "500ms"
}, kM = {
  property: IM,
  easing: wM,
  duration: PM
}, AM = {
  hide: -1,
  auto: "auto",
  base: 0,
  docked: 10,
  dropdown: 1e3,
  sticky: 1100,
  banner: 1200,
  overlay: 1300,
  modal: 1400,
  popover: 1500,
  skipLink: 1600,
  toast: 1700,
  tooltip: 1800
}, TM = {
  none: 0,
  sm: "4px",
  base: "8px",
  md: "12px",
  lg: "16px",
  xl: "24px",
  "2xl": "40px",
  "3xl": "64px"
}, EM = {
  breakpoints: yM,
  zIndices: AM,
  radii: xM,
  blur: TM,
  colors: SM,
  ...b1,
  sizes: d1,
  shadows: CM,
  space: u1,
  borders: vM,
  transition: kM
}, RM = {
  colors: {
    "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
    "chakra-body-bg": { _light: "white", _dark: "gray.800" },
    "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
    "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
    "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
    "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
    "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
  }
}, _M = {
  global: {
    body: {
      fontFamily: "body",
      color: "chakra-body-text",
      bg: "chakra-body-bg",
      transitionProperty: "background-color",
      transitionDuration: "normal",
      lineHeight: "base"
    },
    "*::placeholder": {
      color: "chakra-placeholder-color"
    },
    "*, *::before, &::after": {
      borderColor: "chakra-border-color"
    }
  }
}, OM = [
  "borders",
  "breakpoints",
  "colors",
  "components",
  "config",
  "direction",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "space",
  "styles",
  "transition",
  "zIndices"
];
function NM(e) {
  return Mt(e) ? OM.every(
    (t) => Object.prototype.hasOwnProperty.call(e, t)
  ) : !1;
}
const MM = "ltr", BM = {
  useSystemColorMode: !1,
  initialColorMode: "light",
  cssVarPrefix: "chakra"
}, dh = {
  semanticTokens: RM,
  direction: MM,
  ...EM,
  components: bM,
  styles: _M,
  config: BM
};
function FM(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function DM(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var $M = /* @__PURE__ */ (function() {
  function e(n) {
    var r = this;
    this._insertTag = function(o) {
      var i;
      r.tags.length === 0 ? r.insertionPoint ? i = r.insertionPoint.nextSibling : r.prepend ? i = r.container.firstChild : i = r.before : i = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, i), r.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(DM(this));
    var o = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var i = FM(o);
      try {
        i.insertRule(r, i.cssRules.length);
      } catch {
      }
    } else
      o.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var o;
      return (o = r.parentNode) == null ? void 0 : o.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Qt = "-ms-", al = "-moz-", et = "-webkit-", x1 = "comm", fh = "rule", ph = "decl", VM = "@import", C1 = "@keyframes", LM = "@layer", zM = Math.abs, Jl = String.fromCharCode, GM = Object.assign;
function WM(e, t) {
  return Ut(e, 0) ^ 45 ? (((t << 2 ^ Ut(e, 0)) << 2 ^ Ut(e, 1)) << 2 ^ Ut(e, 2)) << 2 ^ Ut(e, 3) : 0;
}
function I1(e) {
  return e.trim();
}
function HM(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function tt(e, t, n) {
  return e.replace(t, n);
}
function Wf(e, t) {
  return e.indexOf(t);
}
function Ut(e, t) {
  return e.charCodeAt(t) | 0;
}
function ta(e, t, n) {
  return e.slice(t, n);
}
function cr(e) {
  return e.length;
}
function hh(e) {
  return e.length;
}
function Qa(e, t) {
  return t.push(e), e;
}
function jM(e, t) {
  return e.map(t).join("");
}
var Kl = 1, Yi = 1, w1 = 0, mn = 0, Ft = 0, ss = "";
function ql(e, t, n, r, o, i, s) {
  return { value: e, root: t, parent: n, type: r, props: o, children: i, line: Kl, column: Yi, length: s, return: "" };
}
function gs(e, t) {
  return GM(ql("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function XM() {
  return Ft;
}
function YM() {
  return Ft = mn > 0 ? Ut(ss, --mn) : 0, Yi--, Ft === 10 && (Yi = 1, Kl--), Ft;
}
function In() {
  return Ft = mn < w1 ? Ut(ss, mn++) : 0, Yi++, Ft === 10 && (Yi = 1, Kl++), Ft;
}
function hr() {
  return Ut(ss, mn);
}
function Fc() {
  return mn;
}
function wa(e, t) {
  return ta(ss, e, t);
}
function na(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function P1(e) {
  return Kl = Yi = 1, w1 = cr(ss = e), mn = 0, [];
}
function k1(e) {
  return ss = "", e;
}
function Dc(e) {
  return I1(wa(mn - 1, Hf(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function ZM(e) {
  for (; (Ft = hr()) && Ft < 33; )
    In();
  return na(e) > 2 || na(Ft) > 3 ? "" : " ";
}
function UM(e, t) {
  for (; --t && In() && !(Ft < 48 || Ft > 102 || Ft > 57 && Ft < 65 || Ft > 70 && Ft < 97); )
    ;
  return wa(e, Fc() + (t < 6 && hr() == 32 && In() == 32));
}
function Hf(e) {
  for (; In(); )
    switch (Ft) {
      // ] ) " '
      case e:
        return mn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Hf(Ft);
        break;
      // (
      case 40:
        e === 41 && Hf(e);
        break;
      // \
      case 92:
        In();
        break;
    }
  return mn;
}
function JM(e, t) {
  for (; In() && e + Ft !== 57; )
    if (e + Ft === 84 && hr() === 47)
      break;
  return "/*" + wa(t, mn - 1) + "*" + Jl(e === 47 ? e : In());
}
function KM(e) {
  for (; !na(hr()); )
    In();
  return wa(e, mn);
}
function qM(e) {
  return k1($c("", null, null, null, [""], e = P1(e), 0, [0], e));
}
function $c(e, t, n, r, o, i, s, a, c) {
  for (var l = 0, u = 0, d = s, f = 0, p = 0, m = 0, h = 1, g = 1, v = 1, y = 0, x = "", S = o, C = i, w = r, I = x; g; )
    switch (m = y, y = In()) {
      // (
      case 40:
        if (m != 108 && Ut(I, d - 1) == 58) {
          Wf(I += tt(Dc(y), "&", "&\f"), "&\f") != -1 && (v = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        I += Dc(y);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        I += ZM(m);
        break;
      // \
      case 92:
        I += UM(Fc() - 1, 7);
        continue;
      // /
      case 47:
        switch (hr()) {
          case 42:
          case 47:
            Qa(QM(JM(In(), Fc()), t, n), c);
            break;
          default:
            I += "/";
        }
        break;
      // {
      case 123 * h:
        a[l++] = cr(I) * v;
      // } ; \0
      case 125 * h:
      case 59:
      case 0:
        switch (y) {
          // \0 }
          case 0:
          case 125:
            g = 0;
          // ;
          case 59 + u:
            v == -1 && (I = tt(I, /\f/g, "")), p > 0 && cr(I) - d && Qa(p > 32 ? Zg(I + ";", r, n, d - 1) : Zg(tt(I, " ", "") + ";", r, n, d - 2), c);
            break;
          // @ ;
          case 59:
            I += ";";
          // { rule/at-rule
          default:
            if (Qa(w = Yg(I, t, n, l, u, o, a, x, S = [], C = [], d), i), y === 123)
              if (u === 0)
                $c(I, t, w, w, S, i, d, a, C);
              else
                switch (f === 99 && Ut(I, 3) === 110 ? 100 : f) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    $c(e, w, w, r && Qa(Yg(e, w, w, 0, 0, o, a, x, o, S = [], d), C), o, C, d, a, r ? S : C);
                    break;
                  default:
                    $c(I, w, w, w, [""], C, 0, a, C);
                }
        }
        l = u = p = 0, h = v = 1, x = I = "", d = s;
        break;
      // :
      case 58:
        d = 1 + cr(I), p = m;
      default:
        if (h < 1) {
          if (y == 123)
            --h;
          else if (y == 125 && h++ == 0 && YM() == 125)
            continue;
        }
        switch (I += Jl(y), y * h) {
          // &
          case 38:
            v = u > 0 ? 1 : (I += "\f", -1);
            break;
          // ,
          case 44:
            a[l++] = (cr(I) - 1) * v, v = 1;
            break;
          // @
          case 64:
            hr() === 45 && (I += Dc(In())), f = hr(), u = d = cr(x = I += KM(Fc())), y++;
            break;
          // -
          case 45:
            m === 45 && cr(I) == 2 && (h = 0);
        }
    }
  return i;
}
function Yg(e, t, n, r, o, i, s, a, c, l, u) {
  for (var d = o - 1, f = o === 0 ? i : [""], p = hh(f), m = 0, h = 0, g = 0; m < r; ++m)
    for (var v = 0, y = ta(e, d + 1, d = zM(h = s[m])), x = e; v < p; ++v)
      (x = I1(h > 0 ? f[v] + " " + y : tt(y, /&\f/g, f[v]))) && (c[g++] = x);
  return ql(e, t, n, o === 0 ? fh : a, c, l, u);
}
function QM(e, t, n) {
  return ql(e, t, n, x1, Jl(XM()), ta(e, 2, -2), 0);
}
function Zg(e, t, n, r) {
  return ql(e, t, n, ph, ta(e, 0, r), ta(e, r + 1, -1), r);
}
function Di(e, t) {
  for (var n = "", r = hh(e), o = 0; o < r; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function eB(e, t, n, r) {
  switch (e.type) {
    case LM:
      if (e.children.length) break;
    case VM:
    case ph:
      return e.return = e.return || e.value;
    case x1:
      return "";
    case C1:
      return e.return = e.value + "{" + Di(e.children, r) + "}";
    case fh:
      e.value = e.props.join(",");
  }
  return cr(n = Di(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function tB(e) {
  var t = hh(e);
  return function(n, r, o, i) {
    for (var s = "", a = 0; a < t; a++)
      s += e[a](n, r, o, i) || "";
    return s;
  };
}
function nB(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
var Ug = function(t) {
  var n = /* @__PURE__ */ new WeakMap();
  return function(r) {
    if (n.has(r))
      return n.get(r);
    var o = t(r);
    return n.set(r, o), o;
  };
};
function A1(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var rB = function(t, n, r) {
  for (var o = 0, i = 0; o = i, i = hr(), o === 38 && i === 12 && (n[r] = 1), !na(i); )
    In();
  return wa(t, mn);
}, oB = function(t, n) {
  var r = -1, o = 44;
  do
    switch (na(o)) {
      case 0:
        o === 38 && hr() === 12 && (n[r] = 1), t[r] += rB(mn - 1, n, r);
        break;
      case 2:
        t[r] += Dc(o);
        break;
      case 4:
        if (o === 44) {
          t[++r] = hr() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Jl(o);
    }
  while (o = In());
  return t;
}, iB = function(t, n) {
  return k1(oB(P1(t), n));
}, Jg = /* @__PURE__ */ new WeakMap(), sB = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, o = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Jg.get(r)) && !o) {
      Jg.set(t, !0);
      for (var i = [], s = iB(n, i), a = r.props, c = 0, l = 0; c < s.length; c++)
        for (var u = 0; u < a.length; u++, l++)
          t.props[l] = i[c] ? s[c].replace(/&\f/g, a[u]) : a[u] + " " + s[c];
    }
  }
}, aB = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function T1(e, t) {
  switch (WM(e, t)) {
    // color-adjust
    case 5103:
      return et + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return et + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return et + e + al + e + Qt + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return et + e + Qt + e + e;
    // order
    case 6165:
      return et + e + Qt + "flex-" + e + e;
    // align-items
    case 5187:
      return et + e + tt(e, /(\w+).+(:[^]+)/, et + "box-$1$2" + Qt + "flex-$1$2") + e;
    // align-self
    case 5443:
      return et + e + Qt + "flex-item-" + tt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return et + e + Qt + "flex-line-pack" + tt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return et + e + Qt + tt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return et + e + Qt + tt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return et + "box-" + tt(e, "-grow", "") + et + e + Qt + tt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return et + tt(e, /([^-])(transform)/g, "$1" + et + "$2") + e;
    // cursor
    case 6187:
      return tt(tt(tt(e, /(zoom-|grab)/, et + "$1"), /(image-set)/, et + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return tt(e, /(image-set\([^]*)/, et + "$1$`$1");
    // justify-content
    case 4968:
      return tt(tt(e, /(.+:)(flex-)?(.*)/, et + "box-pack:$3" + Qt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + et + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return tt(e, /(.+)-inline(.+)/, et + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (cr(e) - 1 - t > 6) switch (Ut(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Ut(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return tt(e, /(.+:)(.+)-([^]+)/, "$1" + et + "$2-$3$1" + al + (Ut(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Wf(e, "stretch") ? T1(tt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Ut(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Ut(e, cr(e) - 3 - (~Wf(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return tt(e, ":", ":" + et) + e;
        // (inline-)?fl(e)x
        case 101:
          return tt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + et + (Ut(e, 14) === 45 ? "inline-" : "") + "box$3$1" + et + "$2$3$1" + Qt + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Ut(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return et + e + Qt + tt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return et + e + Qt + tt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return et + e + Qt + tt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return et + e + Qt + e + e;
  }
  return e;
}
var cB = function(t, n, r, o) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case ph:
      t.return = T1(t.value, t.length);
      break;
    case C1:
      return Di([gs(t, {
        value: tt(t.value, "@", "@" + et)
      })], o);
    case fh:
      if (t.length) return jM(t.props, function(i) {
        switch (HM(i, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Di([gs(t, {
              props: [tt(i, /:(read-\w+)/, ":" + al + "$1")]
            })], o);
          // :placeholder
          case "::placeholder":
            return Di([gs(t, {
              props: [tt(i, /:(plac\w+)/, ":" + et + "input-$1")]
            }), gs(t, {
              props: [tt(i, /:(plac\w+)/, ":" + al + "$1")]
            }), gs(t, {
              props: [tt(i, /:(plac\w+)/, Qt + "input-$1")]
            })], o);
        }
        return "";
      });
  }
}, lB = [cB], uB = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(h) {
      var g = h.getAttribute("data-emotion");
      g.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var o = t.stylisPlugins || lB, i = {}, s, a = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(h) {
      for (var g = h.getAttribute("data-emotion").split(" "), v = 1; v < g.length; v++)
        i[g[v]] = !0;
      a.push(h);
    }
  );
  var c, l = [sB, aB];
  {
    var u, d = [eB, nB(function(h) {
      u.insert(h);
    })], f = tB(l.concat(o, d)), p = function(g) {
      return Di(qM(g), f);
    };
    c = function(g, v, y, x) {
      u = y, p(g ? g + "{" + v.styles + "}" : v.styles), x && (m.inserted[v.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new $M({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: i,
    registered: {},
    insert: c
  };
  return m.sheet.hydrate(a), m;
};
function Ie() {
  return Ie = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Ie.apply(null, arguments);
}
var ec = { exports: {} }, it = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kg;
function dB() {
  if (Kg) return it;
  Kg = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function x(C) {
    if (typeof C == "object" && C !== null) {
      var w = C.$$typeof;
      switch (w) {
        case t:
          switch (C = C.type, C) {
            case c:
            case l:
            case r:
            case i:
            case o:
            case d:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case a:
                case u:
                case m:
                case p:
                case s:
                  return C;
                default:
                  return w;
              }
          }
        case n:
          return w;
      }
    }
  }
  function S(C) {
    return x(C) === l;
  }
  return it.AsyncMode = c, it.ConcurrentMode = l, it.ContextConsumer = a, it.ContextProvider = s, it.Element = t, it.ForwardRef = u, it.Fragment = r, it.Lazy = m, it.Memo = p, it.Portal = n, it.Profiler = i, it.StrictMode = o, it.Suspense = d, it.isAsyncMode = function(C) {
    return S(C) || x(C) === c;
  }, it.isConcurrentMode = S, it.isContextConsumer = function(C) {
    return x(C) === a;
  }, it.isContextProvider = function(C) {
    return x(C) === s;
  }, it.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === t;
  }, it.isForwardRef = function(C) {
    return x(C) === u;
  }, it.isFragment = function(C) {
    return x(C) === r;
  }, it.isLazy = function(C) {
    return x(C) === m;
  }, it.isMemo = function(C) {
    return x(C) === p;
  }, it.isPortal = function(C) {
    return x(C) === n;
  }, it.isProfiler = function(C) {
    return x(C) === i;
  }, it.isStrictMode = function(C) {
    return x(C) === o;
  }, it.isSuspense = function(C) {
    return x(C) === d;
  }, it.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === r || C === l || C === i || C === o || C === d || C === f || typeof C == "object" && C !== null && (C.$$typeof === m || C.$$typeof === p || C.$$typeof === s || C.$$typeof === a || C.$$typeof === u || C.$$typeof === g || C.$$typeof === v || C.$$typeof === y || C.$$typeof === h);
  }, it.typeOf = x, it;
}
var st = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qg;
function fB() {
  return qg || (qg = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function x(Y) {
      return typeof Y == "string" || typeof Y == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Y === r || Y === l || Y === i || Y === o || Y === d || Y === f || typeof Y == "object" && Y !== null && (Y.$$typeof === m || Y.$$typeof === p || Y.$$typeof === s || Y.$$typeof === a || Y.$$typeof === u || Y.$$typeof === g || Y.$$typeof === v || Y.$$typeof === y || Y.$$typeof === h);
    }
    function S(Y) {
      if (typeof Y == "object" && Y !== null) {
        var ce = Y.$$typeof;
        switch (ce) {
          case t:
            var re = Y.type;
            switch (re) {
              case c:
              case l:
              case r:
              case i:
              case o:
              case d:
                return re;
              default:
                var Ce = re && re.$$typeof;
                switch (Ce) {
                  case a:
                  case u:
                  case m:
                  case p:
                  case s:
                    return Ce;
                  default:
                    return ce;
                }
            }
          case n:
            return ce;
        }
      }
    }
    var C = c, w = l, I = a, P = s, k = t, A = u, N = r, B = m, L = p, Z = n, ne = i, W = o, O = d, J = !1;
    function ee(Y) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), H(Y) || S(Y) === c;
    }
    function H(Y) {
      return S(Y) === l;
    }
    function _(Y) {
      return S(Y) === a;
    }
    function j(Y) {
      return S(Y) === s;
    }
    function E(Y) {
      return typeof Y == "object" && Y !== null && Y.$$typeof === t;
    }
    function M(Y) {
      return S(Y) === u;
    }
    function F(Y) {
      return S(Y) === r;
    }
    function G(Y) {
      return S(Y) === m;
    }
    function q(Y) {
      return S(Y) === p;
    }
    function te(Y) {
      return S(Y) === n;
    }
    function U(Y) {
      return S(Y) === i;
    }
    function K(Y) {
      return S(Y) === o;
    }
    function ae(Y) {
      return S(Y) === d;
    }
    st.AsyncMode = C, st.ConcurrentMode = w, st.ContextConsumer = I, st.ContextProvider = P, st.Element = k, st.ForwardRef = A, st.Fragment = N, st.Lazy = B, st.Memo = L, st.Portal = Z, st.Profiler = ne, st.StrictMode = W, st.Suspense = O, st.isAsyncMode = ee, st.isConcurrentMode = H, st.isContextConsumer = _, st.isContextProvider = j, st.isElement = E, st.isForwardRef = M, st.isFragment = F, st.isLazy = G, st.isMemo = q, st.isPortal = te, st.isProfiler = U, st.isStrictMode = K, st.isSuspense = ae, st.isValidElementType = x, st.typeOf = S;
  })()), st;
}
var Qg;
function mh() {
  return Qg || (Qg = 1, process.env.NODE_ENV === "production" ? ec.exports = dB() : ec.exports = fB()), ec.exports;
}
var kd, eb;
function pB() {
  if (eb) return kd;
  eb = 1;
  var e = mh(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, i = {};
  i[e.ForwardRef] = r, i[e.Memo] = o;
  function s(m) {
    return e.isMemo(m) ? o : i[m.$$typeof] || t;
  }
  var a = Object.defineProperty, c = Object.getOwnPropertyNames, l = Object.getOwnPropertySymbols, u = Object.getOwnPropertyDescriptor, d = Object.getPrototypeOf, f = Object.prototype;
  function p(m, h, g) {
    if (typeof h != "string") {
      if (f) {
        var v = d(h);
        v && v !== f && p(m, v, g);
      }
      var y = c(h);
      l && (y = y.concat(l(h)));
      for (var x = s(m), S = s(h), C = 0; C < y.length; ++C) {
        var w = y[C];
        if (!n[w] && !(g && g[w]) && !(S && S[w]) && !(x && x[w])) {
          var I = u(h, w);
          try {
            a(m, w, I);
          } catch {
          }
        }
      }
    }
    return m;
  }
  return kd = p, kd;
}
pB();
var hB = !0;
function E1(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
  }), r;
}
var gh = function(t, n, r) {
  var o = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  hB === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
}, bh = function(t, n, r) {
  gh(t, n, r);
  var o = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var i = n;
    do
      t.insert(n === i ? "." + o : "", i, t.sheet, !0), i = i.next;
    while (i !== void 0);
  }
};
function mB(e) {
  for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var gB = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, bB = /[A-Z]|^ms/g, vB = /_EMO_([^_]+?)_([^]*?)_EMO_/g, R1 = function(t) {
  return t.charCodeAt(1) === 45;
}, tb = function(t) {
  return t != null && typeof t != "boolean";
}, Ad = /* @__PURE__ */ A1(function(e) {
  return R1(e) ? e : e.replace(bB, "-$&").toLowerCase();
}), nb = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(vB, function(r, o, i) {
          return lr = {
            name: o,
            styles: i,
            next: lr
          }, o;
        });
  }
  return gB[t] !== 1 && !R1(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function ra(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return lr = {
          name: o.name,
          styles: o.styles,
          next: lr
        }, o.name;
      var i = n;
      if (i.styles !== void 0) {
        var s = i.next;
        if (s !== void 0)
          for (; s !== void 0; )
            lr = {
              name: s.name,
              styles: s.styles,
              next: lr
            }, s = s.next;
        var a = i.styles + ";";
        return a;
      }
      return yB(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var c = lr, l = n(e);
        return lr = c, ra(e, t, l);
      }
      break;
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function yB(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      r += ra(e, t, n[o]) + ";";
  else
    for (var i in n) {
      var s = n[i];
      if (typeof s != "object") {
        var a = s;
        t != null && t[a] !== void 0 ? r += i + "{" + t[a] + "}" : tb(a) && (r += Ad(i) + ":" + nb(i, a) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var c = 0; c < s.length; c++)
          tb(s[c]) && (r += Ad(i) + ":" + nb(i, s[c]) + ";");
      else {
        var l = ra(e, t, s);
        switch (i) {
          case "animation":
          case "animationName": {
            r += Ad(i) + ":" + l + ";";
            break;
          }
          default:
            r += i + "{" + l + "}";
        }
      }
    }
  return r;
}
var rb = /label:\s*([^\s;{]+)\s*(;|$)/g, lr;
function Ql(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, o = "";
  lr = void 0;
  var i = e[0];
  if (i == null || i.raw === void 0)
    r = !1, o += ra(n, t, i);
  else {
    var s = i;
    o += s[0];
  }
  for (var a = 1; a < e.length; a++)
    if (o += ra(n, t, e[a]), r) {
      var c = i;
      o += c[a];
    }
  rb.lastIndex = 0;
  for (var l = "", u; (u = rb.exec(o)) !== null; )
    l += "-" + u[1];
  var d = mB(o) + l;
  return {
    name: d,
    styles: o,
    next: lr
  };
}
var SB = function(t) {
  return t();
}, _1 = ie.useInsertionEffect ? ie.useInsertionEffect : !1, O1 = _1 || SB, ob = _1 || ie.useLayoutEffect, vh = /* @__PURE__ */ ie.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ uB({
    key: "css"
  }) : null
);
vh.Provider;
var xB = function() {
  return at(vh);
}, yh = function(t) {
  return /* @__PURE__ */ _t(function(n, r) {
    var o = at(vh);
    return t(n, o, r);
  });
}, Lo = /* @__PURE__ */ ie.createContext({}), CB = function(t, n) {
  if (typeof n == "function") {
    var r = n(t);
    return r;
  }
  return Ie({}, t, n);
}, IB = /* @__PURE__ */ Ug(function(e) {
  return Ug(function(t) {
    return CB(e, t);
  });
}), wB = function(t) {
  var n = ie.useContext(Lo);
  return t.theme !== n && (n = IB(n)(t.theme)), /* @__PURE__ */ ie.createElement(Lo.Provider, {
    value: n
  }, t.children);
}, Sh = {}.hasOwnProperty, jf = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", PB = function(t, n) {
  var r = {};
  for (var o in n)
    Sh.call(n, o) && (r[o] = n[o]);
  return r[jf] = t, r;
}, kB = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return gh(n, r, o), O1(function() {
    return bh(n, r, o);
  }), null;
}, AB = /* @__PURE__ */ yh(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var o = e[jf], i = [r], s = "";
  typeof e.className == "string" ? s = E1(t.registered, i, e.className) : e.className != null && (s = e.className + " ");
  var a = Ql(i, void 0, ie.useContext(Lo));
  s += t.key + "-" + a.name;
  var c = {};
  for (var l in e)
    Sh.call(e, l) && l !== "css" && l !== jf && (c[l] = e[l]);
  return c.className = s, n && (c.ref = n), /* @__PURE__ */ ie.createElement(ie.Fragment, null, /* @__PURE__ */ ie.createElement(kB, {
    cache: t,
    serialized: a,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ ie.createElement(o, c));
}), TB = AB, Ee = function(t, n) {
  var r = arguments;
  if (n == null || !Sh.call(n, "css"))
    return ie.createElement.apply(void 0, r);
  var o = r.length, i = new Array(o);
  i[0] = TB, i[1] = PB(t, n);
  for (var s = 2; s < o; s++)
    i[s] = r[s];
  return ie.createElement.apply(null, i);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Ee || (Ee = {}));
var eu = /* @__PURE__ */ yh(function(e, t) {
  var n = e.styles, r = Ql([n], void 0, ie.useContext(Lo)), o = ie.useRef();
  return ob(function() {
    var i = t.key + "-global", s = new t.sheet.constructor({
      key: i,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), a = !1, c = document.querySelector('style[data-emotion="' + i + " " + r.name + '"]');
    return t.sheet.tags.length && (s.before = t.sheet.tags[0]), c !== null && (a = !0, c.setAttribute("data-emotion", i), s.hydrate([c])), o.current = [s, a], function() {
      s.flush();
    };
  }, [t]), ob(function() {
    var i = o.current, s = i[0], a = i[1];
    if (a) {
      i[1] = !1;
      return;
    }
    if (r.next !== void 0 && bh(t, r.next, !0), s.tags.length) {
      var c = s.tags[s.tags.length - 1].nextElementSibling;
      s.before = c, s.flush();
    }
    t.insert("", r, s, !1);
  }, [t, r.name]), null;
});
function xh() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Ql(t);
}
function An() {
  var e = xh.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
const Pa = an({});
Pa.displayName = "ColorModeContext";
function tu() {
  const e = at(Pa);
  if (e === void 0)
    throw new Error("useColorMode must be used within a ColorModeProvider");
  return e;
}
function ib(e, t) {
  const { colorMode: n } = tu();
  return n === "dark" ? t : e;
}
const tc = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function EB(e = {}) {
  const { preventTransition: t = !0, nonce: n } = e, r = {
    setDataset: (o) => {
      const i = t ? r.preventTransition() : void 0;
      document.documentElement.dataset.theme = o, document.documentElement.style.colorScheme = o, i?.();
    },
    setClassName(o) {
      document.body.classList.add(o ? tc.dark : tc.light), document.body.classList.remove(o ? tc.light : tc.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(o) {
      return r.query().matches ?? o === "dark" ? "dark" : "light";
    },
    addListener(o) {
      const i = r.query(), s = (a) => {
        o(a.matches ? "dark" : "light");
      };
      return typeof i.addListener == "function" ? i.addListener(s) : i.addEventListener("change", s), () => {
        typeof i.removeListener == "function" ? i.removeListener(s) : i.removeEventListener("change", s);
      };
    },
    preventTransition() {
      const o = document.createElement("style");
      return o.appendChild(
        document.createTextNode(
          "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}"
        )
      ), n !== void 0 && (o.nonce = n), document.head.appendChild(o), () => {
        window.getComputedStyle(document.body), requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(o);
          });
        });
      };
    }
  };
  return r;
}
const RB = "chakra-ui-color-mode";
function _B(e) {
  return {
    ssr: !1,
    type: "localStorage",
    get(t) {
      if (!globalThis?.document)
        return t;
      let n;
      try {
        n = localStorage.getItem(e) || t;
      } catch {
      }
      return n || t;
    },
    set(t) {
      try {
        localStorage.setItem(e, t);
      } catch {
      }
    }
  };
}
const OB = _B(RB), cl = () => {
}, NB = oA() ? os : ge;
function sb(e, t) {
  return e.type === "cookie" && e.ssr ? e.get(t) : t;
}
const N1 = function(t) {
  const {
    value: n,
    children: r,
    options: {
      useSystemColorMode: o,
      initialColorMode: i,
      disableTransitionOnChange: s
    } = {},
    colorModeManager: a = OB
  } = t, c = xB(), l = i === "dark" ? "dark" : "light", [u, d] = ue(
    () => sb(a, l)
  ), [f, p] = ue(
    () => sb(a)
  ), { getSystemTheme: m, setClassName: h, setDataset: g, addListener: v } = be(
    () => EB({
      preventTransition: s,
      nonce: c?.nonce
    }),
    [s, c?.nonce]
  ), y = i === "system" && !u ? f : u, x = R(
    (w) => {
      const I = w === "system" ? m() : w;
      d(I), h(I === "dark"), g(I), a.set(I);
    },
    [a, m, h, g]
  );
  NB(() => {
    i === "system" && p(m());
  }, []), ge(() => {
    const w = a.get();
    if (w) {
      x(w);
      return;
    }
    if (i === "system") {
      x("system");
      return;
    }
    x(l);
  }, [a, l, i, x]);
  const S = R(() => {
    x(y === "dark" ? "light" : "dark");
  }, [y, x]);
  ge(() => {
    if (o)
      return v(x);
  }, [o, v, x]);
  const C = be(
    () => ({
      colorMode: n ?? y,
      toggleColorMode: n ? cl : S,
      setColorMode: n ? cl : x,
      forced: n !== void 0
    }),
    [y, S, x, n]
  );
  return /* @__PURE__ */ b(Pa.Provider, { value: C, children: r });
};
N1.displayName = "ColorModeProvider";
function MB(e) {
  const t = be(
    () => ({
      colorMode: "dark",
      toggleColorMode: cl,
      setColorMode: cl,
      forced: !0
    }),
    []
  );
  return /* @__PURE__ */ b(Pa.Provider, { value: t, ...e });
}
MB.displayName = "DarkMode";
const M1 = String.raw, B1 = M1`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`, BB = () => /* @__PURE__ */ b(eu, { styles: B1 }), FB = ({ scope: e = "" }) => /* @__PURE__ */ b(
  eu,
  {
    styles: M1`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${e} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${e} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${e} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${e} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${e} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${e} :where(b, strong) {
        font-weight: bold;
      }

      ${e} small {
        font-size: 80%;
      }

      ${e} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${e} sub {
        bottom: -0.25em;
      }

      ${e} sup {
        top: -0.5em;
      }

      ${e} img {
        border-style: none;
      }

      ${e} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${e} :where(button, input) {
        overflow: visible;
      }

      ${e} :where(button, select) {
        text-transform: none;
      }

      ${e} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${e} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${e} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${e} progress {
        vertical-align: baseline;
      }

      ${e} textarea {
        overflow: auto;
      }

      ${e} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${e} input[type="number"]::-webkit-inner-spin-button,
      ${e} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${e} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${e} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${e} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${e} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${e} details {
        display: block;
      }

      ${e} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${e} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${e} button {
        background: transparent;
        padding: 0;
      }

      ${e} fieldset {
        margin: 0;
        padding: 0;
      }

      ${e} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${e} textarea {
        resize: vertical;
      }

      ${e} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${e} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${e} table {
        border-collapse: collapse;
      }

      ${e} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${e} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${e} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${e} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${e} select::-ms-expand {
        display: none;
      }

      ${B1}
    `
  }
);
function F1(e) {
  const { cssVarsRoot: t, theme: n, children: r } = e, o = be(() => IE(n), [n]);
  return /* @__PURE__ */ Ae(wB, { theme: o, children: [
    /* @__PURE__ */ b(DB, { root: t }),
    r
  ] });
}
function DB({ root: e = ":host, :root" }) {
  const t = [e, "[data-theme]"].join(",");
  return /* @__PURE__ */ b(eu, { styles: (n) => ({ [t]: n.__cssVars }) });
}
De({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function D1(e) {
  return De({
    name: `${e}StylesContext`,
    errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${e} />" `
  });
}
function $B() {
  const { colorMode: e } = tu();
  return /* @__PURE__ */ b(
    eu,
    {
      styles: (t) => {
        const n = D0(t, "styles.global"), r = jt(n, { theme: t, colorMode: e });
        return r ? s1(r)(t) : void 0;
      }
    }
  );
}
const [VB, LB] = De({
  strict: !1,
  name: "PortalManagerContext"
});
function $1(e) {
  const { children: t, zIndex: n } = e;
  return /* @__PURE__ */ b(VB, { value: { zIndex: n }, children: t });
}
$1.displayName = "PortalManager";
const Ch = an({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
Ch.displayName = "EnvironmentContext";
function zB({ defer: e } = {}) {
  const [, t] = Qk((n) => n + 1, 0);
  return Dn(() => {
    e && t();
  }, [e]), at(Ch);
}
function V1(e) {
  const { children: t, environment: n, disabled: r } = e, o = se(null), i = be(() => n || {
    getDocument: () => o.current?.ownerDocument ?? document,
    getWindow: () => o.current?.ownerDocument.defaultView ?? window
  }, [n]), s = !r || !n;
  return /* @__PURE__ */ Ae(Ch.Provider, { value: i, children: [
    t,
    s && /* @__PURE__ */ b("span", { id: "__chakra_env", hidden: !0, ref: o })
  ] });
}
V1.displayName = "EnvironmentProvider";
const GB = (e) => {
  const {
    children: t,
    colorModeManager: n,
    portalZIndex: r,
    resetScope: o,
    resetCSS: i = !0,
    theme: s = {},
    environment: a,
    cssVarsRoot: c,
    disableEnvironment: l,
    disableGlobalStyle: u
  } = e, d = /* @__PURE__ */ b(
    V1,
    {
      environment: a,
      disabled: l,
      children: t
    }
  );
  return /* @__PURE__ */ b(F1, { theme: s, cssVarsRoot: c, children: /* @__PURE__ */ Ae(
    N1,
    {
      colorModeManager: n,
      options: s.config,
      children: [
        i ? /* @__PURE__ */ b(FB, { scope: o }) : /* @__PURE__ */ b(BB, {}),
        !u && /* @__PURE__ */ b($B, {}),
        r ? /* @__PURE__ */ b($1, { zIndex: r, children: d }) : d
      ]
    }
  ) });
}, L1 = an({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
}), nu = an({}), ka = an(null), ru = typeof document < "u", Ih = ru ? os : ge, z1 = an({ strict: !1 }), wh = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), WB = "framerAppearId", G1 = "data-" + wh(WB);
function HB(e, t, n, r) {
  const { visualElement: o } = at(nu), i = at(z1), s = at(ka), a = at(L1).reducedMotion, c = se();
  r = r || i.renderer, !c.current && r && (c.current = r(e, {
    visualState: t,
    parent: o,
    props: n,
    presenceContext: s,
    blockInitialAnimation: s ? s.initial === !1 : !1,
    reducedMotionConfig: a
  }));
  const l = c.current;
  A0(() => {
    l && l.update(n, s);
  });
  const u = se(!!(n[G1] && !window.HandoffComplete));
  return Ih(() => {
    l && (l.render(), u.current && l.animationState && l.animationState.animateChanges());
  }), ge(() => {
    l && (l.updateFeatures(), !u.current && l.animationState && l.animationState.animateChanges(), u.current && (u.current = !1, window.HandoffComplete = !0));
  }), l;
}
function xi(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function jB(e, t, n) {
  return R(
    (r) => {
      r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : xi(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [t]
  );
}
function oa(e) {
  return typeof e == "string" || Array.isArray(e);
}
function ou(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
const Ph = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], kh = ["initial", ...Ph];
function iu(e) {
  return ou(e.animate) || kh.some((t) => oa(e[t]));
}
function W1(e) {
  return !!(iu(e) || e.variants);
}
function XB(e, t) {
  if (iu(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || oa(n) ? n : void 0,
      animate: oa(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function YB(e) {
  const { initial: t, animate: n } = XB(e, at(nu));
  return be(() => ({ initial: t, animate: n }), [ab(t), ab(n)]);
}
function ab(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const cb = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, ia = {};
for (const e in cb)
  ia[e] = {
    isEnabled: (t) => cb[e].some((n) => !!t[n])
  };
function ZB(e) {
  for (const t in e)
    ia[t] = {
      ...ia[t],
      ...e[t]
    };
}
const Ah = an({}), H1 = an({}), UB = Symbol.for("motionComponentSymbol");
function JB({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: o }) {
  e && ZB(e);
  function i(a, c) {
    let l;
    const u = {
      ...at(L1),
      ...a,
      layoutId: KB(a)
    }, { isStatic: d } = u, f = YB(a), p = r(a, d);
    if (!d && ru) {
      f.visualElement = HB(o, p, u, t);
      const m = at(H1), h = at(z1).strict;
      f.visualElement && (l = f.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        u,
        h,
        e,
        m
      ));
    }
    return ie.createElement(
      nu.Provider,
      { value: f },
      l && f.visualElement ? ie.createElement(l, { visualElement: f.visualElement, ...u }) : null,
      n(o, a, jB(p, f.visualElement, c), p, d, f.visualElement)
    );
  }
  const s = _t(i);
  return s[UB] = o, s;
}
function KB({ layoutId: e }) {
  const t = at(Ah).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function qB(e) {
  function t(r, o = {}) {
    return JB(e(r, o));
  }
  if (typeof Proxy > "u")
    return t;
  const n = /* @__PURE__ */ new Map();
  return new Proxy(t, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, o) => (n.has(o) || n.set(o, t(o)), n.get(o))
  });
}
const QB = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Th(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(QB.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(e))
    )
  );
}
const ll = {};
function eF(e) {
  Object.assign(ll, e);
}
const Aa = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], jo = new Set(Aa);
function j1(e, { layout: t, layoutId: n }) {
  return jo.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!ll[e] || e === "opacity");
}
const gn = (e) => !!(e && e.getVelocity), tF = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, nF = Aa.length;
function rF(e, { enableHardwareAcceleration: t = !0, allowTransformNone: n = !0 }, r, o) {
  let i = "";
  for (let s = 0; s < nF; s++) {
    const a = Aa[s];
    if (e[a] !== void 0) {
      const c = tF[a] || a;
      i += `${c}(${e[a]}) `;
    }
  }
  return t && !e.z && (i += "translateZ(0)"), i = i.trim(), o ? i = o(e, r ? "" : i) : n && r && (i = "none"), i;
}
const X1 = (e) => (t) => typeof t == "string" && t.startsWith(e), Y1 = X1("--"), Xf = X1("var(--"), oF = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, iF = (e, t) => t && typeof e == "number" ? t.transform(e) : e, ro = (e, t, n) => Math.min(Math.max(n, e), t), Xo = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Hs = {
  ...Xo,
  transform: (e) => ro(0, 1, e)
}, nc = {
  ...Xo,
  default: 1
}, js = (e) => Math.round(e * 1e5) / 1e5, su = /(-)?([\d]*\.?[\d])+/g, Z1 = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, sF = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function Ta(e) {
  return typeof e == "string";
}
const Ea = (e) => ({
  test: (t) => Ta(t) && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Jr = Ea("deg"), mr = Ea("%"), Me = Ea("px"), aF = Ea("vh"), cF = Ea("vw"), lb = {
  ...mr,
  parse: (e) => mr.parse(e) / 100,
  transform: (e) => mr.transform(e * 100)
}, ub = {
  ...Xo,
  transform: Math.round
}, U1 = {
  // Border props
  borderWidth: Me,
  borderTopWidth: Me,
  borderRightWidth: Me,
  borderBottomWidth: Me,
  borderLeftWidth: Me,
  borderRadius: Me,
  radius: Me,
  borderTopLeftRadius: Me,
  borderTopRightRadius: Me,
  borderBottomRightRadius: Me,
  borderBottomLeftRadius: Me,
  // Positioning props
  width: Me,
  maxWidth: Me,
  height: Me,
  maxHeight: Me,
  size: Me,
  top: Me,
  right: Me,
  bottom: Me,
  left: Me,
  // Spacing props
  padding: Me,
  paddingTop: Me,
  paddingRight: Me,
  paddingBottom: Me,
  paddingLeft: Me,
  margin: Me,
  marginTop: Me,
  marginRight: Me,
  marginBottom: Me,
  marginLeft: Me,
  // Transform props
  rotate: Jr,
  rotateX: Jr,
  rotateY: Jr,
  rotateZ: Jr,
  scale: nc,
  scaleX: nc,
  scaleY: nc,
  scaleZ: nc,
  skew: Jr,
  skewX: Jr,
  skewY: Jr,
  distance: Me,
  translateX: Me,
  translateY: Me,
  translateZ: Me,
  x: Me,
  y: Me,
  z: Me,
  perspective: Me,
  transformPerspective: Me,
  opacity: Hs,
  originX: lb,
  originY: lb,
  originZ: Me,
  // Misc
  zIndex: ub,
  // SVG
  fillOpacity: Hs,
  strokeOpacity: Hs,
  numOctaves: ub
};
function Eh(e, t, n, r) {
  const { style: o, vars: i, transform: s, transformOrigin: a } = e;
  let c = !1, l = !1, u = !0;
  for (const d in t) {
    const f = t[d];
    if (Y1(d)) {
      i[d] = f;
      continue;
    }
    const p = U1[d], m = iF(f, p);
    if (jo.has(d)) {
      if (c = !0, s[d] = m, !u)
        continue;
      f !== (p.default || 0) && (u = !1);
    } else d.startsWith("origin") ? (l = !0, a[d] = m) : o[d] = m;
  }
  if (t.transform || (c || r ? o.transform = rF(e.transform, n, u, r) : o.transform && (o.transform = "none")), l) {
    const { originX: d = "50%", originY: f = "50%", originZ: p = 0 } = a;
    o.transformOrigin = `${d} ${f} ${p}`;
  }
}
const Rh = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function J1(e, t, n) {
  for (const r in t)
    !gn(t[r]) && !j1(r, n) && (e[r] = t[r]);
}
function lF({ transformTemplate: e }, t, n) {
  return be(() => {
    const r = Rh();
    return Eh(r, t, { enableHardwareAcceleration: !n }, e), Object.assign({}, r.vars, r.style);
  }, [t]);
}
function uF(e, t, n) {
  const r = e.style || {}, o = {};
  return J1(o, r, e), Object.assign(o, lF(e, t, n)), e.transformValues ? e.transformValues(o) : o;
}
function dF(e, t, n) {
  const r = {}, o = uF(e, t, n);
  return e.drag && e.dragListener !== !1 && (r.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (r.tabIndex = 0), r.style = o, r;
}
const fF = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function ul(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || fF.has(e);
}
let K1 = (e) => !ul(e);
function pF(e) {
  e && (K1 = (t) => t.startsWith("on") ? !ul(t) : e(t));
}
try {
  pF(require("@emotion/is-prop-valid").default);
} catch {
}
function hF(e, t, n) {
  const r = {};
  for (const o in e)
    o === "values" && typeof e.values == "object" || (K1(o) || n === !0 && ul(o) || !t && !ul(o) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && o.startsWith("onDrag")) && (r[o] = e[o]);
  return r;
}
function db(e, t, n) {
  return typeof e == "string" ? e : Me.transform(t + n * e);
}
function mF(e, t, n) {
  const r = db(t, e.x, e.width), o = db(n, e.y, e.height);
  return `${r} ${o}`;
}
const gF = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, bF = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function vF(e, t, n = 1, r = 0, o = !0) {
  e.pathLength = 1;
  const i = o ? gF : bF;
  e[i.offset] = Me.transform(-r);
  const s = Me.transform(t), a = Me.transform(n);
  e[i.array] = `${s} ${a}`;
}
function _h(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  originX: o,
  originY: i,
  pathLength: s,
  pathSpacing: a = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...l
}, u, d, f) {
  if (Eh(e, l, u, f), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: p, style: m, dimensions: h } = e;
  p.transform && (h && (m.transform = p.transform), delete p.transform), h && (o !== void 0 || i !== void 0 || m.transform) && (m.transformOrigin = mF(h, o !== void 0 ? o : 0.5, i !== void 0 ? i : 0.5)), t !== void 0 && (p.x = t), n !== void 0 && (p.y = n), r !== void 0 && (p.scale = r), s !== void 0 && vF(p, s, a, c, !1);
}
const q1 = () => ({
  ...Rh(),
  attrs: {}
}), Oh = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function yF(e, t, n, r) {
  const o = be(() => {
    const i = q1();
    return _h(i, t, { enableHardwareAcceleration: !1 }, Oh(r), e.transformTemplate), {
      ...i.attrs,
      style: { ...i.style }
    };
  }, [t]);
  if (e.style) {
    const i = {};
    J1(i, e.style, e), o.style = { ...i, ...o.style };
  }
  return o;
}
function SF(e = !1) {
  return (n, r, o, { latestValues: i }, s) => {
    const c = (Th(n) ? yF : dF)(r, i, s, n), u = {
      ...hF(r, typeof n == "string", e),
      ...c,
      ref: o
    }, { children: d } = r, f = be(() => gn(d) ? d.get() : d, [d]);
    return eh(n, {
      ...u,
      children: f
    });
  };
}
function Q1(e, { style: t, vars: n }, r, o) {
  Object.assign(e.style, t, o && o.getProjectionStyles(r));
  for (const i in n)
    e.style.setProperty(i, n[i]);
}
const eS = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function tS(e, t, n, r) {
  Q1(e, t, void 0, r);
  for (const o in t.attrs)
    e.setAttribute(eS.has(o) ? o : wh(o), t.attrs[o]);
}
function Nh(e, t) {
  const { style: n } = e, r = {};
  for (const o in n)
    (gn(n[o]) || t.style && gn(t.style[o]) || j1(o, e)) && (r[o] = n[o]);
  return r;
}
function nS(e, t) {
  const n = Nh(e, t);
  for (const r in e)
    if (gn(e[r]) || gn(t[r])) {
      const o = Aa.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
      n[o] = e[r];
    }
  return n;
}
function Mh(e, t, n, r = {}, o = {}) {
  return typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, o)), typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, o)), t;
}
function rS(e) {
  const t = se(null);
  return t.current === null && (t.current = e()), t.current;
}
const dl = (e) => Array.isArray(e), xF = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), CF = (e) => dl(e) ? e[e.length - 1] || 0 : e;
function Vc(e) {
  const t = gn(e) ? e.get() : e;
  return xF(t) ? t.toValue() : t;
}
function IF({ scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n }, r, o, i) {
  const s = {
    latestValues: wF(r, o, i, e),
    renderState: t()
  };
  return n && (s.mount = (a) => n(r, a, s)), s;
}
const oS = (e) => (t, n) => {
  const r = at(nu), o = at(ka), i = () => IF(e, t, r, o);
  return n ? i() : rS(i);
};
function wF(e, t, n, r) {
  const o = {}, i = r(e, {});
  for (const f in i)
    o[f] = Vc(i[f]);
  let { initial: s, animate: a } = e;
  const c = iu(e), l = W1(e);
  t && l && !c && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || s === !1;
  const d = u ? a : s;
  return d && typeof d != "boolean" && !ou(d) && (Array.isArray(d) ? d : [d]).forEach((p) => {
    const m = Mh(e, p);
    if (!m)
      return;
    const { transitionEnd: h, transition: g, ...v } = m;
    for (const y in v) {
      let x = v[y];
      if (Array.isArray(x)) {
        const S = u ? x.length - 1 : 0;
        x = x[S];
      }
      x !== null && (o[y] = x);
    }
    for (const y in h)
      o[y] = h[y];
  }), o;
}
const Tt = (e) => e;
class fb {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(t) {
    if (!this.scheduled.has(t))
      return this.scheduled.add(t), this.order.push(t), !0;
  }
  remove(t) {
    const n = this.order.indexOf(t);
    n !== -1 && (this.order.splice(n, 1), this.scheduled.delete(t));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function PF(e) {
  let t = new fb(), n = new fb(), r = 0, o = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet(), a = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, l = !1, u = !1) => {
      const d = u && o, f = d ? t : n;
      return l && s.add(c), f.add(c) && d && o && (r = t.order.length), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      n.remove(c), s.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (o) {
        i = !0;
        return;
      }
      if (o = !0, [t, n] = [n, t], n.clear(), r = t.order.length, r)
        for (let l = 0; l < r; l++) {
          const u = t.order[l];
          u(c), s.has(u) && (a.schedule(u), e());
        }
      o = !1, i && (i = !1, a.process(c));
    }
  };
  return a;
}
const rc = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], kF = 40;
function AF(e, t) {
  let n = !1, r = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, i = rc.reduce((d, f) => (d[f] = PF(() => n = !0), d), {}), s = (d) => i[d].process(o), a = () => {
    const d = performance.now();
    n = !1, o.delta = r ? 1e3 / 60 : Math.max(Math.min(d - o.timestamp, kF), 1), o.timestamp = d, o.isProcessing = !0, rc.forEach(s), o.isProcessing = !1, n && t && (r = !1, e(a));
  }, c = () => {
    n = !0, r = !0, o.isProcessing || e(a);
  };
  return { schedule: rc.reduce((d, f) => {
    const p = i[f];
    return d[f] = (m, h = !1, g = !1) => (n || c(), p.schedule(m, h, g)), d;
  }, {}), cancel: (d) => rc.forEach((f) => i[f].cancel(d)), state: o, steps: i };
}
const { schedule: ht, cancel: zr, state: en, steps: Td } = AF(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Tt, !0), TF = {
  useVisualState: oS({
    scrapeMotionValuesFromProps: nS,
    createRenderState: q1,
    onMount: (e, t, { renderState: n, latestValues: r }) => {
      ht.read(() => {
        try {
          n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
        } catch {
          n.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), ht.render(() => {
        _h(n, r, { enableHardwareAcceleration: !1 }, Oh(t.tagName), e.transformTemplate), tS(t, n);
      });
    }
  })
}, EF = {
  useVisualState: oS({
    scrapeMotionValuesFromProps: Nh,
    createRenderState: Rh
  })
};
function RF(e, { forwardMotionProps: t = !1 }, n, r) {
  return {
    ...Th(e) ? TF : EF,
    preloadedFeatures: n,
    useRender: SF(t),
    createVisualElement: r,
    Component: e
  };
}
function Mr(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
const iS = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function au(e, t = "page") {
  return {
    point: {
      x: e[t + "X"],
      y: e[t + "Y"]
    }
  };
}
const _F = (e) => (t) => iS(t) && e(t, au(t));
function Fr(e, t, n, r) {
  return Mr(e, t, _F(n), r);
}
const OF = (e, t) => (n) => t(e(n)), eo = (...e) => e.reduce(OF);
function sS(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const pb = sS("dragHorizontal"), hb = sS("dragVertical");
function aS(e) {
  let t = !1;
  if (e === "y")
    t = hb();
  else if (e === "x")
    t = pb();
  else {
    const n = pb(), r = hb();
    n && r ? t = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return t;
}
function cS() {
  const e = aS(!0);
  return e ? (e(), !1) : !0;
}
class lo {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function mb(e, t) {
  const n = "pointer" + (t ? "enter" : "leave"), r = "onHover" + (t ? "Start" : "End"), o = (i, s) => {
    if (i.pointerType === "touch" || cS())
      return;
    const a = e.getProps();
    e.animationState && a.whileHover && e.animationState.setActive("whileHover", t), a[r] && ht.update(() => a[r](i, s));
  };
  return Fr(e.current, n, o, {
    passive: !e.getProps()[r]
  });
}
class NF extends lo {
  mount() {
    this.unmount = eo(mb(this.node, !0), mb(this.node, !1));
  }
  unmount() {
  }
}
class MF extends lo {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = eo(Mr(this.node.current, "focus", () => this.onFocus()), Mr(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const lS = (e, t) => t ? e === t ? !0 : lS(e, t.parentElement) : !1;
function Ed(e, t) {
  if (!t)
    return;
  const n = new PointerEvent("pointer" + e);
  t(n, au(n));
}
class BF extends lo {
  constructor() {
    super(...arguments), this.removeStartListeners = Tt, this.removeEndListeners = Tt, this.removeAccessibleListeners = Tt, this.startPointerPress = (t, n) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const r = this.node.getProps(), i = Fr(window, "pointerup", (a, c) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: l, onTapCancel: u, globalTapTarget: d } = this.node.getProps();
        ht.update(() => {
          !d && !lS(this.node.current, a.target) ? u && u(a, c) : l && l(a, c);
        });
      }, { passive: !(r.onTap || r.onPointerUp) }), s = Fr(window, "pointercancel", (a, c) => this.cancelPress(a, c), { passive: !(r.onTapCancel || r.onPointerCancel) });
      this.removeEndListeners = eo(i, s), this.startPress(t, n);
    }, this.startAccessiblePress = () => {
      const t = (i) => {
        if (i.key !== "Enter" || this.isPressing)
          return;
        const s = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || Ed("up", (c, l) => {
            const { onTap: u } = this.node.getProps();
            u && ht.update(() => u(c, l));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Mr(this.node.current, "keyup", s), Ed("down", (a, c) => {
          this.startPress(a, c);
        });
      }, n = Mr(this.node.current, "keydown", t), r = () => {
        this.isPressing && Ed("cancel", (i, s) => this.cancelPress(i, s));
      }, o = Mr(this.node.current, "blur", r);
      this.removeAccessibleListeners = eo(n, o);
    };
  }
  startPress(t, n) {
    this.isPressing = !0;
    const { onTapStart: r, whileTap: o } = this.node.getProps();
    o && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && ht.update(() => r(t, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !cS();
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: r } = this.node.getProps();
    r && ht.update(() => r(t, n));
  }
  mount() {
    const t = this.node.getProps(), n = Fr(t.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(t.onTapStart || t.onPointerStart) }), r = Mr(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = eo(n, r);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const Yf = /* @__PURE__ */ new WeakMap(), Rd = /* @__PURE__ */ new WeakMap(), FF = (e) => {
  const t = Yf.get(e.target);
  t && t(e);
}, DF = (e) => {
  e.forEach(FF);
};
function $F({ root: e, ...t }) {
  const n = e || document;
  Rd.has(n) || Rd.set(n, {});
  const r = Rd.get(n), o = JSON.stringify(t);
  return r[o] || (r[o] = new IntersectionObserver(DF, { root: e, ...t })), r[o];
}
function VF(e, t, n) {
  const r = $F(t);
  return Yf.set(e, n), r.observe(e), () => {
    Yf.delete(e), r.unobserve(e);
  };
}
const LF = {
  some: 0,
  all: 1
};
class zF extends lo {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: o = "some", once: i } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof o == "number" ? o : LF[o]
    }, a = (c) => {
      const { isIntersecting: l } = c;
      if (this.isInView === l || (this.isInView = l, i && !l && this.hasEnteredView))
        return;
      l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
      const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(), f = l ? u : d;
      f && f(c);
    };
    return VF(this.node.current, s, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(GF(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function GF({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const WF = {
  inView: {
    Feature: zF
  },
  tap: {
    Feature: BF
  },
  focus: {
    Feature: MF
  },
  hover: {
    Feature: NF
  }
};
function uS(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function HF(e) {
  const t = {};
  return e.values.forEach((n, r) => t[r] = n.get()), t;
}
function jF(e) {
  const t = {};
  return e.values.forEach((n, r) => t[r] = n.getVelocity()), t;
}
function cu(e, t, n) {
  const r = e.getProps();
  return Mh(r, t, n !== void 0 ? n : r.custom, HF(e), jF(e));
}
let Ra = Tt, Vn = Tt;
process.env.NODE_ENV !== "production" && (Ra = (e, t) => {
  !e && typeof console < "u" && console.warn(t);
}, Vn = (e, t) => {
  if (!e)
    throw new Error(t);
});
const to = (e) => e * 1e3, Dr = (e) => e / 1e3, XF = {
  current: !1
}, dS = (e) => Array.isArray(e) && typeof e[0] == "number";
function fS(e) {
  return !!(!e || typeof e == "string" && pS[e] || dS(e) || Array.isArray(e) && e.every(fS));
}
const Os = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, pS = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: Os([0, 0.65, 0.55, 1]),
  circOut: Os([0.55, 0, 1, 0.45]),
  backIn: Os([0.31, 0.01, 0.66, -0.59]),
  backOut: Os([0.33, 1.53, 0.69, 0.99])
};
function hS(e) {
  if (e)
    return dS(e) ? Os(e) : Array.isArray(e) ? e.map(hS) : pS[e];
}
function YF(e, t, n, { delay: r = 0, duration: o, repeat: i = 0, repeatType: s = "loop", ease: a, times: c } = {}) {
  const l = { [t]: n };
  c && (l.offset = c);
  const u = hS(a);
  return Array.isArray(u) && (l.easing = u), e.animate(l, {
    delay: r,
    duration: o,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: i + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  });
}
function ZF(e, { repeat: t, repeatType: n = "loop" }) {
  const r = t && n !== "loop" && t % 2 === 1 ? 0 : e.length - 1;
  return e[r];
}
const mS = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, UF = 1e-7, JF = 12;
function KF(e, t, n, r, o) {
  let i, s, a = 0;
  do
    s = t + (n - t) / 2, i = mS(s, r, o) - e, i > 0 ? n = s : t = s;
  while (Math.abs(i) > UF && ++a < JF);
  return s;
}
function _a(e, t, n, r) {
  if (e === t && n === r)
    return Tt;
  const o = (i) => KF(i, 0, 1, e, n);
  return (i) => i === 0 || i === 1 ? i : mS(o(i), t, r);
}
const qF = _a(0.42, 0, 1, 1), QF = _a(0, 0, 0.58, 1), gS = _a(0.42, 0, 0.58, 1), eD = (e) => Array.isArray(e) && typeof e[0] != "number", bS = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, vS = (e) => (t) => 1 - e(1 - t), Bh = (e) => 1 - Math.sin(Math.acos(e)), yS = vS(Bh), tD = bS(Bh), SS = _a(0.33, 1.53, 0.69, 0.99), Fh = vS(SS), nD = bS(Fh), rD = (e) => (e *= 2) < 1 ? 0.5 * Fh(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), gb = {
  linear: Tt,
  easeIn: qF,
  easeInOut: gS,
  easeOut: QF,
  circIn: Bh,
  circInOut: tD,
  circOut: yS,
  backIn: Fh,
  backInOut: nD,
  backOut: SS,
  anticipate: rD
}, bb = (e) => {
  if (Array.isArray(e)) {
    Vn(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, r, o] = e;
    return _a(t, n, r, o);
  } else if (typeof e == "string")
    return Vn(gb[e] !== void 0, `Invalid easing type '${e}'`), gb[e];
  return e;
}, Dh = (e, t) => (n) => !!(Ta(n) && sF.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)), xS = (e, t, n) => (r) => {
  if (!Ta(r))
    return r;
  const [o, i, s, a] = r.match(su);
  return {
    [e]: parseFloat(o),
    [t]: parseFloat(i),
    [n]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, oD = (e) => ro(0, 255, e), _d = {
  ...Xo,
  transform: (e) => Math.round(oD(e))
}, Po = {
  test: Dh("rgb", "red"),
  parse: xS("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + _d.transform(e) + ", " + _d.transform(t) + ", " + _d.transform(n) + ", " + js(Hs.transform(r)) + ")"
};
function iD(e) {
  let t = "", n = "", r = "", o = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), o = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), o = e.substring(4, 5), t += t, n += n, r += r, o += o), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const Zf = {
  test: Dh("#"),
  parse: iD,
  transform: Po.transform
}, Ci = {
  test: Dh("hsl", "hue"),
  parse: xS("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + mr.transform(js(t)) + ", " + mr.transform(js(n)) + ", " + js(Hs.transform(r)) + ")"
}, rn = {
  test: (e) => Po.test(e) || Zf.test(e) || Ci.test(e),
  parse: (e) => Po.test(e) ? Po.parse(e) : Ci.test(e) ? Ci.parse(e) : Zf.parse(e),
  transform: (e) => Ta(e) ? e : e.hasOwnProperty("red") ? Po.transform(e) : Ci.transform(e)
}, xt = (e, t, n) => -n * e + n * t + e;
function Od(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function sD({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let o = 0, i = 0, s = 0;
  if (!t)
    o = i = s = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - a;
    o = Od(c, a, e + 1 / 3), i = Od(c, a, e), s = Od(c, a, e - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(i * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
const Nd = (e, t, n) => {
  const r = e * e;
  return Math.sqrt(Math.max(0, n * (t * t - r) + r));
}, aD = [Zf, Po, Ci], cD = (e) => aD.find((t) => t.test(e));
function vb(e) {
  const t = cD(e);
  Vn(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`);
  let n = t.parse(e);
  return t === Ci && (n = sD(n)), n;
}
const CS = (e, t) => {
  const n = vb(e), r = vb(t), o = { ...n };
  return (i) => (o.red = Nd(n.red, r.red, i), o.green = Nd(n.green, r.green, i), o.blue = Nd(n.blue, r.blue, i), o.alpha = xt(n.alpha, r.alpha, i), Po.transform(o));
};
function lD(e) {
  var t, n;
  return isNaN(e) && Ta(e) && (((t = e.match(su)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(Z1)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const IS = {
  regex: oF,
  countKey: "Vars",
  token: "${v}",
  parse: Tt
}, wS = {
  regex: Z1,
  countKey: "Colors",
  token: "${c}",
  parse: rn.parse
}, PS = {
  regex: su,
  countKey: "Numbers",
  token: "${n}",
  parse: Xo.parse
};
function Md(e, { regex: t, countKey: n, token: r, parse: o }) {
  const i = e.tokenised.match(t);
  i && (e["num" + n] = i.length, e.tokenised = e.tokenised.replace(t, r), e.values.push(...i.map(o)));
}
function fl(e) {
  const t = e.toString(), n = {
    value: t,
    tokenised: t,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return n.value.includes("var(--") && Md(n, IS), Md(n, wS), Md(n, PS), n;
}
function kS(e) {
  return fl(e).values;
}
function AS(e) {
  const { values: t, numColors: n, numVars: r, tokenised: o } = fl(e), i = t.length;
  return (s) => {
    let a = o;
    for (let c = 0; c < i; c++)
      c < r ? a = a.replace(IS.token, s[c]) : c < r + n ? a = a.replace(wS.token, rn.transform(s[c])) : a = a.replace(PS.token, js(s[c]));
    return a;
  };
}
const uD = (e) => typeof e == "number" ? 0 : e;
function dD(e) {
  const t = kS(e);
  return AS(e)(t.map(uD));
}
const oo = {
  test: lD,
  parse: kS,
  createTransformer: AS,
  getAnimatableNone: dD
}, TS = (e, t) => (n) => `${n > 0 ? t : e}`;
function ES(e, t) {
  return typeof e == "number" ? (n) => xt(e, t, n) : rn.test(e) ? CS(e, t) : e.startsWith("var(") ? TS(e, t) : _S(e, t);
}
const RS = (e, t) => {
  const n = [...e], r = n.length, o = e.map((i, s) => ES(i, t[s]));
  return (i) => {
    for (let s = 0; s < r; s++)
      n[s] = o[s](i);
    return n;
  };
}, fD = (e, t) => {
  const n = { ...e, ...t }, r = {};
  for (const o in n)
    e[o] !== void 0 && t[o] !== void 0 && (r[o] = ES(e[o], t[o]));
  return (o) => {
    for (const i in r)
      n[i] = r[i](o);
    return n;
  };
}, _S = (e, t) => {
  const n = oo.createTransformer(t), r = fl(e), o = fl(t);
  return r.numVars === o.numVars && r.numColors === o.numColors && r.numNumbers >= o.numNumbers ? eo(RS(r.values, o.values), n) : (Ra(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), TS(e, t));
}, sa = (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
}, yb = (e, t) => (n) => xt(e, t, n);
function pD(e) {
  return typeof e == "number" ? yb : typeof e == "string" ? rn.test(e) ? CS : _S : Array.isArray(e) ? RS : typeof e == "object" ? fD : yb;
}
function hD(e, t, n) {
  const r = [], o = n || pD(e[0]), i = e.length - 1;
  for (let s = 0; s < i; s++) {
    let a = o(e[s], e[s + 1]);
    if (t) {
      const c = Array.isArray(t) ? t[s] || Tt : t;
      a = eo(c, a);
    }
    r.push(a);
  }
  return r;
}
function OS(e, t, { clamp: n = !0, ease: r, mixer: o } = {}) {
  const i = e.length;
  if (Vn(i === t.length, "Both input and output ranges must be the same length"), i === 1)
    return () => t[0];
  e[0] > e[i - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const s = hD(t, r, o), a = s.length, c = (l) => {
    let u = 0;
    if (a > 1)
      for (; u < e.length - 2 && !(l < e[u + 1]); u++)
        ;
    const d = sa(e[u], e[u + 1], l);
    return s[u](d);
  };
  return n ? (l) => c(ro(e[0], e[i - 1], l)) : c;
}
function mD(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const o = sa(0, t, r);
    e.push(xt(n, 1, o));
  }
}
function gD(e) {
  const t = [0];
  return mD(t, e.length - 1), t;
}
function bD(e, t) {
  return e.map((n) => n * t);
}
function vD(e, t) {
  return e.map(() => t || gS).splice(0, e.length - 1);
}
function pl({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const o = eD(r) ? r.map(bb) : bb(r), i = {
    done: !1,
    value: t[0]
  }, s = bD(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : gD(t),
    e
  ), a = OS(s, t, {
    ease: Array.isArray(o) ? o : vD(t, o)
  });
  return {
    calculatedDuration: e,
    next: (c) => (i.value = a(c), i.done = c >= e, i)
  };
}
function NS(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const yD = 5;
function MS(e, t, n) {
  const r = Math.max(t - yD, 0);
  return NS(n - e(r), t - r);
}
const Bd = 1e-3, SD = 0.01, Sb = 10, xD = 0.05, CD = 1;
function ID({ duration: e = 800, bounce: t = 0.25, velocity: n = 0, mass: r = 1 }) {
  let o, i;
  Ra(e <= to(Sb), "Spring duration must be 10 seconds or less");
  let s = 1 - t;
  s = ro(xD, CD, s), e = ro(SD, Sb, Dr(e)), s < 1 ? (o = (l) => {
    const u = l * s, d = u * e, f = u - n, p = Uf(l, s), m = Math.exp(-d);
    return Bd - f / p * m;
  }, i = (l) => {
    const d = l * s * e, f = d * n + n, p = Math.pow(s, 2) * Math.pow(l, 2) * e, m = Math.exp(-d), h = Uf(Math.pow(l, 2), s);
    return (-o(l) + Bd > 0 ? -1 : 1) * ((f - p) * m) / h;
  }) : (o = (l) => {
    const u = Math.exp(-l * e), d = (l - n) * e + 1;
    return -Bd + u * d;
  }, i = (l) => {
    const u = Math.exp(-l * e), d = (n - l) * (e * e);
    return u * d;
  });
  const a = 5 / e, c = PD(o, i, a);
  if (e = to(e), isNaN(c))
    return {
      stiffness: 100,
      damping: 10,
      duration: e
    };
  {
    const l = Math.pow(c, 2) * r;
    return {
      stiffness: l,
      damping: s * 2 * Math.sqrt(r * l),
      duration: e
    };
  }
}
const wD = 12;
function PD(e, t, n) {
  let r = n;
  for (let o = 1; o < wD; o++)
    r = r - e(r) / t(r);
  return r;
}
function Uf(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const kD = ["duration", "bounce"], AD = ["stiffness", "damping", "mass"];
function xb(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function TD(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!xb(e, AD) && xb(e, kD)) {
    const n = ID(e);
    t = {
      ...t,
      ...n,
      mass: 1
    }, t.isResolvedFromDuration = !0;
  }
  return t;
}
function BS({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
  const o = e[0], i = e[e.length - 1], s = { done: !1, value: o }, { stiffness: a, damping: c, mass: l, duration: u, velocity: d, isResolvedFromDuration: f } = TD({
    ...r,
    velocity: -Dr(r.velocity || 0)
  }), p = d || 0, m = c / (2 * Math.sqrt(a * l)), h = i - o, g = Dr(Math.sqrt(a / l)), v = Math.abs(h) < 5;
  n || (n = v ? 0.01 : 2), t || (t = v ? 5e-3 : 0.5);
  let y;
  if (m < 1) {
    const x = Uf(g, m);
    y = (S) => {
      const C = Math.exp(-m * g * S);
      return i - C * ((p + m * g * h) / x * Math.sin(x * S) + h * Math.cos(x * S));
    };
  } else if (m === 1)
    y = (x) => i - Math.exp(-g * x) * (h + (p + g * h) * x);
  else {
    const x = g * Math.sqrt(m * m - 1);
    y = (S) => {
      const C = Math.exp(-m * g * S), w = Math.min(x * S, 300);
      return i - C * ((p + m * g * h) * Math.sinh(w) + x * h * Math.cosh(w)) / x;
    };
  }
  return {
    calculatedDuration: f && u || null,
    next: (x) => {
      const S = y(x);
      if (f)
        s.done = x >= u;
      else {
        let C = p;
        x !== 0 && (m < 1 ? C = MS(y, x, S) : C = 0);
        const w = Math.abs(C) <= n, I = Math.abs(i - S) <= t;
        s.done = w && I;
      }
      return s.value = s.done ? i : S, s;
    }
  };
}
function Cb({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: o = 10, bounceStiffness: i = 500, modifyTarget: s, min: a, max: c, restDelta: l = 0.5, restSpeed: u }) {
  const d = e[0], f = {
    done: !1,
    value: d
  }, p = (P) => a !== void 0 && P < a || c !== void 0 && P > c, m = (P) => a === void 0 ? c : c === void 0 || Math.abs(a - P) < Math.abs(c - P) ? a : c;
  let h = n * t;
  const g = d + h, v = s === void 0 ? g : s(g);
  v !== g && (h = v - d);
  const y = (P) => -h * Math.exp(-P / r), x = (P) => v + y(P), S = (P) => {
    const k = y(P), A = x(P);
    f.done = Math.abs(k) <= l, f.value = f.done ? v : A;
  };
  let C, w;
  const I = (P) => {
    p(f.value) && (C = P, w = BS({
      keyframes: [f.value, m(f.value)],
      velocity: MS(x, P, f.value),
      damping: o,
      stiffness: i,
      restDelta: l,
      restSpeed: u
    }));
  };
  return I(0), {
    calculatedDuration: null,
    next: (P) => {
      let k = !1;
      return !w && C === void 0 && (k = !0, S(P), I(P)), C !== void 0 && P > C ? w.next(P - C) : (!k && S(P), f);
    }
  };
}
const ED = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: () => ht.update(t, !0),
    stop: () => zr(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => en.isProcessing ? en.timestamp : performance.now()
  };
}, Ib = 2e4;
function wb(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < Ib; )
    t += n, r = e.next(t);
  return t >= Ib ? 1 / 0 : t;
}
const RD = {
  decay: Cb,
  inertia: Cb,
  tween: pl,
  keyframes: pl,
  spring: BS
};
function hl({ autoplay: e = !0, delay: t = 0, driver: n = ED, keyframes: r, type: o = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: a = "loop", onPlay: c, onStop: l, onComplete: u, onUpdate: d, ...f }) {
  let p = 1, m = !1, h, g;
  const v = () => {
    g = new Promise((_) => {
      h = _;
    });
  };
  v();
  let y;
  const x = RD[o] || pl;
  let S;
  x !== pl && typeof r[0] != "number" && (process.env.NODE_ENV !== "production" && Vn(r.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${r}`), S = OS([0, 100], r, {
    clamp: !1
  }), r = [0, 100]);
  const C = x({ ...f, keyframes: r });
  let w;
  a === "mirror" && (w = x({
    ...f,
    keyframes: [...r].reverse(),
    velocity: -(f.velocity || 0)
  }));
  let I = "idle", P = null, k = null, A = null;
  C.calculatedDuration === null && i && (C.calculatedDuration = wb(C));
  const { calculatedDuration: N } = C;
  let B = 1 / 0, L = 1 / 0;
  N !== null && (B = N + s, L = B * (i + 1) - s);
  let Z = 0;
  const ne = (_) => {
    if (k === null)
      return;
    p > 0 && (k = Math.min(k, _)), p < 0 && (k = Math.min(_ - L / p, k)), P !== null ? Z = P : Z = Math.round(_ - k) * p;
    const j = Z - t * (p >= 0 ? 1 : -1), E = p >= 0 ? j < 0 : j > L;
    Z = Math.max(j, 0), I === "finished" && P === null && (Z = L);
    let M = Z, F = C;
    if (i) {
      const U = Math.min(Z, L) / B;
      let K = Math.floor(U), ae = U % 1;
      !ae && U >= 1 && (ae = 1), ae === 1 && K--, K = Math.min(K, i + 1), !!(K % 2) && (a === "reverse" ? (ae = 1 - ae, s && (ae -= s / B)) : a === "mirror" && (F = w)), M = ro(0, 1, ae) * B;
    }
    const G = E ? { done: !1, value: r[0] } : F.next(M);
    S && (G.value = S(G.value));
    let { done: q } = G;
    !E && N !== null && (q = p >= 0 ? Z >= L : Z <= 0);
    const te = P === null && (I === "finished" || I === "running" && q);
    return d && d(G.value), te && J(), G;
  }, W = () => {
    y && y.stop(), y = void 0;
  }, O = () => {
    I = "idle", W(), h(), v(), k = A = null;
  }, J = () => {
    I = "finished", u && u(), W(), h();
  }, ee = () => {
    if (m)
      return;
    y || (y = n(ne));
    const _ = y.now();
    c && c(), P !== null ? k = _ - P : (!k || I === "finished") && (k = _), I === "finished" && v(), A = k, P = null, I = "running", y.start();
  };
  e && ee();
  const H = {
    then(_, j) {
      return g.then(_, j);
    },
    get time() {
      return Dr(Z);
    },
    set time(_) {
      _ = to(_), Z = _, P !== null || !y || p === 0 ? P = _ : k = y.now() - _ / p;
    },
    get duration() {
      const _ = C.calculatedDuration === null ? wb(C) : C.calculatedDuration;
      return Dr(_);
    },
    get speed() {
      return p;
    },
    set speed(_) {
      _ === p || !y || (p = _, H.time = Dr(Z));
    },
    get state() {
      return I;
    },
    play: ee,
    pause: () => {
      I = "paused", P = Z;
    },
    stop: () => {
      m = !0, I !== "idle" && (I = "idle", l && l(), O());
    },
    cancel: () => {
      A !== null && ne(A), O();
    },
    complete: () => {
      I = "finished";
    },
    sample: (_) => (k = 0, ne(_))
  };
  return H;
}
function _D(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const OD = _D(() => Object.hasOwnProperty.call(Element.prototype, "animate")), ND = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), oc = 10, MD = 2e4, BD = (e, t) => t.type === "spring" || e === "backgroundColor" || !fS(t.ease);
function FD(e, t, { onUpdate: n, onComplete: r, ...o }) {
  if (!(OD() && ND.has(t) && !o.repeatDelay && o.repeatType !== "mirror" && o.damping !== 0 && o.type !== "inertia"))
    return !1;
  let s = !1, a, c, l = !1;
  const u = () => {
    c = new Promise((x) => {
      a = x;
    });
  };
  u();
  let { keyframes: d, duration: f = 300, ease: p, times: m } = o;
  if (BD(t, o)) {
    const x = hl({
      ...o,
      repeat: 0,
      delay: 0
    });
    let S = { done: !1, value: d[0] };
    const C = [];
    let w = 0;
    for (; !S.done && w < MD; )
      S = x.sample(w), C.push(S.value), w += oc;
    m = void 0, d = C, f = w - oc, p = "linear";
  }
  const h = YF(e.owner.current, t, d, {
    ...o,
    duration: f,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: p,
    times: m
  }), g = () => {
    l = !1, h.cancel();
  }, v = () => {
    l = !0, ht.update(g), a(), u();
  };
  return h.onfinish = () => {
    l || (e.set(ZF(d, o)), r && r(), v());
  }, {
    then(x, S) {
      return c.then(x, S);
    },
    attachTimeline(x) {
      return h.timeline = x, h.onfinish = null, Tt;
    },
    get time() {
      return Dr(h.currentTime || 0);
    },
    set time(x) {
      h.currentTime = to(x);
    },
    get speed() {
      return h.playbackRate;
    },
    set speed(x) {
      h.playbackRate = x;
    },
    get duration() {
      return Dr(f);
    },
    play: () => {
      s || (h.play(), zr(g));
    },
    pause: () => h.pause(),
    stop: () => {
      if (s = !0, h.playState === "idle")
        return;
      const { currentTime: x } = h;
      if (x) {
        const S = hl({
          ...o,
          autoplay: !1
        });
        e.setWithVelocity(S.sample(x - oc).value, S.sample(x).value, oc);
      }
      v();
    },
    complete: () => {
      l || h.finish();
    },
    cancel: v
  };
}
function DD({ keyframes: e, delay: t, onUpdate: n, onComplete: r }) {
  const o = () => (n && n(e[e.length - 1]), r && r(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: Tt,
    pause: Tt,
    stop: Tt,
    then: (i) => (i(), Promise.resolve()),
    cancel: Tt,
    complete: Tt
  });
  return t ? hl({
    keyframes: [0, 1],
    duration: 0,
    delay: t,
    onComplete: o
  }) : o();
}
const $D = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, VD = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), LD = {
  type: "keyframes",
  duration: 0.8
}, zD = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, GD = (e, { keyframes: t }) => t.length > 2 ? LD : jo.has(e) ? e.startsWith("scale") ? VD(t[1]) : $D : zD, Jf = (e, t) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(oo.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url(")), WD = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function HD(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(su) || [];
  if (!r)
    return e;
  const o = n.replace(r, "");
  let i = WD.has(t) ? 1 : 0;
  return r !== n && (i *= 100), t + "(" + i + o + ")";
}
const jD = /([a-z-]*)\(.*?\)/g, Kf = {
  ...oo,
  getAnimatableNone: (e) => {
    const t = e.match(jD);
    return t ? t.map(HD).join(" ") : e;
  }
}, XD = {
  ...U1,
  // Color props
  color: rn,
  backgroundColor: rn,
  outlineColor: rn,
  fill: rn,
  stroke: rn,
  // Border props
  borderColor: rn,
  borderTopColor: rn,
  borderRightColor: rn,
  borderBottomColor: rn,
  borderLeftColor: rn,
  filter: Kf,
  WebkitFilter: Kf
}, $h = (e) => XD[e];
function FS(e, t) {
  let n = $h(e);
  return n !== Kf && (n = oo), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const DS = (e) => /^0[^.\s]+$/.test(e);
function YD(e) {
  if (typeof e == "number")
    return e === 0;
  if (e !== null)
    return e === "none" || e === "0" || DS(e);
}
function ZD(e, t, n, r) {
  const o = Jf(t, n);
  let i;
  Array.isArray(n) ? i = [...n] : i = [null, n];
  const s = r.from !== void 0 ? r.from : e.get();
  let a;
  const c = [];
  for (let l = 0; l < i.length; l++)
    i[l] === null && (i[l] = l === 0 ? s : i[l - 1]), YD(i[l]) && c.push(l), typeof i[l] == "string" && i[l] !== "none" && i[l] !== "0" && (a = i[l]);
  if (o && c.length && a)
    for (let l = 0; l < c.length; l++) {
      const u = c[l];
      i[u] = FS(t, a);
    }
  return i;
}
function UD({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: o, repeat: i, repeatType: s, repeatDelay: a, from: c, elapsed: l, ...u }) {
  return !!Object.keys(u).length;
}
function Vh(e, t) {
  return e[t] || e.default || e;
}
const JD = {
  skipAnimations: !1
}, Lh = (e, t, n, r = {}) => (o) => {
  const i = Vh(r, e) || {}, s = i.delay || r.delay || 0;
  let { elapsed: a = 0 } = r;
  a = a - to(s);
  const c = ZD(t, e, n, i), l = c[0], u = c[c.length - 1], d = Jf(e, l), f = Jf(e, u);
  Ra(d === f, `You are trying to animate ${e} from "${l}" to "${u}". ${l} is not an animatable value - to enable this animation set ${l} to a value animatable to ${u} via the \`style\` property.`);
  let p = {
    keyframes: c,
    velocity: t.getVelocity(),
    ease: "easeOut",
    ...i,
    delay: -a,
    onUpdate: (m) => {
      t.set(m), i.onUpdate && i.onUpdate(m);
    },
    onComplete: () => {
      o(), i.onComplete && i.onComplete();
    }
  };
  if (UD(i) || (p = {
    ...p,
    ...GD(e, p)
  }), p.duration && (p.duration = to(p.duration)), p.repeatDelay && (p.repeatDelay = to(p.repeatDelay)), !d || !f || XF.current || i.type === !1 || JD.skipAnimations)
    return DD(p);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !r.isHandoff && t.owner && t.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !t.owner.getProps().onUpdate
  ) {
    const m = FD(t, e, p);
    if (m)
      return m;
  }
  return hl(p);
};
function ml(e) {
  return !!(gn(e) && e.add);
}
const $S = (e) => /^\-?\d*\.?\d+$/.test(e);
function zh(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Gh(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class Wh {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return zh(this.subscriptions, t), () => Gh(this.subscriptions, t);
  }
  notify(t, n, r) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let i = 0; i < o; i++) {
          const s = this.subscriptions[i];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Pb = /* @__PURE__ */ new Set();
function Hh(e, t, n) {
  e || Pb.has(t) || (console.warn(t), Pb.add(t));
}
const KD = (e) => !isNaN(parseFloat(e));
class qD {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(t, n = {}) {
    this.version = "10.18.0", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (r, o = !0) => {
      this.prev = this.current, this.current = r;
      const { delta: i, timestamp: s } = en;
      this.lastUpdated !== s && (this.timeDelta = i, this.lastUpdated = s, ht.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), o && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => ht.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: r }) => {
      r !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = t, this.canTrackVelocity = KD(this.current), this.owner = n.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return process.env.NODE_ENV !== "production" && Hh(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Wh());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), ht.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = t, this.timeDelta = r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t) {
    this.updateAndNotify(t), this.prev = t, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      NS(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Zi(e, t) {
  return new qD(e, t);
}
const VS = (e) => (t) => t.test(e), QD = {
  test: (e) => e === "auto",
  parse: (e) => e
}, LS = [Xo, Me, mr, Jr, cF, aF, QD], bs = (e) => LS.find(VS(e)), e$ = [...LS, rn, oo], t$ = (e) => e$.find(VS(e));
function n$(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Zi(n));
}
function r$(e, t) {
  const n = cu(e, t);
  let { transitionEnd: r = {}, transition: o = {}, ...i } = n ? e.makeTargetAnimatable(n, !1) : {};
  i = { ...i, ...r };
  for (const s in i) {
    const a = CF(i[s]);
    n$(e, s, a);
  }
}
function o$(e, t, n) {
  var r, o;
  const i = Object.keys(t).filter((a) => !e.hasValue(a)), s = i.length;
  if (s)
    for (let a = 0; a < s; a++) {
      const c = i[a], l = t[c];
      let u = null;
      Array.isArray(l) && (u = l[0]), u === null && (u = (o = (r = n[c]) !== null && r !== void 0 ? r : e.readValue(c)) !== null && o !== void 0 ? o : t[c]), u != null && (typeof u == "string" && ($S(u) || DS(u)) ? u = parseFloat(u) : !t$(u) && oo.test(l) && (u = FS(c, l)), e.addValue(c, Zi(u, { owner: e })), n[c] === void 0 && (n[c] = u), u !== null && e.setBaseTarget(c, u));
    }
}
function i$(e, t) {
  return t ? (t[e] || t.default || t).from : void 0;
}
function s$(e, t, n) {
  const r = {};
  for (const o in e) {
    const i = i$(o, t);
    if (i !== void 0)
      r[o] = i;
    else {
      const s = n.getValue(o);
      s && (r[o] = s.get());
    }
  }
  return r;
}
function a$({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function c$(e, t) {
  const n = e.get();
  if (Array.isArray(t)) {
    for (let r = 0; r < t.length; r++)
      if (t[r] !== n)
        return !0;
  } else
    return n !== t;
}
function zS(e, t, { delay: n = 0, transitionOverride: r, type: o } = {}) {
  let { transition: i = e.getDefaultTransition(), transitionEnd: s, ...a } = e.makeTargetAnimatable(t);
  const c = e.getValue("willChange");
  r && (i = r);
  const l = [], u = o && e.animationState && e.animationState.getState()[o];
  for (const d in a) {
    const f = e.getValue(d), p = a[d];
    if (!f || p === void 0 || u && a$(u, d))
      continue;
    const m = {
      delay: n,
      elapsed: 0,
      ...Vh(i || {}, d)
    };
    if (window.HandoffAppearAnimations) {
      const v = e.getProps()[G1];
      if (v) {
        const y = window.HandoffAppearAnimations(v, d, f, ht);
        y !== null && (m.elapsed = y, m.isHandoff = !0);
      }
    }
    let h = !m.isHandoff && !c$(f, p);
    if (m.type === "spring" && (f.getVelocity() || m.velocity) && (h = !1), f.animation && (h = !1), h)
      continue;
    f.start(Lh(d, f, p, e.shouldReduceMotion && jo.has(d) ? { type: !1 } : m));
    const g = f.animation;
    ml(c) && (c.add(d), g.then(() => c.remove(d))), l.push(g);
  }
  return s && Promise.all(l).then(() => {
    s && r$(e, s);
  }), l;
}
function qf(e, t, n = {}) {
  const r = cu(e, t, n.custom);
  let { transition: o = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (o = n.transitionOverride);
  const i = r ? () => Promise.all(zS(e, r, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: l = 0, staggerChildren: u, staggerDirection: d } = o;
    return l$(e, t, l + c, u, d, n);
  } : () => Promise.resolve(), { when: a } = o;
  if (a) {
    const [c, l] = a === "beforeChildren" ? [i, s] : [s, i];
    return c().then(() => l());
  } else
    return Promise.all([i(), s(n.delay)]);
}
function l$(e, t, n = 0, r = 0, o = 1, i) {
  const s = [], a = (e.variantChildren.size - 1) * r, c = o === 1 ? (l = 0) => l * r : (l = 0) => a - l * r;
  return Array.from(e.variantChildren).sort(u$).forEach((l, u) => {
    l.notify("AnimationStart", t), s.push(qf(l, t, {
      ...i,
      delay: n + c(u)
    }).then(() => l.notify("AnimationComplete", t)));
  }), Promise.all(s);
}
function u$(e, t) {
  return e.sortNodePosition(t);
}
function d$(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const o = t.map((i) => qf(e, i, n));
    r = Promise.all(o);
  } else if (typeof t == "string")
    r = qf(e, t, n);
  else {
    const o = typeof t == "function" ? cu(e, t, n.custom) : t;
    r = Promise.all(zS(e, o, n));
  }
  return r.then(() => e.notify("AnimationComplete", t));
}
const f$ = [...Ph].reverse(), p$ = Ph.length;
function h$(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => d$(e, n, r)));
}
function m$(e) {
  let t = h$(e);
  const n = b$();
  let r = !0;
  const o = (c, l) => {
    const u = cu(e, l);
    if (u) {
      const { transition: d, transitionEnd: f, ...p } = u;
      c = { ...c, ...p, ...f };
    }
    return c;
  };
  function i(c) {
    t = c(e);
  }
  function s(c, l) {
    const u = e.getProps(), d = e.getVariantContext(!0) || {}, f = [], p = /* @__PURE__ */ new Set();
    let m = {}, h = 1 / 0;
    for (let v = 0; v < p$; v++) {
      const y = f$[v], x = n[y], S = u[y] !== void 0 ? u[y] : d[y], C = oa(S), w = y === l ? x.isActive : null;
      w === !1 && (h = v);
      let I = S === d[y] && S !== u[y] && C;
      if (I && r && e.manuallyAnimateOnMount && (I = !1), x.protectedKeys = { ...m }, // If it isn't active and hasn't *just* been set as inactive
      !x.isActive && w === null || // If we didn't and don't have any defined prop for this animation type
      !S && !x.prevProp || // Or if the prop doesn't define an animation
      ou(S) || typeof S == "boolean")
        continue;
      let k = g$(x.prevProp, S) || // If we're making this variant active, we want to always make it active
      y === l && x.isActive && !I && C || // If we removed a higher-priority variant (i is in reverse order)
      v > h && C, A = !1;
      const N = Array.isArray(S) ? S : [S];
      let B = N.reduce(o, {});
      w === !1 && (B = {});
      const { prevResolvedValues: L = {} } = x, Z = {
        ...L,
        ...B
      }, ne = (W) => {
        k = !0, p.has(W) && (A = !0, p.delete(W)), x.needsAnimating[W] = !0;
      };
      for (const W in Z) {
        const O = B[W], J = L[W];
        if (m.hasOwnProperty(W))
          continue;
        let ee = !1;
        dl(O) && dl(J) ? ee = !uS(O, J) : ee = O !== J, ee ? O !== void 0 ? ne(W) : p.add(W) : O !== void 0 && p.has(W) ? ne(W) : x.protectedKeys[W] = !0;
      }
      x.prevProp = S, x.prevResolvedValues = B, x.isActive && (m = { ...m, ...B }), r && e.blockInitialAnimation && (k = !1), k && (!I || A) && f.push(...N.map((W) => ({
        animation: W,
        options: { type: y, ...c }
      })));
    }
    if (p.size) {
      const v = {};
      p.forEach((y) => {
        const x = e.getBaseTarget(y);
        x !== void 0 && (v[y] = x);
      }), f.push({ animation: v });
    }
    let g = !!f.length;
    return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (g = !1), r = !1, g ? t(f) : Promise.resolve();
  }
  function a(c, l, u) {
    var d;
    if (n[c].isActive === l)
      return Promise.resolve();
    (d = e.variantChildren) === null || d === void 0 || d.forEach((p) => {
      var m;
      return (m = p.animationState) === null || m === void 0 ? void 0 : m.setActive(c, l);
    }), n[c].isActive = l;
    const f = s(u, c);
    for (const p in n)
      n[p].protectedKeys = {};
    return f;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: i,
    getState: () => n
  };
}
function g$(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !uS(t, e) : !1;
}
function bo(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function b$() {
  return {
    animate: bo(!0),
    whileInView: bo(),
    whileHover: bo(),
    whileTap: bo(),
    whileDrag: bo(),
    whileFocus: bo(),
    exit: bo()
  };
}
class v$ extends lo {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = m$(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    this.unmount(), ou(t) && (this.unmount = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let y$ = 0;
class S$ extends lo {
  constructor() {
    super(...arguments), this.id = y$++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n, custom: r } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === o)
      return;
    const i = this.node.animationState.setActive("exit", !t, { custom: r ?? this.node.getProps().custom });
    n && !t && i.then(() => n(this.id));
  }
  mount() {
    const { register: t } = this.node.presenceContext || {};
    t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const x$ = {
  animation: {
    Feature: v$
  },
  exit: {
    Feature: S$
  }
}, kb = (e, t) => Math.abs(e - t);
function C$(e, t) {
  const n = kb(e.x, t.x), r = kb(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class GS {
  constructor(t, n, { transformPagePoint: r, contextWindow: o, dragSnapToOrigin: i = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = Dd(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, p = C$(d.offset, { x: 0, y: 0 }) >= 3;
      if (!f && !p)
        return;
      const { point: m } = d, { timestamp: h } = en;
      this.history.push({ ...m, timestamp: h });
      const { onStart: g, onMove: v } = this.handlers;
      f || (g && g(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), v && v(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, f) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = Fd(f, this.transformPagePoint), ht.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, f) => {
      this.end();
      const { onEnd: p, onSessionEnd: m, resumeAnimation: h } = this.handlers;
      if (this.dragSnapToOrigin && h && h(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = Dd(d.type === "pointercancel" ? this.lastMoveEventInfo : Fd(f, this.transformPagePoint), this.history);
      this.startEvent && p && p(d, g), m && m(d, g);
    }, !iS(t))
      return;
    this.dragSnapToOrigin = i, this.handlers = n, this.transformPagePoint = r, this.contextWindow = o || window;
    const s = au(t), a = Fd(s, this.transformPagePoint), { point: c } = a, { timestamp: l } = en;
    this.history = [{ ...c, timestamp: l }];
    const { onSessionStart: u } = n;
    u && u(t, Dd(a, this.history)), this.removeListeners = eo(Fr(this.contextWindow, "pointermove", this.handlePointerMove), Fr(this.contextWindow, "pointerup", this.handlePointerUp), Fr(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), zr(this.updatePoint);
  }
}
function Fd(e, t) {
  return t ? { point: t(e.point) } : e;
}
function Ab(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Dd({ point: e }, t) {
  return {
    point: e,
    delta: Ab(e, WS(t)),
    offset: Ab(e, I$(t)),
    velocity: w$(t, 0.1)
  };
}
function I$(e) {
  return e[0];
}
function WS(e) {
  return e[e.length - 1];
}
function w$(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const o = WS(e);
  for (; n >= 0 && (r = e[n], !(o.timestamp - r.timestamp > to(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const i = Dr(o.timestamp - r.timestamp);
  if (i === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (o.x - r.x) / i,
    y: (o.y - r.y) / i
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function Pn(e) {
  return e.max - e.min;
}
function Qf(e, t = 0, n = 0.01) {
  return Math.abs(e - t) <= n;
}
function Tb(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = xt(t.min, t.max, e.origin), e.scale = Pn(n) / Pn(t), (Qf(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1), e.translate = xt(n.min, n.max, e.origin) - e.originPoint, (Qf(e.translate) || isNaN(e.translate)) && (e.translate = 0);
}
function Xs(e, t, n, r) {
  Tb(e.x, t.x, n.x, r ? r.originX : void 0), Tb(e.y, t.y, n.y, r ? r.originY : void 0);
}
function Eb(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Pn(t);
}
function P$(e, t, n) {
  Eb(e.x, t.x, n.x), Eb(e.y, t.y, n.y);
}
function Rb(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Pn(t);
}
function Ys(e, t, n) {
  Rb(e.x, t.x, n.x), Rb(e.y, t.y, n.y);
}
function k$(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? xt(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? xt(n, e, r.max) : Math.min(e, n)), e;
}
function _b(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function A$(e, { top: t, left: n, bottom: r, right: o }) {
  return {
    x: _b(e.x, n, o),
    y: _b(e.y, t, r)
  };
}
function Ob(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function T$(e, t) {
  return {
    x: Ob(e.x, t.x),
    y: Ob(e.y, t.y)
  };
}
function E$(e, t) {
  let n = 0.5;
  const r = Pn(e), o = Pn(t);
  return o > r ? n = sa(t.min, t.max - r, e.min) : r > o && (n = sa(e.min, e.max - o, t.min)), ro(0, 1, n);
}
function R$(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const ep = 0.35;
function _$(e = ep) {
  return e === !1 ? e = 0 : e === !0 && (e = ep), {
    x: Nb(e, "left", "right"),
    y: Nb(e, "top", "bottom")
  };
}
function Nb(e, t, n) {
  return {
    min: Mb(e, t),
    max: Mb(e, n)
  };
}
function Mb(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const Bb = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Ii = () => ({
  x: Bb(),
  y: Bb()
}), Fb = () => ({ min: 0, max: 0 }), Bt = () => ({
  x: Fb(),
  y: Fb()
});
function Bn(e) {
  return [e("x"), e("y")];
}
function HS({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function O$({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function N$(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function $d(e) {
  return e === void 0 || e === 1;
}
function tp({ scale: e, scaleX: t, scaleY: n }) {
  return !$d(e) || !$d(t) || !$d(n);
}
function yo(e) {
  return tp(e) || jS(e) || e.z || e.rotate || e.rotateX || e.rotateY;
}
function jS(e) {
  return Db(e.x) || Db(e.y);
}
function Db(e) {
  return e && e !== "0%";
}
function gl(e, t, n) {
  const r = e - n, o = t * r;
  return n + o;
}
function $b(e, t, n, r, o) {
  return o !== void 0 && (e = gl(e, o, r)), gl(e, n, r) + t;
}
function np(e, t = 0, n = 1, r, o) {
  e.min = $b(e.min, t, n, r, o), e.max = $b(e.max, t, n, r, o);
}
function XS(e, { x: t, y: n }) {
  np(e.x, t.translate, t.scale, t.originPoint), np(e.y, n.translate, n.scale, n.originPoint);
}
function M$(e, t, n, r = !1) {
  const o = n.length;
  if (!o)
    return;
  t.x = t.y = 1;
  let i, s;
  for (let a = 0; a < o; a++) {
    i = n[a], s = i.projectionDelta;
    const c = i.instance;
    c && c.style && c.style.display === "contents" || (r && i.options.layoutScroll && i.scroll && i !== i.root && wi(e, {
      x: -i.scroll.offset.x,
      y: -i.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, XS(e, s)), r && yo(i.latestValues) && wi(e, i.latestValues));
  }
  t.x = Vb(t.x), t.y = Vb(t.y);
}
function Vb(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999 ? e : 1;
}
function Kr(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function Lb(e, t, [n, r, o]) {
  const i = t[o] !== void 0 ? t[o] : 0.5, s = xt(e.min, e.max, i);
  np(e, t[n], t[r], s, t.scale);
}
const B$ = ["x", "scaleX", "originX"], F$ = ["y", "scaleY", "originY"];
function wi(e, t) {
  Lb(e.x, t, B$), Lb(e.y, t, F$);
}
function YS(e, t) {
  return HS(N$(e.getBoundingClientRect(), t));
}
function D$(e, t, n) {
  const r = YS(e, n), { scroll: o } = t;
  return o && (Kr(r.x, o.offset.x), Kr(r.y, o.offset.y)), r;
}
const ZS = ({ current: e }) => e ? e.ownerDocument.defaultView : null, $$ = /* @__PURE__ */ new WeakMap();
class V$ {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Bt(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const o = (u) => {
      const { dragSnapToOrigin: d } = this.getProps();
      d ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(au(u, "page").point);
    }, i = (u, d) => {
      const { drag: f, dragPropagation: p, onDragStart: m } = this.getProps();
      if (f && !p && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = aS(f), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Bn((g) => {
        let v = this.getAxisMotionValue(g).get() || 0;
        if (mr.test(v)) {
          const { projection: y } = this.visualElement;
          if (y && y.layout) {
            const x = y.layout.layoutBox[g];
            x && (v = Pn(x) * (parseFloat(v) / 100));
          }
        }
        this.originPoint[g] = v;
      }), m && ht.update(() => m(u, d), !1, !0);
      const { animationState: h } = this.visualElement;
      h && h.setActive("whileDrag", !0);
    }, s = (u, d) => {
      const { dragPropagation: f, dragDirectionLock: p, onDirectionLock: m, onDrag: h } = this.getProps();
      if (!f && !this.openGlobalLock)
        return;
      const { offset: g } = d;
      if (p && this.currentDirection === null) {
        this.currentDirection = L$(g), this.currentDirection !== null && m && m(this.currentDirection);
        return;
      }
      this.updateAxis("x", d.point, g), this.updateAxis("y", d.point, g), this.visualElement.render(), h && h(u, d);
    }, a = (u, d) => this.stop(u, d), c = () => Bn((u) => {
      var d;
      return this.getAnimationState(u) === "paused" && ((d = this.getAxisMotionValue(u).animation) === null || d === void 0 ? void 0 : d.play());
    }), { dragSnapToOrigin: l } = this.getProps();
    this.panSession = new GS(t, {
      onSessionStart: o,
      onStart: i,
      onMove: s,
      onSessionEnd: a,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: l,
      contextWindow: ZS(this.visualElement)
    });
  }
  stop(t, n) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: o } = n;
    this.startAnimation(o);
    const { onDragEnd: i } = this.getProps();
    i && ht.update(() => i(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(t, n, r) {
    const { drag: o } = this.getProps();
    if (!r || !ic(t, o, this.currentDirection))
      return;
    const i = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = k$(s, this.constraints[t], this.elastic[t])), i.set(s);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: r } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, i = this.constraints;
    n && xi(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && o ? this.constraints = A$(o.layoutBox, n) : this.constraints = !1, this.elastic = _$(r), i !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && Bn((s) => {
      this.getAxisMotionValue(s) && (this.constraints[s] = R$(o.layoutBox[s], this.constraints[s]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !xi(t))
      return !1;
    const r = t.current;
    Vn(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const i = D$(r, o.root, this.visualElement.getTransformPagePoint());
    let s = T$(o.layout.layoutBox, i);
    if (n) {
      const a = n(O$(s));
      this.hasMutatedConstraints = !!a, a && (s = HS(a));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: o, dragTransition: i, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, l = Bn((u) => {
      if (!ic(u, n, this.currentDirection))
        return;
      let d = c && c[u] || {};
      s && (d = { min: 0, max: 0 });
      const f = o ? 200 : 1e6, p = o ? 40 : 1e7, m = {
        type: "inertia",
        velocity: r ? t[u] : 0,
        bounceStiffness: f,
        bounceDamping: p,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...i,
        ...d
      };
      return this.startAxisValueAnimation(u, m);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return r.start(Lh(t, r, 0, n));
  }
  stopAnimation() {
    Bn((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Bn((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0 ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = "_drag" + t.toUpperCase(), r = this.visualElement.getProps(), o = r[n];
    return o || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Bn((n) => {
      const { drag: r } = this.getProps();
      if (!ic(n, r, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, i = this.getAxisMotionValue(n);
      if (o && o.layout) {
        const { min: s, max: a } = o.layout.layoutBox[n];
        i.set(t[n] - xt(s, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!xi(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    Bn((s) => {
      const a = this.getAxisMotionValue(s);
      if (a) {
        const c = a.get();
        o[s] = E$({ min: c, max: c }, this.constraints[s]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    this.visualElement.current.style.transform = i ? i({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Bn((s) => {
      if (!ic(s, t, null))
        return;
      const a = this.getAxisMotionValue(s), { min: c, max: l } = this.constraints[s];
      a.set(xt(c, l, o[s]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    $$.set(this.visualElement, this);
    const t = this.visualElement.current, n = Fr(t, "pointerdown", (c) => {
      const { drag: l, dragListener: u = !0 } = this.getProps();
      l && u && this.start(c);
    }), r = () => {
      const { dragConstraints: c } = this.getProps();
      xi(c) && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, i = o.addEventListener("measure", r);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), r();
    const s = Mr(window, "resize", () => this.scalePositionWithinConstraints()), a = o.addEventListener("didUpdate", (({ delta: c, hasLayoutChanged: l }) => {
      this.isDragging && l && (Bn((u) => {
        const d = this.getAxisMotionValue(u);
        d && (this.originPoint[u] += c[u].translate, d.set(d.get() + c[u].translate));
      }), this.visualElement.render());
    }));
    return () => {
      s(), n(), i(), a && a();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: o = !1, dragConstraints: i = !1, dragElastic: s = ep, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: o,
      dragConstraints: i,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function ic(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function L$(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class z$ extends lo {
  constructor(t) {
    super(t), this.removeGroupControls = Tt, this.removeListeners = Tt, this.controls = new V$(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Tt;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const zb = (e) => (t, n) => {
  e && ht.update(() => e(t, n));
};
class G$ extends lo {
  constructor() {
    super(...arguments), this.removePointerDownListener = Tt;
  }
  onPointerDown(t) {
    this.session = new GS(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: ZS(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: zb(t),
      onStart: zb(n),
      onMove: r,
      onEnd: (i, s) => {
        delete this.session, o && ht.update(() => o(i, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Fr(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function US() {
  const e = at(ka);
  if (e === null)
    return [!0, null];
  const { isPresent: t, onExitComplete: n, register: r } = e, o = Xt();
  return ge(() => r(o), []), !t && n ? [!1, () => n && n(o)] : [!0];
}
function W$() {
  return H$(at(ka));
}
function H$(e) {
  return e === null ? !0 : e.isPresent;
}
const Lc = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Gb(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const vs = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (Me.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = Gb(e, t.target.x), r = Gb(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, j$ = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, o = oo.parse(e);
    if (o.length > 5)
      return r;
    const i = oo.createTransformer(e), s = typeof o[0] != "number" ? 1 : 0, a = n.x.scale * t.x, c = n.y.scale * t.y;
    o[0 + s] /= a, o[1 + s] /= c;
    const l = xt(a, c, 0.5);
    return typeof o[2 + s] == "number" && (o[2 + s] /= l), typeof o[3 + s] == "number" && (o[3 + s] /= l), i(o);
  }
};
class X$ extends At.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: o } = this.props, { projection: i } = t;
    eF(Y$), i && (n.group && n.group.add(i), r && r.register && o && r.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), i.setOptions({
      ...i.options,
      onExitComplete: () => this.safeToRemove()
    })), Lc.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: o, isPresent: i } = this.props, s = r.projection;
    return s && (s.isPresent = i, o || t.layoutDependency !== n || n === void 0 ? s.willUpdate() : this.safeToRemove(), t.isPresent !== i && (i ? s.promote() : s.relegate() || ht.postRender(() => {
      const a = s.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), queueMicrotask(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: o } = t;
    o && (o.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(o), r && r.deregister && r.deregister(o));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function JS(e) {
  const [t, n] = US(), r = at(Ah);
  return At.createElement(X$, { ...e, layoutGroup: r, switchLayoutGroup: at(H1), isPresent: t, safeToRemove: n });
}
const Y$ = {
  borderRadius: {
    ...vs,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: vs,
  borderTopRightRadius: vs,
  borderBottomLeftRadius: vs,
  borderBottomRightRadius: vs,
  boxShadow: j$
}, KS = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Z$ = KS.length, Wb = (e) => typeof e == "string" ? parseFloat(e) : e, Hb = (e) => typeof e == "number" || Me.test(e);
function U$(e, t, n, r, o, i) {
  o ? (e.opacity = xt(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    J$(r)
  ), e.opacityExit = xt(t.opacity !== void 0 ? t.opacity : 1, 0, K$(r))) : i && (e.opacity = xt(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let s = 0; s < Z$; s++) {
    const a = `border${KS[s]}Radius`;
    let c = jb(t, a), l = jb(n, a);
    if (c === void 0 && l === void 0)
      continue;
    c || (c = 0), l || (l = 0), c === 0 || l === 0 || Hb(c) === Hb(l) ? (e[a] = Math.max(xt(Wb(c), Wb(l), r), 0), (mr.test(l) || mr.test(c)) && (e[a] += "%")) : e[a] = l;
  }
  (t.rotate || n.rotate) && (e.rotate = xt(t.rotate || 0, n.rotate || 0, r));
}
function jb(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const J$ = qS(0, 0.5, yS), K$ = qS(0.5, 0.95, Tt);
function qS(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(sa(e, t, r));
}
function Xb(e, t) {
  e.min = t.min, e.max = t.max;
}
function On(e, t) {
  Xb(e.x, t.x), Xb(e.y, t.y);
}
function Yb(e, t, n, r, o) {
  return e -= t, e = gl(e, 1 / n, r), o !== void 0 && (e = gl(e, 1 / o, r)), e;
}
function q$(e, t = 0, n = 1, r = 0.5, o, i = e, s = e) {
  if (mr.test(t) && (t = parseFloat(t), t = xt(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let a = xt(i.min, i.max, r);
  e === i && (a -= t), e.min = Yb(e.min, t, n, a, o), e.max = Yb(e.max, t, n, a, o);
}
function Zb(e, t, [n, r, o], i, s) {
  q$(e, t[n], t[r], t[o], t.scale, i, s);
}
const Q$ = ["x", "scaleX", "originX"], eV = ["y", "scaleY", "originY"];
function Ub(e, t, n, r) {
  Zb(e.x, t, Q$, n ? n.x : void 0, r ? r.x : void 0), Zb(e.y, t, eV, n ? n.y : void 0, r ? r.y : void 0);
}
function Jb(e) {
  return e.translate === 0 && e.scale === 1;
}
function QS(e) {
  return Jb(e.x) && Jb(e.y);
}
function tV(e, t) {
  return e.x.min === t.x.min && e.x.max === t.x.max && e.y.min === t.y.min && e.y.max === t.y.max;
}
function ex(e, t) {
  return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max);
}
function Kb(e) {
  return Pn(e.x) / Pn(e.y);
}
class nV {
  constructor() {
    this.members = [];
  }
  add(t) {
    zh(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Gh(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((o) => t === o);
    if (n === 0)
      return !1;
    let r;
    for (let o = n; o >= 0; o--) {
      const i = this.members[o];
      if (i.isPresent !== !1) {
        r = i;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: o } = t.options;
      o === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function qb(e, t, n) {
  let r = "";
  const o = e.x.translate / t.x, i = e.y.translate / t.y;
  if ((o || i) && (r = `translate3d(${o}px, ${i}px, 0) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { rotate: c, rotateX: l, rotateY: u } = n;
    c && (r += `rotate(${c}deg) `), l && (r += `rotateX(${l}deg) `), u && (r += `rotateY(${u}deg) `);
  }
  const s = e.x.scale * t.x, a = e.y.scale * t.y;
  return (s !== 1 || a !== 1) && (r += `scale(${s}, ${a})`), r || "none";
}
const rV = (e, t) => e.depth - t.depth;
class oV {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    zh(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Gh(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(rV), this.isDirty = !1, this.children.forEach(t);
  }
}
function iV(e, t) {
  const n = performance.now(), r = ({ timestamp: o }) => {
    const i = o - n;
    i >= t && (zr(r), e(i - t));
  };
  return ht.read(r, !0), () => zr(r);
}
function sV(e) {
  window.MotionDebug && window.MotionDebug.record(e);
}
function aV(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
function cV(e, t, n) {
  const r = gn(e) ? e : Zi(e);
  return r.start(Lh("", r, t, n)), r.animation;
}
const Qb = ["", "X", "Y", "Z"], lV = { visibility: "hidden" }, ev = 1e3;
let uV = 0;
const So = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function tx({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: o }) {
  return class {
    constructor(s = {}, a = t?.()) {
      this.id = uV++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, So.totalNodes = So.resolvedTargetDeltas = So.recalculatedProjection = 0, this.nodes.forEach(pV), this.nodes.forEach(vV), this.nodes.forEach(yV), this.nodes.forEach(hV), sV(So);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new oV());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new Wh()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const c = this.eventHandlers.get(s);
      c && c.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = aV(s), this.instance = s;
      const { layoutId: c, layout: l, visualElement: u } = this.options;
      if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l || c) && (this.isLayoutDirty = !0), e) {
        let d;
        const f = () => this.root.updateBlockedByResize = !1;
        e(s, () => {
          this.root.updateBlockedByResize = !0, d && d(), d = iV(f, 250), Lc.hasAnimatedSinceResize && (Lc.hasAnimatedSinceResize = !1, this.nodes.forEach(nv));
        });
      }
      c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && u && (c || l) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: f, hasRelativeTargetChanged: p, layout: m }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const h = this.options.transition || u.getDefaultTransition() || wV, { onLayoutAnimationStart: g, onLayoutAnimationComplete: v } = u.getProps(), y = !this.targetLayout || !ex(this.targetLayout, m) || p, x = !f && p;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || x || f && (y || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, x);
          const S = {
            ...Vh(h, "layout"),
            onPlay: g,
            onComplete: v
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (S.delay = 0, S.type = !1), this.startAnimation(S);
        } else
          f || nv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = m;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, zr(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(SV), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: c } = this.options;
      if (a === void 0 && !c)
        return;
      const l = this.getTransformTemplate();
      this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(tv);
        return;
      }
      this.isUpdating || this.nodes.forEach(gV), this.isUpdating = !1, this.nodes.forEach(bV), this.nodes.forEach(dV), this.nodes.forEach(fV), this.clearAllSnapshots();
      const a = performance.now();
      en.delta = ro(0, 1e3 / 60, a - en.timestamp), en.timestamp = a, en.isProcessing = !0, Td.update.process(en), Td.preRender.process(en), Td.render.process(en), en.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(mV), this.sharedNodes.forEach(xV);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ht.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      ht.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Bt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && (this.scroll = {
        animationId: this.root.animationId,
        phase: s,
        isRoot: r(this.instance),
        offset: n(this.instance)
      });
    }
    resetTransform() {
      if (!o)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !QS(this.projectionDelta), c = this.getTransformTemplate(), l = c ? c(this.latestValues, "") : void 0, u = l !== this.prevTransformTemplateValue;
      s && (a || yo(this.latestValues) || u) && (o(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return s && (c = this.removeTransform(c)), PV(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s } = this.options;
      if (!s)
        return Bt();
      const a = s.measureViewportBox(), { scroll: c } = this.root;
      return c && (Kr(a.x, c.offset.x), Kr(a.y, c.offset.y)), a;
    }
    removeElementScroll(s) {
      const a = Bt();
      On(a, s);
      for (let c = 0; c < this.path.length; c++) {
        const l = this.path[c], { scroll: u, options: d } = l;
        if (l !== this.root && u && d.layoutScroll) {
          if (u.isRoot) {
            On(a, s);
            const { scroll: f } = this.root;
            f && (Kr(a.x, -f.offset.x), Kr(a.y, -f.offset.y));
          }
          Kr(a.x, u.offset.x), Kr(a.y, u.offset.y);
        }
      }
      return a;
    }
    applyTransform(s, a = !1) {
      const c = Bt();
      On(c, s);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && wi(c, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), yo(u.latestValues) && wi(c, u.latestValues);
      }
      return yo(this.latestValues) && wi(c, this.latestValues), c;
    }
    removeTransform(s) {
      const a = Bt();
      On(a, s);
      for (let c = 0; c < this.path.length; c++) {
        const l = this.path[c];
        if (!l.instance || !yo(l.latestValues))
          continue;
        tp(l.latestValues) && l.updateSnapshot();
        const u = Bt(), d = l.measurePageBox();
        On(u, d), Ub(a, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, u);
      }
      return yo(this.latestValues) && Ub(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== en.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      var a;
      const c = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== c;
      if (!(s || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: d, layoutId: f } = this.options;
      if (!(!this.layout || !(d || f))) {
        if (this.resolvedRelativeTargetAt = en.timestamp, !this.targetDelta && !this.relativeTarget) {
          const p = this.getClosestProjectingParent();
          p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), Ys(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), On(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = Bt(), this.targetWithTransforms = Bt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), P$(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : On(this.target, this.layout.layoutBox), XS(this.target, this.targetDelta)) : On(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const p = this.getClosestProjectingParent();
            p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Bt(), this.relativeTargetOrigin = Bt(), Ys(this.relativeTargetOrigin, this.target, p.target), On(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          So.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || tp(this.parent.latestValues) || jS(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var s;
      const a = this.getLead(), c = !!this.resumingFrom || this !== a;
      let l = !0;
      if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (l = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === en.timestamp && (l = !1), l)
        return;
      const { layout: u, layoutId: d } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || d))
        return;
      On(this.layoutCorrected, this.layout.layoutBox);
      const f = this.treeScale.x, p = this.treeScale.y;
      M$(this.layoutCorrected, this.treeScale, this.path, c), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox);
      const { target: m } = a;
      if (!m) {
        this.projectionTransform && (this.projectionDelta = Ii(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = Ii(), this.projectionDeltaWithTransform = Ii());
      const h = this.projectionTransform;
      Xs(this.projectionDelta, this.layoutCorrected, m, this.latestValues), this.projectionTransform = qb(this.projectionDelta, this.treeScale), (this.projectionTransform !== h || this.treeScale.x !== f || this.treeScale.y !== p) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m)), So.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), s) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(s, a = !1) {
      const c = this.snapshot, l = c ? c.latestValues : {}, u = { ...this.latestValues }, d = Ii();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const f = Bt(), p = c ? c.source : void 0, m = this.layout ? this.layout.source : void 0, h = p !== m, g = this.getStack(), v = !g || g.members.length <= 1, y = !!(h && !v && this.options.crossfade === !0 && !this.path.some(IV));
      this.animationProgress = 0;
      let x;
      this.mixTargetDelta = (S) => {
        const C = S / 1e3;
        rv(d.x, s.x, C), rv(d.y, s.y, C), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Ys(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), CV(this.relativeTarget, this.relativeTargetOrigin, f, C), x && tV(this.relativeTarget, x) && (this.isProjectionDirty = !1), x || (x = Bt()), On(x, this.relativeTarget)), h && (this.animationValues = u, U$(u, l, this.latestValues, C, y, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (zr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ht.update(() => {
        Lc.hasAnimatedSinceResize = !0, this.currentAnimation = cV(0, ev, {
          ...s,
          onUpdate: (a) => {
            this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(ev), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: c, layout: l, latestValues: u } = s;
      if (!(!a || !c || !l)) {
        if (this !== s && this.layout && l && nx(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          c = this.target || Bt();
          const d = Pn(this.layout.layoutBox.x);
          c.x.min = s.target.x.min, c.x.max = c.x.min + d;
          const f = Pn(this.layout.layoutBox.y);
          c.y.min = s.target.y.min, c.y.max = c.y.min + f;
        }
        On(a, c), wi(a, u), Xs(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new nV()), this.sharedNodes.get(s).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this;
    }
    getPrevLead() {
      var s;
      const { layoutId: a } = this.options;
      return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: c } = {}) {
      const l = this.getStack();
      l && l.promote(this, c), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: c } = s;
      if ((c.rotate || c.rotateX || c.rotateY || c.rotateZ) && (a = !0), !a)
        return;
      const l = {};
      for (let u = 0; u < Qb.length; u++) {
        const d = "rotate" + Qb[u];
        c[d] && (l[d] = c[d], s.setStaticValue(d, 0));
      }
      s.render();
      for (const u in l)
        s.setStaticValue(u, l[u]);
      s.scheduleRender();
    }
    getProjectionStyles(s) {
      var a, c;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return lV;
      const l = {
        visibility: ""
      }, u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = Vc(s?.pointerEvents) || "", l.transform = u ? u(this.latestValues, "") : "none", l;
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const h = {};
        return this.options.layoutId && (h.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, h.pointerEvents = Vc(s?.pointerEvents) || ""), this.hasProjected && !yo(this.latestValues) && (h.transform = u ? u({}, "") : "none", this.hasProjected = !1), h;
      }
      const f = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(), l.transform = qb(this.projectionDeltaWithTransform, this.treeScale, f), u && (l.transform = u(f, l.transform));
      const { x: p, y: m } = this.projectionDelta;
      l.transformOrigin = `${p.origin * 100}% ${m.origin * 100}% 0`, d.animationValues ? l.opacity = d === this ? (c = (a = f.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : l.opacity = d === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const h in ll) {
        if (f[h] === void 0)
          continue;
        const { correct: g, applyTo: v } = ll[h], y = l.transform === "none" ? f[h] : g(f[h], d);
        if (v) {
          const x = v.length;
          for (let S = 0; S < x; S++)
            l[v[S]] = y;
        } else
          l[h] = y;
      }
      return this.options.layoutId && (l.pointerEvents = d === this ? Vc(s?.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => {
        var a;
        return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(tv), this.root.sharedNodes.clear();
    }
  };
}
function dV(e) {
  e.updateLayout();
}
function fV(e) {
  var t;
  const n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: o } = e.layout, { animationType: i } = e.options, s = n.source !== e.layout.source;
    i === "size" ? Bn((d) => {
      const f = s ? n.measuredBox[d] : n.layoutBox[d], p = Pn(f);
      f.min = r[d].min, f.max = f.min + p;
    }) : nx(i, n.layoutBox, r) && Bn((d) => {
      const f = s ? n.measuredBox[d] : n.layoutBox[d], p = Pn(r[d]);
      f.max = f.min + p, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[d].max = e.relativeTarget[d].min + p);
    });
    const a = Ii();
    Xs(a, r, n.layoutBox);
    const c = Ii();
    s ? Xs(c, e.applyTransform(o, !0), n.measuredBox) : Xs(c, r, n.layoutBox);
    const l = !QS(a);
    let u = !1;
    if (!e.resumeFrom) {
      const d = e.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: f, layout: p } = d;
        if (f && p) {
          const m = Bt();
          Ys(m, n.layoutBox, f.layoutBox);
          const h = Bt();
          Ys(h, r, p.layoutBox), ex(m, h) || (u = !0), d.options.layoutRoot && (e.relativeTarget = h, e.relativeTargetOrigin = m, e.relativeParent = d);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: c,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function pV(e) {
  So.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function hV(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function mV(e) {
  e.clearSnapshot();
}
function tv(e) {
  e.clearMeasurements();
}
function gV(e) {
  e.isLayoutDirty = !1;
}
function bV(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function nv(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function vV(e) {
  e.resolveTargetDelta();
}
function yV(e) {
  e.calcProjection();
}
function SV(e) {
  e.resetRotation();
}
function xV(e) {
  e.removeLeadSnapshot();
}
function rv(e, t, n) {
  e.translate = xt(t.translate, 0, n), e.scale = xt(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function ov(e, t, n, r) {
  e.min = xt(t.min, n.min, r), e.max = xt(t.max, n.max, r);
}
function CV(e, t, n, r) {
  ov(e.x, t.x, n.x, r), ov(e.y, t.y, n.y, r);
}
function IV(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const wV = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, iv = (e) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(e), sv = iv("applewebkit/") && !iv("chrome/") ? Math.round : Tt;
function av(e) {
  e.min = sv(e.min), e.max = sv(e.max);
}
function PV(e) {
  av(e.x), av(e.y);
}
function nx(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !Qf(Kb(t), Kb(n), 0.2);
}
const kV = tx({
  attachResizeListener: (e, t) => Mr(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), Vd = {
  current: void 0
}, rx = tx({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Vd.current) {
      const e = new kV({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Vd.current = e;
    }
    return Vd.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), AV = {
  pan: {
    Feature: G$
  },
  drag: {
    Feature: z$,
    ProjectionNode: rx,
    MeasureLayout: JS
  }
}, TV = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function EV(e) {
  const t = TV.exec(e);
  if (!t)
    return [,];
  const [, n, r] = t;
  return [n, r];
}
const RV = 4;
function rp(e, t, n = 1) {
  Vn(n <= RV, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [r, o] = EV(e);
  if (!r)
    return;
  const i = window.getComputedStyle(t).getPropertyValue(r);
  if (i) {
    const s = i.trim();
    return $S(s) ? parseFloat(s) : s;
  } else return Xf(o) ? rp(o, t, n + 1) : o;
}
function _V(e, { ...t }, n) {
  const r = e.current;
  if (!(r instanceof Element))
    return { target: t, transitionEnd: n };
  n && (n = { ...n }), e.values.forEach((o) => {
    const i = o.get();
    if (!Xf(i))
      return;
    const s = rp(i, r);
    s && o.set(s);
  });
  for (const o in t) {
    const i = t[o];
    if (!Xf(i))
      continue;
    const s = rp(i, r);
    s && (t[o] = s, n || (n = {}), n[o] === void 0 && (n[o] = i));
  }
  return { target: t, transitionEnd: n };
}
const OV = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), ox = (e) => OV.has(e), NV = (e) => Object.keys(e).some(ox), sc = (e) => e === Xo || e === Me, cv = (e, t) => parseFloat(e.split(", ")[t]), lv = (e, t) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const o = r.match(/^matrix3d\((.+)\)$/);
  if (o)
    return cv(o[1], t);
  {
    const i = r.match(/^matrix\((.+)\)$/);
    return i ? cv(i[1], e) : 0;
  }
}, MV = /* @__PURE__ */ new Set(["x", "y", "z"]), BV = Aa.filter((e) => !MV.has(e));
function FV(e) {
  const t = [];
  return BV.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t.length && e.render(), t;
}
const Ui = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: lv(4, 13),
  y: lv(5, 14)
};
Ui.translateX = Ui.x;
Ui.translateY = Ui.y;
const DV = (e, t, n) => {
  const r = t.measureViewportBox(), o = t.current, i = getComputedStyle(o), { display: s } = i, a = {};
  s === "none" && t.setStaticValue("display", e.display || "block"), n.forEach((l) => {
    a[l] = Ui[l](r, i);
  }), t.render();
  const c = t.measureViewportBox();
  return n.forEach((l) => {
    const u = t.getValue(l);
    u && u.jump(a[l]), e[l] = Ui[l](c, i);
  }), e;
}, $V = (e, t, n = {}, r = {}) => {
  t = { ...t }, r = { ...r };
  const o = Object.keys(t).filter(ox);
  let i = [], s = !1;
  const a = [];
  if (o.forEach((c) => {
    const l = e.getValue(c);
    if (!e.hasValue(c))
      return;
    let u = n[c], d = bs(u);
    const f = t[c];
    let p;
    if (dl(f)) {
      const m = f.length, h = f[0] === null ? 1 : 0;
      u = f[h], d = bs(u);
      for (let g = h; g < m && f[g] !== null; g++)
        p ? Vn(bs(f[g]) === p, "All keyframes must be of the same type") : (p = bs(f[g]), Vn(p === d || sc(d) && sc(p), "Keyframes must be of the same dimension as the current value"));
    } else
      p = bs(f);
    if (d !== p)
      if (sc(d) && sc(p)) {
        const m = l.get();
        typeof m == "string" && l.set(parseFloat(m)), typeof f == "string" ? t[c] = parseFloat(f) : Array.isArray(f) && p === Me && (t[c] = f.map(parseFloat));
      } else d?.transform && p?.transform && (u === 0 || f === 0) ? u === 0 ? l.set(p.transform(u)) : t[c] = d.transform(f) : (s || (i = FV(e), s = !0), a.push(c), r[c] = r[c] !== void 0 ? r[c] : t[c], l.jump(f));
  }), a.length) {
    const c = a.indexOf("height") >= 0 ? window.pageYOffset : null, l = DV(t, e, a);
    return i.length && i.forEach(([u, d]) => {
      e.getValue(u).set(d);
    }), e.render(), ru && c !== null && window.scrollTo({ top: c }), { target: l, transitionEnd: r };
  } else
    return { target: t, transitionEnd: r };
};
function VV(e, t, n, r) {
  return NV(t) ? $V(e, t, n, r) : { target: t, transitionEnd: r };
}
const LV = (e, t, n, r) => {
  const o = _V(e, t, r);
  return t = o.target, r = o.transitionEnd, VV(e, t, n, r);
}, op = { current: null }, ix = { current: !1 };
function zV() {
  if (ix.current = !0, !!ru)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => op.current = e.matches;
      e.addListener(t), t();
    } else
      op.current = !1;
}
function GV(e, t, n) {
  const { willChange: r } = t;
  for (const o in t) {
    const i = t[o], s = n[o];
    if (gn(i))
      e.addValue(o, i), ml(r) && r.add(o), process.env.NODE_ENV === "development" && Hh(i.version === "10.18.0", `Attempting to mix Framer Motion versions ${i.version} with 10.18.0 may not work as expected.`);
    else if (gn(s))
      e.addValue(o, Zi(i, { owner: e })), ml(r) && r.remove(o);
    else if (s !== i)
      if (e.hasValue(o)) {
        const a = e.getValue(o);
        !a.hasAnimated && a.set(i);
      } else {
        const a = e.getStaticValue(o);
        e.addValue(o, Zi(a !== void 0 ? a : i, { owner: e }));
      }
  }
  for (const o in n)
    t[o] === void 0 && e.removeValue(o);
  return t;
}
const uv = /* @__PURE__ */ new WeakMap(), sx = Object.keys(ia), WV = sx.length, dv = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], HV = kh.length;
class jV {
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: o, visualState: i }, s = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => ht.render(this.render, !1, !0);
    const { latestValues: a, renderState: c } = i;
    this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = n.initial ? { ...a } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = o, this.options = s, this.isControllingVariants = iu(n), this.isVariantNode = W1(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: l, ...u } = this.scrapeMotionValuesFromProps(n, {});
    for (const d in u) {
      const f = u[d];
      a[d] !== void 0 && gn(f) && (f.set(a[d], !1), ml(l) && l.add(d));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n) {
    return {};
  }
  mount(t) {
    this.current = t, uv.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), ix.current || zV(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : op.current, process.env.NODE_ENV !== "production" && Hh(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    uv.delete(this.current), this.projection && this.projection.unmount(), zr(this.notifyUpdate), zr(this.render), this.valueSubscriptions.forEach((t) => t()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features)
      this.features[t].unmount();
    this.current = null;
  }
  bindToMotionValue(t, n) {
    const r = jo.has(t), o = n.on("change", (s) => {
      this.latestValues[t] = s, this.props.onUpdate && ht.update(this.notifyUpdate, !1, !0), r && this.projection && (this.projection.isTransformDirty = !0);
    }), i = n.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(t, () => {
      o(), i();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  loadFeatures({ children: t, ...n }, r, o, i) {
    let s, a;
    if (process.env.NODE_ENV !== "production" && o && r) {
      const c = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      n.ignoreStrict ? Ra(!1, c) : Vn(!1, c);
    }
    for (let c = 0; c < WV; c++) {
      const l = sx[c], { isEnabled: u, Feature: d, ProjectionNode: f, MeasureLayout: p } = ia[l];
      f && (s = f), u(n) && (!this.features[l] && d && (this.features[l] = new d(this)), p && (a = p));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && s) {
      this.projection = new s(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: c, layout: l, drag: u, dragConstraints: d, layoutScroll: f, layoutRoot: p } = n;
      this.projection.setOptions({
        layoutId: c,
        layout: l,
        alwaysMeasureLayout: !!u || d && xi(d),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof l == "string" ? l : "both",
        initialPromotionConfig: i,
        layoutScroll: f,
        layoutRoot: p
      });
    }
    return a;
  }
  updateFeatures() {
    for (const t in this.features) {
      const n = this.features[t];
      n.isMounted ? n.update() : (n.mount(), n.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Bt();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(t, n = !0) {
    return this.makeTargetAnimatableFromInstance(t, this.props, n);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < dv.length; r++) {
      const o = dv[r];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const i = t["on" + o];
      i && (this.propEventSubscriptions[o] = this.on(o, i));
    }
    this.prevMotionValues = GV(this, this.scrapeMotionValuesFromProps(t, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(t = !1) {
    if (t)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const r = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (r.initial = this.props.initial), r;
    }
    const n = {};
    for (let r = 0; r < HV; r++) {
      const o = kh[r], i = this.props[o];
      (oa(i) || i === !1) && (n[o] = i);
    }
    return n;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    n !== this.values.get(t) && (this.removeValue(t), this.bindToMotionValue(t, n)), this.values.set(t, n), this.latestValues[t] = n.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Zi(n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t) {
    var n;
    return this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (n = this.getBaseTargetFromProps(this.props, t)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, t, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: r } = this.props, o = typeof r == "string" || typeof r == "object" ? (n = Mh(this.props, r)) === null || n === void 0 ? void 0 : n[t] : void 0;
    if (r && o !== void 0)
      return o;
    const i = this.getBaseTargetFromProps(this.props, t);
    return i !== void 0 && !gn(i) ? i : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Wh()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
class ax extends jV {
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  makeTargetAnimatableFromInstance({ transition: t, transitionEnd: n, ...r }, { transformValues: o }, i) {
    let s = s$(r, t || {}, this);
    if (o && (n && (n = o(n)), r && (r = o(r)), s && (s = o(s))), i) {
      o$(this, r, s);
      const a = LV(this, r, s, n);
      n = a.transitionEnd, r = a.target;
    }
    return {
      transition: t,
      transitionEnd: n,
      ...r
    };
  }
}
function XV(e) {
  return window.getComputedStyle(e);
}
class YV extends ax {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(t, n) {
    if (jo.has(n)) {
      const r = $h(n);
      return r && r.default || 0;
    } else {
      const r = XV(t), o = (Y1(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return YS(t, n);
  }
  build(t, n, r, o) {
    Eh(t, n, r, o.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n) {
    return Nh(t, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    gn(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
  renderInstance(t, n, r, o) {
    Q1(t, n, r, o);
  }
}
class ZV extends ax {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (jo.has(n)) {
      const r = $h(n);
      return r && r.default || 0;
    }
    return n = eS.has(n) ? n : wh(n), t.getAttribute(n);
  }
  measureInstanceViewportBox() {
    return Bt();
  }
  scrapeMotionValuesFromProps(t, n) {
    return nS(t, n);
  }
  build(t, n, r, o) {
    _h(t, n, r, this.isSVGTag, o.transformTemplate);
  }
  renderInstance(t, n, r, o) {
    tS(t, n, r, o);
  }
  mount(t) {
    this.isSVGTag = Oh(t.tagName), super.mount(t);
  }
}
const UV = (e, t) => Th(e) ? new ZV(t, { enableHardwareAcceleration: !1 }) : new YV(t, { enableHardwareAcceleration: !0 }), JV = {
  layout: {
    ProjectionNode: rx,
    MeasureLayout: JS
  }
}, KV = {
  ...x$,
  ...WF,
  ...AV,
  ...JV
}, Jt = /* @__PURE__ */ qB((e, t) => RF(e, t, KV, UV));
function cx() {
  const e = se(!1);
  return Ih(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function qV() {
  const e = cx(), [t, n] = ue(0), r = R(() => {
    e.current && n(t + 1);
  }, [t]);
  return [R(() => ht.postRender(r), [r]), t];
}
class QV extends ie.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function e5({ children: e, isPresent: t }) {
  const n = Xt(), r = se(null), o = se({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return A0(() => {
    const { width: i, height: s, top: a, left: c } = o.current;
    if (t || !r.current || !i || !s)
      return;
    r.current.dataset.motionPopId = n;
    const l = document.createElement("style");
    return document.head.appendChild(l), l.sheet && l.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${i}px !important;
            height: ${s}px !important;
            top: ${a}px !important;
            left: ${c}px !important;
          }
        `), () => {
      document.head.removeChild(l);
    };
  }, [t]), ie.createElement(QV, { isPresent: t, childRef: r, sizeRef: o }, ie.cloneElement(e, { ref: r }));
}
const Ld = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: o, presenceAffectsLayout: i, mode: s }) => {
  const a = rS(t5), c = Xt(), l = be(
    () => ({
      id: c,
      initial: t,
      isPresent: n,
      custom: o,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const d of a.values())
          if (!d)
            return;
        r && r();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? void 0 : [n]
  );
  return be(() => {
    a.forEach((u, d) => a.set(d, !1));
  }, [n]), ie.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), s === "popLayout" && (e = ie.createElement(e5, { isPresent: n }, e)), ie.createElement(ka.Provider, { value: l }, e);
};
function t5() {
  return /* @__PURE__ */ new Map();
}
function n5(e) {
  return ge(() => () => e(), []);
}
const xo = (e) => e.key || "";
function r5(e, t) {
  e.forEach((n) => {
    const r = xo(n);
    t.set(r, n);
  });
}
function o5(e) {
  const t = [];
  return yr.forEach(e, (n) => {
    ao(n) && t.push(n);
  }), t;
}
const Sr = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, exitBeforeEnter: o, presenceAffectsLayout: i = !0, mode: s = "sync" }) => {
  Vn(!o, "Replace exitBeforeEnter with mode='wait'");
  const a = at(Ah).forceRender || qV()[0], c = cx(), l = o5(e);
  let u = l;
  const d = se(/* @__PURE__ */ new Map()).current, f = se(u), p = se(/* @__PURE__ */ new Map()).current, m = se(!0);
  if (Ih(() => {
    m.current = !1, r5(l, p), f.current = u;
  }), n5(() => {
    m.current = !0, p.clear(), d.clear();
  }), m.current)
    return ie.createElement(ie.Fragment, null, u.map((y) => ie.createElement(Ld, { key: xo(y), isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: i, mode: s }, y)));
  u = [...u];
  const h = f.current.map(xo), g = l.map(xo), v = h.length;
  for (let y = 0; y < v; y++) {
    const x = h[y];
    g.indexOf(x) === -1 && !d.has(x) && d.set(x, void 0);
  }
  return s === "wait" && d.size && (u = []), d.forEach((y, x) => {
    if (g.indexOf(x) !== -1)
      return;
    const S = p.get(x);
    if (!S)
      return;
    const C = h.indexOf(x);
    let w = y;
    if (!w) {
      const I = () => {
        d.delete(x);
        const P = Array.from(p.keys()).filter((k) => !g.includes(k));
        if (P.forEach((k) => p.delete(k)), f.current = l.filter((k) => {
          const A = xo(k);
          return (
            // filter out the node exiting
            A === x || // filter out the leftover children
            P.includes(A)
          );
        }), !d.size) {
          if (c.current === !1)
            return;
          a(), r && r();
        }
      };
      w = ie.createElement(Ld, { key: xo(S), isPresent: !1, onExitComplete: I, custom: t, presenceAffectsLayout: i, mode: s }, S), d.set(x, w);
    }
    u.splice(C, 0, w);
  }), u = u.map((y) => {
    const x = y.key;
    return d.has(x) ? y : ie.createElement(Ld, { key: xo(y), isPresent: !0, presenceAffectsLayout: i, mode: s }, y);
  }), process.env.NODE_ENV !== "production" && s === "wait" && u.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), ie.createElement(ie.Fragment, null, d.size ? u : u.map((y) => Lt(y)));
}, i5 = (e, t) => e.find((n) => n.id === t);
function fv(e, t) {
  const n = lx(e, t), r = n ? e[n].findIndex((o) => o.id === t) : -1;
  return {
    position: n,
    index: r
  };
}
function lx(e, t) {
  for (const [n, r] of Object.entries(e))
    if (i5(r, t))
      return n;
}
function s5(e) {
  const t = e.includes("right"), n = e.includes("left");
  let r = "center";
  return t && (r = "flex-end"), n && (r = "flex-start"), {
    display: "flex",
    flexDirection: "column",
    alignItems: r
  };
}
function a5(e) {
  const n = e === "top" || e === "bottom" ? "0 auto" : void 0, r = e.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0, o = e.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0, i = e.includes("left") ? void 0 : "env(safe-area-inset-right, 0px)", s = e.includes("right") ? void 0 : "env(safe-area-inset-left, 0px)";
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: n,
    top: r,
    bottom: o,
    right: i,
    left: s
  };
}
var c5 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, l5 = /* @__PURE__ */ A1(
  function(e) {
    return c5.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), u5 = l5, d5 = function(t) {
  return t !== "theme";
}, pv = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? u5 : d5;
}, hv = function(t, n, r) {
  var o;
  if (n) {
    var i = n.shouldForwardProp;
    o = t.__emotion_forwardProp && i ? function(s) {
      return t.__emotion_forwardProp(s) && i(s);
    } : i;
  }
  return typeof o != "function" && r && (o = t.__emotion_forwardProp), o;
}, f5 = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return gh(n, r, o), O1(function() {
    return bh(n, r, o);
  }), null;
}, p5 = function e(t, n) {
  var r = t.__emotion_real === t, o = r && t.__emotion_base || t, i, s;
  n !== void 0 && (i = n.label, s = n.target);
  var a = hv(t, n, r), c = a || pv(o), l = !c("as");
  return function() {
    var u = arguments, d = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (i !== void 0 && d.push("label:" + i + ";"), u[0] == null || u[0].raw === void 0)
      d.push.apply(d, u);
    else {
      var f = u[0];
      d.push(f[0]);
      for (var p = u.length, m = 1; m < p; m++)
        d.push(u[m], f[m]);
    }
    var h = yh(function(g, v, y) {
      var x = l && g.as || o, S = "", C = [], w = g;
      if (g.theme == null) {
        w = {};
        for (var I in g)
          w[I] = g[I];
        w.theme = ie.useContext(Lo);
      }
      typeof g.className == "string" ? S = E1(v.registered, C, g.className) : g.className != null && (S = g.className + " ");
      var P = Ql(d.concat(C), v.registered, w);
      S += v.key + "-" + P.name, s !== void 0 && (S += " " + s);
      var k = l && a === void 0 ? pv(x) : c, A = {};
      for (var N in g)
        l && N === "as" || k(N) && (A[N] = g[N]);
      return A.className = S, y && (A.ref = y), /* @__PURE__ */ ie.createElement(ie.Fragment, null, /* @__PURE__ */ ie.createElement(f5, {
        cache: v,
        serialized: P,
        isStringTag: typeof x == "string"
      }), /* @__PURE__ */ ie.createElement(x, A));
    });
    return h.displayName = i !== void 0 ? i : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", h.defaultProps = t.defaultProps, h.__emotion_real = h, h.__emotion_base = o, h.__emotion_styles = d, h.__emotion_forwardProp = a, Object.defineProperty(h, "toString", {
      value: function() {
        return "." + s;
      }
    }), h.withComponent = function(g, v) {
      var y = e(g, Ie({}, n, v, {
        shouldForwardProp: hv(h, v, !0)
      }));
      return y.apply(void 0, d);
    }, h;
  };
}, h5 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], aa = p5.bind(null);
h5.forEach(function(e) {
  aa[e] = aa(e);
});
const m5 = /* @__PURE__ */ new Set([
  ...UT,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]), g5 = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function b5(e) {
  return (g5.has(e) || !m5.has(e)) && e[0] !== "_";
}
const v5 = EA(aa), y5 = ({ baseStyle: e }) => (t) => {
  const { theme: n, css: r, __css: o, sx: i, ...s } = t, [a] = BA(s, KT), c = jt(e, t), l = gA(
    {},
    o,
    c,
    is(a),
    i
  ), u = s1(l)(t.theme);
  return r ? [u, r] : u;
};
function zd(e, t) {
  const { baseStyle: n, ...r } = t ?? {};
  r.shouldForwardProp || (r.shouldForwardProp = b5);
  const o = y5({ baseStyle: n }), i = v5(
    e,
    r
  )(o);
  return _t(
    function(c, l) {
      const { children: u, ...d } = c, { colorMode: f, forced: p } = tu();
      return eh(
        i,
        { ref: l, "data-theme": p ? f : void 0, ...d },
        u
      );
    }
  );
}
function S5() {
  const e = /* @__PURE__ */ new Map();
  return new Proxy(zd, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(t, n, r) {
      return zd(...r);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(t, n) {
      return e.has(n) || e.set(n, zd(n)), e.get(n);
    }
  });
}
const z = S5(), x5 = {
  initial: (e) => {
    const { position: t } = e, n = ["top", "bottom"].includes(t) ? "y" : "x";
    let r = ["top-right", "bottom-right"].includes(t) ? 1 : -1;
    return t === "bottom" && (r = 1), {
      opacity: 0,
      [n]: r * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
}, ux = T0((e) => {
  const {
    id: t,
    message: n,
    onCloseComplete: r,
    onRequestRemove: o,
    requestClose: i = !1,
    position: s = "bottom",
    duration: a = 5e3,
    containerStyle: c,
    motionVariants: l = x5,
    toastSpacing: u = "0.5rem"
  } = e, [d, f] = ue(a), p = W$();
  Jn(() => {
    p || r?.();
  }, [p]), Jn(() => {
    f(a);
  }, [a]);
  const m = () => f(null), h = () => f(a), g = () => {
    p && o();
  };
  ge(() => {
    p && i && o();
  }, [p, i, o]), tT(g, d);
  const v = be(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: u,
      ...c
    }),
    [c, u]
  ), y = be(() => s5(s), [s]);
  return /* @__PURE__ */ b(
    Jt.div,
    {
      layout: !0,
      className: "chakra-toast",
      variants: l,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: m,
      onHoverEnd: h,
      custom: { position: s },
      style: y,
      children: /* @__PURE__ */ b(
        z.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: v,
          children: jt(n, { id: t, onClose: g })
        }
      )
    }
  );
});
ux.displayName = "ToastComponent";
function X(e) {
  return _t(e);
}
var Gd, mv;
function C5() {
  if (mv) return Gd;
  mv = 1;
  var e = typeof Element < "u", t = typeof Map == "function", n = typeof Set == "function", r = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function o(i, s) {
    if (i === s) return !0;
    if (i && s && typeof i == "object" && typeof s == "object") {
      if (i.constructor !== s.constructor) return !1;
      var a, c, l;
      if (Array.isArray(i)) {
        if (a = i.length, a != s.length) return !1;
        for (c = a; c-- !== 0; )
          if (!o(i[c], s[c])) return !1;
        return !0;
      }
      var u;
      if (t && i instanceof Map && s instanceof Map) {
        if (i.size !== s.size) return !1;
        for (u = i.entries(); !(c = u.next()).done; )
          if (!s.has(c.value[0])) return !1;
        for (u = i.entries(); !(c = u.next()).done; )
          if (!o(c.value[1], s.get(c.value[0]))) return !1;
        return !0;
      }
      if (n && i instanceof Set && s instanceof Set) {
        if (i.size !== s.size) return !1;
        for (u = i.entries(); !(c = u.next()).done; )
          if (!s.has(c.value[0])) return !1;
        return !0;
      }
      if (r && ArrayBuffer.isView(i) && ArrayBuffer.isView(s)) {
        if (a = i.length, a != s.length) return !1;
        for (c = a; c-- !== 0; )
          if (i[c] !== s[c]) return !1;
        return !0;
      }
      if (i.constructor === RegExp) return i.source === s.source && i.flags === s.flags;
      if (i.valueOf !== Object.prototype.valueOf && typeof i.valueOf == "function" && typeof s.valueOf == "function") return i.valueOf() === s.valueOf();
      if (i.toString !== Object.prototype.toString && typeof i.toString == "function" && typeof s.toString == "function") return i.toString() === s.toString();
      if (l = Object.keys(i), a = l.length, a !== Object.keys(s).length) return !1;
      for (c = a; c-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(s, l[c])) return !1;
      if (e && i instanceof Element) return !1;
      for (c = a; c-- !== 0; )
        if (!((l[c] === "_owner" || l[c] === "__v" || l[c] === "__o") && i.$$typeof) && !o(i[l[c]], s[l[c]]))
          return !1;
      return !0;
    }
    return i !== i && s !== s;
  }
  return Gd = function(s, a) {
    try {
      return o(s, a);
    } catch (c) {
      if ((c.message || "").match(/stack|recursion/i))
        return console.warn("react-fast-compare cannot handle circular refs"), !1;
      throw c;
    }
  }, Gd;
}
var I5 = C5();
const dx = /* @__PURE__ */ Wl(I5);
function bn() {
  const e = at(
    Lo
  );
  if (!e)
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  return e;
}
function fx() {
  const e = tu(), t = bn();
  return { ...e, theme: t };
}
function w5(e, t, n) {
  if (t == null)
    return t;
  const r = (o) => e.__breakpoints?.asArray?.[o];
  return r(t) ?? r(n) ?? n;
}
function P5(e, t, n) {
  if (t == null)
    return t;
  const r = (o) => e.__cssMap?.[o]?.value;
  return r(t) ?? r(n) ?? n;
}
function k5(e, t, n) {
  const r = bn();
  return px(e, t, n)(r);
}
function px(e, t, n) {
  const r = Array.isArray(t) ? t : [t], o = Array.isArray(n) ? n : [n];
  return (i) => {
    const s = o.filter(Boolean), a = r.map((c, l) => {
      if (e === "breakpoints")
        return w5(i, c, s[l] ?? c);
      const u = `${e}.${c}`;
      return P5(i, u, s[l] ?? c);
    });
    return Array.isArray(t) ? a : a[0];
  };
}
function A5(e) {
  return Object.fromEntries(
    Object.entries(e).filter(([t, n]) => n !== void 0 && t !== "children" && !ao(n))
  );
}
function hx(e, t = {}) {
  const { styleConfig: n, ...r } = t, { theme: o, colorMode: i } = fx(), s = e ? D0(o, `components.${e}`) : void 0, a = n || s, c = Ot(
    { theme: o, colorMode: i },
    a?.defaultProps ?? {},
    A5(r),
    (u, d) => u ? void 0 : d
  ), l = se({});
  if (a) {
    const d = cE(a)(c);
    dx(l.current, d) || (l.current = d);
  }
  return l.current;
}
function Gt(e, t = {}) {
  return hx(e, t);
}
function We(e, t = {}) {
  return hx(e, t);
}
const gv = {
  path: /* @__PURE__ */ Ae("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ b(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ b(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ b("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
}, It = X((e, t) => {
  const {
    as: n,
    viewBox: r,
    color: o = "currentColor",
    focusable: i = !1,
    children: s,
    className: a,
    __css: c,
    ...l
  } = e, u = oe("chakra-icon", a), d = Gt("Icon", e), f = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: o,
    ...c,
    ...d
  }, p = {
    ref: t,
    focusable: i,
    className: u,
    __css: f
  }, m = r ?? gv.viewBox;
  if (n && typeof n != "string")
    return /* @__PURE__ */ b(z.svg, { as: n, ...p, ...l });
  const h = s ?? gv.path;
  return /* @__PURE__ */ b(z.svg, { verticalAlign: "middle", viewBox: m, ...p, ...l, children: h });
});
It.displayName = "Icon";
function T5(e) {
  return /* @__PURE__ */ b(It, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function E5(e) {
  return /* @__PURE__ */ b(It, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function bv(e) {
  return /* @__PURE__ */ b(It, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
const R5 = An({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
}), lu = X((e, t) => {
  const n = Gt("Spinner", e), {
    label: r = "Loading...",
    thickness: o = "2px",
    speed: i = "0.45s",
    emptyColor: s = "transparent",
    className: a,
    ...c
  } = $e(e), l = oe("chakra-spinner", a), u = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: o,
    borderBottomColor: s,
    borderLeftColor: s,
    animation: `${R5} ${i} linear infinite`,
    ...n
  };
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: t,
      __css: u,
      className: l,
      ...c,
      children: r && /* @__PURE__ */ b(z.span, { srOnly: !0, children: r })
    }
  );
});
lu.displayName = "Spinner";
const [_5, jh] = De({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
}), [O5, Xh] = De({
  name: "AlertStylesContext",
  hookName: "useAlertStyles",
  providerName: "<Alert />"
}), mx = {
  info: { icon: E5, colorScheme: "blue" },
  warning: { icon: bv, colorScheme: "orange" },
  success: { icon: T5, colorScheme: "green" },
  error: { icon: bv, colorScheme: "red" },
  loading: { icon: lu, colorScheme: "blue" }
};
function N5(e) {
  return mx[e].colorScheme;
}
function M5(e) {
  return mx[e].icon;
}
const gx = X(function(t, n) {
  const { status: r = "info", addRole: o = !0, ...i } = $e(t), s = t.colorScheme ?? N5(r), a = We("Alert", { ...t, colorScheme: s }), c = {
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...a.container
  };
  return /* @__PURE__ */ b(_5, { value: { status: r }, children: /* @__PURE__ */ b(O5, { value: a, children: /* @__PURE__ */ b(
    z.div,
    {
      "data-status": r,
      role: o ? "alert" : void 0,
      ref: n,
      ...i,
      className: oe("chakra-alert", t.className),
      __css: c
    }
  ) }) });
});
gx.displayName = "Alert";
function bx(e) {
  const { status: t } = jh(), n = M5(t), r = Xh(), o = t === "loading" ? r.spinner : r.icon;
  return /* @__PURE__ */ b(
    z.span,
    {
      display: "inherit",
      "data-status": t,
      ...e,
      className: oe("chakra-alert__icon", e.className),
      __css: o,
      children: e.children || /* @__PURE__ */ b(n, { h: "100%", w: "100%" })
    }
  );
}
bx.displayName = "AlertIcon";
const vx = X(
  function(t, n) {
    const r = Xh(), { status: o } = jh();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        "data-status": o,
        ...t,
        className: oe("chakra-alert__title", t.className),
        __css: r.title
      }
    );
  }
);
vx.displayName = "AlertTitle";
const yx = X(
  function(t, n) {
    const { status: r } = jh(), o = Xh(), i = {
      display: "inline",
      ...o.description
    };
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        "data-status": r,
        ...t,
        className: oe("chakra-alert__desc", t.className),
        __css: i
      }
    );
  }
);
yx.displayName = "AlertDescription";
function B5(e) {
  return /* @__PURE__ */ b(It, { focusable: "false", "aria-hidden": !0, ...e, children: /* @__PURE__ */ b(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
const uu = X(
  function(t, n) {
    const r = Gt("CloseButton", t), { children: o, isDisabled: i, __css: s, ...a } = $e(t), c = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ b(
      z.button,
      {
        type: "button",
        "aria-label": "Close",
        ref: n,
        disabled: i,
        __css: {
          ...c,
          ...r,
          ...s
        },
        ...a,
        children: o || /* @__PURE__ */ b(B5, { width: "1em", height: "1em" })
      }
    );
  }
);
uu.displayName = "CloseButton";
const F5 = (e) => {
  const {
    status: t,
    variant: n = "solid",
    id: r,
    title: o,
    isClosable: i,
    onClose: s,
    description: a,
    colorScheme: c,
    icon: l
  } = e, u = r ? {
    root: `toast-${r}`,
    title: `toast-${r}-title`,
    description: `toast-${r}-description`
  } : void 0;
  return /* @__PURE__ */ Ae(
    gx,
    {
      addRole: !1,
      status: t,
      variant: n,
      id: u?.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme: c,
      children: [
        /* @__PURE__ */ b(bx, { children: l }),
        /* @__PURE__ */ Ae(z.div, { flex: "1", maxWidth: "100%", children: [
          o && /* @__PURE__ */ b(vx, { id: u?.title, children: o }),
          a && /* @__PURE__ */ b(yx, { id: u?.description, display: "block", children: a })
        ] }),
        i && /* @__PURE__ */ b(
          uu,
          {
            size: "sm",
            onClick: s,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function Sx(e = {}) {
  const { render: t, toastComponent: n = F5 } = e;
  return (o) => typeof t == "function" ? t({ ...o, ...e }) : /* @__PURE__ */ b(n, { ...o, ...e });
}
const D5 = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
}, ur = $5(D5);
function $5(e) {
  let t = e;
  const n = /* @__PURE__ */ new Set(), r = (o) => {
    t = o(t), n.forEach((i) => i());
  };
  return {
    getState: () => t,
    subscribe: (o) => (n.add(o), () => {
      r(() => e), n.delete(o);
    }),
    /**
     * Delete a toast record at its position
     */
    removeToast: (o, i) => {
      r((s) => ({
        ...s,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [i]: s[i].filter((a) => a.id != o)
      }));
    },
    notify: (o, i) => {
      const s = V5(o, i), { position: a, id: c } = s;
      return r((l) => {
        const d = a.includes("top") ? [s, ...l[a] ?? []] : [...l[a] ?? [], s];
        return {
          ...l,
          [a]: d
        };
      }), c;
    },
    update: (o, i) => {
      o && r((s) => {
        const a = { ...s }, { position: c, index: l } = fv(a, o);
        return c && l !== -1 && (a[c][l] = {
          ...a[c][l],
          ...i,
          message: Sx(i)
        }), a;
      });
    },
    closeAll: ({ positions: o } = {}) => {
      r((i) => (o ?? [
        "bottom",
        "bottom-right",
        "bottom-left",
        "top",
        "top-left",
        "top-right"
      ]).reduce(
        (c, l) => (c[l] = i[l].map((u) => ({
          ...u,
          requestClose: !0
        })), c),
        { ...i }
      ));
    },
    close: (o) => {
      r((i) => {
        const s = lx(i, o);
        return s ? {
          ...i,
          [s]: i[s].map((a) => a.id == o ? {
            ...a,
            requestClose: !0
          } : a)
        } : i;
      });
    },
    isActive: (o) => !!fv(ur.getState(), o).position
  };
}
let vv = 0;
function V5(e, t = {}) {
  vv += 1;
  const n = t.id ?? vv, r = t.position ?? "bottom";
  return {
    id: n,
    message: e,
    position: r,
    duration: t.duration,
    onCloseComplete: t.onCloseComplete,
    onRequestRemove: () => ur.removeToast(String(n), r),
    status: t.status,
    requestClose: !1,
    containerStyle: t.containerStyle
  };
}
const [xx, L5] = De({
  strict: !1,
  name: "PortalContext"
}), Yh = "chakra-portal", z5 = ".chakra-portal", G5 = (e) => /* @__PURE__ */ b(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: e.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: e.children
  }
), W5 = (e) => {
  const { appendToParentPortal: t, children: n } = e, [r, o] = ue(null), i = se(null), [, s] = ue({});
  ge(() => s({}), []);
  const a = L5(), c = LB();
  Dn(() => {
    if (!r)
      return;
    const u = r.ownerDocument, d = t ? a ?? u.body : u.body;
    if (!d)
      return;
    i.current = u.createElement("div"), i.current.className = Yh, d.appendChild(i.current), s({});
    const f = i.current;
    return () => {
      d.contains(f) && d.removeChild(f);
    };
  }, [r]);
  const l = c?.zIndex ? /* @__PURE__ */ b(G5, { zIndex: c?.zIndex, children: n }) : n;
  return i.current ? va(
    /* @__PURE__ */ b(xx, { value: i.current, children: l }),
    i.current
  ) : /* @__PURE__ */ b(
    "span",
    {
      ref: (u) => {
        u && o(u);
      }
    }
  );
}, H5 = (e) => {
  const { children: t, containerRef: n, appendToParentPortal: r } = e, o = n.current, i = o ?? (typeof window < "u" ? document.body : void 0), s = be(() => {
    const c = o?.ownerDocument.createElement("div");
    return c && (c.className = Yh), c;
  }, [o]), [, a] = ue({});
  return Dn(() => a({}), []), Dn(() => {
    if (!(!s || !i))
      return i.appendChild(s), () => {
        i.removeChild(s);
      };
  }, [s, i]), i && s ? va(
    /* @__PURE__ */ b(xx, { value: r ? s : null, children: t }),
    s
  ) : null;
};
function Yo(e) {
  const t = {
    appendToParentPortal: !0,
    ...e
  }, { containerRef: n, ...r } = t;
  return n ? /* @__PURE__ */ b(H5, { containerRef: n, ...r }) : /* @__PURE__ */ b(W5, { ...r });
}
Yo.className = Yh;
Yo.selector = z5;
Yo.displayName = "Portal";
const [j5, X5] = De({
  name: "ToastOptionsContext",
  strict: !1
}), Cx = (e) => {
  const t = E0(
    ur.subscribe,
    ur.getState,
    ur.getState
  ), {
    motionVariants: n,
    component: r = ux,
    portalProps: o,
    animatePresenceProps: i
  } = e, a = Object.keys(t).map((c) => {
    const l = t[c];
    return /* @__PURE__ */ b(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${c}`,
        id: `chakra-toast-manager-${c}`,
        style: a5(c),
        children: /* @__PURE__ */ b(Sr, { ...i, initial: !1, children: l.map((u) => /* @__PURE__ */ b(
          r,
          {
            motionVariants: n,
            ...u
          },
          u.id
        )) })
      },
      c
    );
  });
  return /* @__PURE__ */ b(Yo, { ...o, children: a });
}, Y5 = (e) => function({
  children: n,
  theme: r = e,
  toastOptions: o,
  ...i
}) {
  return /* @__PURE__ */ Ae(GB, { theme: r, ...i, children: [
    /* @__PURE__ */ b(j5, { value: o?.defaultOptions, children: n }),
    /* @__PURE__ */ b(Cx, { ...o })
  ] });
}, AQ = Y5(dh);
function yv(e) {
  return e.sort((t, n) => {
    const r = t.compareDocumentPosition(n);
    if (r & Node.DOCUMENT_POSITION_FOLLOWING || r & Node.DOCUMENT_POSITION_CONTAINED_BY)
      return -1;
    if (r & Node.DOCUMENT_POSITION_PRECEDING || r & Node.DOCUMENT_POSITION_CONTAINS)
      return 1;
    if (r & Node.DOCUMENT_POSITION_DISCONNECTED || r & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC)
      throw Error("Cannot sort the given nodes.");
    return 0;
  });
}
const Z5 = (e) => typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
function Sv(e, t, n) {
  let r = e + 1;
  return n && r >= t && (r = 0), r;
}
function xv(e, t, n) {
  let r = e - 1;
  return n && r < 0 && (r = t), r;
}
const Wd = typeof window < "u" ? os : ge, Cv = (e) => e;
var U5 = Object.defineProperty, J5 = (e, t, n) => t in e ? U5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, wt = (e, t, n) => (J5(e, typeof t != "symbol" ? t + "" : t, n), n);
class K5 {
  constructor() {
    wt(this, "descendants", /* @__PURE__ */ new Map()), wt(this, "register", (t) => {
      if (t != null)
        return Z5(t) ? this.registerNode(t) : (n) => {
          this.registerNode(n, t);
        };
    }), wt(this, "unregister", (t) => {
      this.descendants.delete(t);
      const n = yv(Array.from(this.descendants.keys()));
      this.assignIndex(n);
    }), wt(this, "destroy", () => {
      this.descendants.clear();
    }), wt(this, "assignIndex", (t) => {
      this.descendants.forEach((n) => {
        const r = t.indexOf(n.node);
        n.index = r, n.node.dataset.index = n.index.toString();
      });
    }), wt(this, "count", () => this.descendants.size), wt(this, "enabledCount", () => this.enabledValues().length), wt(this, "values", () => Array.from(this.descendants.values()).sort((n, r) => n.index - r.index)), wt(this, "enabledValues", () => this.values().filter((t) => !t.disabled)), wt(this, "item", (t) => {
      if (this.count() !== 0)
        return this.values()[t];
    }), wt(this, "enabledItem", (t) => {
      if (this.enabledCount() !== 0)
        return this.enabledValues()[t];
    }), wt(this, "first", () => this.item(0)), wt(this, "firstEnabled", () => this.enabledItem(0)), wt(this, "last", () => this.item(this.descendants.size - 1)), wt(this, "lastEnabled", () => {
      const t = this.enabledValues().length - 1;
      return this.enabledItem(t);
    }), wt(this, "indexOf", (t) => t ? this.descendants.get(t)?.index ?? -1 : -1), wt(this, "enabledIndexOf", (t) => t == null ? -1 : this.enabledValues().findIndex((n) => n.node.isSameNode(t))), wt(this, "next", (t, n = !0) => {
      const r = Sv(t, this.count(), n);
      return this.item(r);
    }), wt(this, "nextEnabled", (t, n = !0) => {
      const r = this.item(t);
      if (!r)
        return;
      const o = this.enabledIndexOf(r.node), i = Sv(
        o,
        this.enabledCount(),
        n
      );
      return this.enabledItem(i);
    }), wt(this, "prev", (t, n = !0) => {
      const r = xv(t, this.count() - 1, n);
      return this.item(r);
    }), wt(this, "prevEnabled", (t, n = !0) => {
      const r = this.item(t);
      if (!r)
        return;
      const o = this.enabledIndexOf(r.node), i = xv(
        o,
        this.enabledCount() - 1,
        n
      );
      return this.enabledItem(i);
    }), wt(this, "registerNode", (t, n) => {
      if (!t || this.descendants.has(t))
        return;
      const r = Array.from(this.descendants.keys()).concat(t), o = yv(r);
      n?.disabled && (n.disabled = !!n.disabled);
      const i = { node: t, index: -1, ...n };
      this.descendants.set(t, i), this.assignIndex(o);
    });
  }
}
function du() {
  const [e, t] = De({
    name: "DescendantsProvider",
    errorMessage: "useDescendantsContext must be used within DescendantsProvider"
  });
  return [
    // context provider
    e,
    // call this when you need to read from context
    t,
    () => {
      const o = se(new K5());
      return Wd(() => () => o.current.destroy()), o.current;
    },
    (o) => {
      const i = t(), [s, a] = ue(-1), c = se(null);
      Wd(() => () => {
        c.current && i.unregister(c.current);
      }, []), Wd(() => {
        if (!c.current)
          return;
        const u = Number(c.current.dataset.index);
        s != u && !Number.isNaN(u) && a(u);
      });
      const l = Cv(o ? i.register(o) : i.register);
      return {
        descendants: i,
        index: s,
        enabledIndex: i.enabledIndexOf(c.current),
        register: Ge(l, c)
      };
    }
  ];
}
const [q5, fu] = De({
  name: "AccordionStylesContext",
  hookName: "useAccordionStyles",
  providerName: "<Accordion />"
}), [Q5, Zh] = De({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItem />"
}), [
  e4,
  TQ,
  t4,
  n4
] = du();
function r4(e) {
  const {
    onChange: t,
    defaultIndex: n,
    index: r,
    allowMultiple: o,
    allowToggle: i,
    ...s
  } = e;
  s4(e), a4(e);
  const a = t4(), [c, l] = ue(-1);
  ge(() => () => {
    l(-1);
  }, []);
  const [u, d] = co({
    value: r,
    defaultValue() {
      return o ? n ?? [] : n ?? -1;
    },
    onChange: t
  });
  return {
    index: u,
    setIndex: d,
    htmlProps: s,
    getAccordionItemProps: (p) => {
      let m = !1;
      return p !== null && (m = Array.isArray(u) ? u.includes(p) : u === p), { isOpen: m, onChange: (g) => {
        if (p !== null)
          if (o && Array.isArray(u)) {
            const v = g ? u.concat(p) : u.filter((y) => y !== p);
            d(v);
          } else g ? d(p) : i && d(-1);
      } };
    },
    focusedIndex: c,
    setFocusedIndex: l,
    descendants: a
  };
}
const [o4, Uh] = De({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "Accordion"
});
function i4(e) {
  const { isDisabled: t, isFocusable: n, id: r, ...o } = e, { getAccordionItemProps: i, setFocusedIndex: s } = Uh(), a = se(null), c = Xt(), l = r ?? c, u = `accordion-button-${l}`, d = `accordion-panel-${l}`;
  c4(e);
  const { register: f, index: p, descendants: m } = n4({
    disabled: t && !n
  }), { isOpen: h, onChange: g } = i(
    p === -1 ? null : p
  );
  l4({ isOpen: h, isDisabled: t });
  const v = () => {
    g?.(!0);
  }, y = () => {
    g?.(!1);
  }, x = R(() => {
    g?.(!h), s(p);
  }, [p, s, h, g]), S = R(
    (P) => {
      const A = {
        ArrowDown: () => {
          m.nextEnabled(p)?.node.focus();
        },
        ArrowUp: () => {
          m.prevEnabled(p)?.node.focus();
        },
        Home: () => {
          m.firstEnabled()?.node.focus();
        },
        End: () => {
          m.lastEnabled()?.node.focus();
        }
      }[P.key];
      A && (P.preventDefault(), A(P));
    },
    [m, p]
  ), C = R(() => {
    s(p);
  }, [s, p]), w = R(
    function(k = {}, A = null) {
      return {
        ...k,
        type: "button",
        ref: Ge(f, a, A),
        id: u,
        disabled: !!t,
        "aria-expanded": !!h,
        "aria-controls": d,
        onClick: fe(k.onClick, x),
        onFocus: fe(k.onFocus, C),
        onKeyDown: fe(k.onKeyDown, S)
      };
    },
    [
      u,
      t,
      h,
      x,
      C,
      S,
      d,
      f
    ]
  ), I = R(
    function(k = {}, A = null) {
      return {
        ...k,
        ref: A,
        role: "region",
        id: d,
        "aria-labelledby": u,
        hidden: !h
      };
    },
    [u, h, d]
  );
  return {
    isOpen: h,
    isDisabled: t,
    isFocusable: n,
    onOpen: v,
    onClose: y,
    getButtonProps: w,
    getPanelProps: I,
    htmlProps: o
  };
}
function s4(e) {
  const t = e.index || e.defaultIndex, n = t != null && !Array.isArray(t) && e.allowMultiple;
  xa({
    condition: !!n,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof t},`
  });
}
function a4(e) {
  xa({
    condition: !!(e.allowMultiple && e.allowToggle),
    message: "If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not"
  });
}
function c4(e) {
  xa({
    condition: !!(e.isFocusable && !e.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}
function l4(e) {
  xa({
    condition: e.isOpen && !!e.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}
const Ix = X(function({ children: t, reduceMotion: n, ...r }, o) {
  const i = We("Accordion", r), s = $e(r), { htmlProps: a, descendants: c, ...l } = r4(s), u = be(
    () => ({ ...l, reduceMotion: !!n }),
    [l, n]
  );
  return /* @__PURE__ */ b(e4, { value: c, children: /* @__PURE__ */ b(o4, { value: u, children: /* @__PURE__ */ b(q5, { value: i, children: /* @__PURE__ */ b(
    z.div,
    {
      ref: o,
      ...a,
      className: oe("chakra-accordion", r.className),
      __css: i.root,
      children: t
    }
  ) }) }) });
});
Ix.displayName = "Accordion";
const wx = X(
  function(t, n) {
    const { getButtonProps: r } = Zh(), o = r(t, n), s = {
      display: "flex",
      alignItems: "center",
      width: "100%",
      outline: 0,
      ...fu().button
    };
    return /* @__PURE__ */ b(
      z.button,
      {
        ...o,
        className: oe("chakra-accordion__button", t.className),
        __css: s
      }
    );
  }
);
wx.displayName = "AccordionButton";
function Px(e) {
  const { isOpen: t, isDisabled: n } = Zh(), { reduceMotion: r } = Uh(), o = oe("chakra-accordion__icon", e.className), i = fu(), s = {
    opacity: n ? 0.4 : 1,
    transform: t ? "rotate(-180deg)" : void 0,
    transition: r ? void 0 : "transform 0.2s",
    transformOrigin: "center",
    ...i.icon
  };
  return /* @__PURE__ */ b(
    It,
    {
      viewBox: "0 0 24 24",
      "aria-hidden": !0,
      className: o,
      __css: s,
      ...e,
      children: /* @__PURE__ */ b(
        "path",
        {
          fill: "currentColor",
          d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
        }
      )
    }
  );
}
Px.displayName = "AccordionIcon";
const kx = X(
  function(t, n) {
    const { children: r, className: o } = t, { htmlProps: i, ...s } = i4(t), a = fu(), c = {
      ...a.container,
      overflowAnchor: "none"
    }, l = be(() => s, [s]);
    return /* @__PURE__ */ b(Q5, { value: l, children: /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        ...i,
        className: oe("chakra-accordion__item", o),
        __css: c,
        children: typeof r == "function" ? r({
          isExpanded: !!s.isOpen,
          isDisabled: !!s.isDisabled
        }) : r
      }
    ) });
  }
);
kx.displayName = "AccordionItem";
const ko = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
}, ys = {
  slideLeft: {
    position: { left: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "-100%", y: 0 }
  },
  slideRight: {
    position: { right: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "100%", y: 0 }
  },
  slideUp: {
    position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "-100%" }
  },
  slideDown: {
    position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "100%" }
  }
};
function ip(e) {
  switch (e?.direction ?? "right") {
    case "right":
      return ys.slideRight;
    case "left":
      return ys.slideLeft;
    case "bottom":
      return ys.slideDown;
    case "top":
      return ys.slideUp;
    default:
      return ys.slideRight;
  }
}
const No = {
  enter: {
    duration: 0.2,
    ease: ko.easeOut
  },
  exit: {
    duration: 0.1,
    ease: ko.easeIn
  }
}, Un = {
  enter: (e, t) => ({
    ...e,
    delay: typeof t == "number" ? t : t?.enter
  }),
  exit: (e, t) => ({
    ...e,
    delay: typeof t == "number" ? t : t?.exit
  })
}, u4 = (e) => e != null && parseInt(e.toString(), 10) > 0, Iv = {
  exit: {
    height: { duration: 0.2, ease: ko.ease },
    opacity: { duration: 0.3, ease: ko.ease }
  },
  enter: {
    height: { duration: 0.3, ease: ko.ease },
    opacity: { duration: 0.4, ease: ko.ease }
  }
}, d4 = {
  exit: ({
    animateOpacity: e,
    startingHeight: t,
    transition: n,
    transitionEnd: r,
    delay: o
  }) => ({
    ...e && { opacity: u4(t) ? 1 : 0 },
    height: t,
    transitionEnd: r?.exit,
    transition: n?.exit ?? Un.exit(Iv.exit, o)
  }),
  enter: ({
    animateOpacity: e,
    endingHeight: t,
    transition: n,
    transitionEnd: r,
    delay: o
  }) => ({
    ...e && { opacity: 1 },
    height: t,
    transitionEnd: r?.enter,
    transition: n?.enter ?? Un.enter(Iv.enter, o)
  })
}, Jh = _t(
  (e, t) => {
    const {
      in: n,
      unmountOnExit: r,
      animateOpacity: o = !0,
      startingHeight: i = 0,
      endingHeight: s = "auto",
      style: a,
      className: c,
      transition: l,
      transitionEnd: u,
      animatePresenceProps: d,
      ...f
    } = e, [p, m] = ue(!1);
    ge(() => {
      const x = setTimeout(() => {
        m(!0);
      });
      return () => clearTimeout(x);
    }, []), xa({
      condition: Number(i) > 0 && !!r,
      message: "startingHeight and unmountOnExit are mutually exclusive. You can't use them together"
    });
    const h = parseFloat(i.toString()) > 0, g = {
      startingHeight: i,
      endingHeight: s,
      animateOpacity: o,
      transition: p ? l : { enter: { duration: 0 } },
      transitionEnd: {
        enter: u?.enter,
        exit: r ? u?.exit : {
          ...u?.exit,
          display: h ? "block" : "none"
        }
      }
    }, v = r ? n : !0, y = n || r ? "enter" : "exit";
    return /* @__PURE__ */ b(
      Sr,
      {
        ...d,
        initial: !1,
        custom: g,
        children: v && /* @__PURE__ */ b(
          Jt.div,
          {
            ref: t,
            ...f,
            className: oe("chakra-collapse", c),
            style: {
              overflow: "hidden",
              display: "block",
              ...a
            },
            custom: g,
            variants: d4,
            initial: r ? "exit" : !1,
            animate: y,
            exit: "exit"
          }
        )
      }
    );
  }
);
Jh.displayName = "Collapse";
const Ax = X(
  function(t, n) {
    const { className: r, motionProps: o, ...i } = t, { reduceMotion: s } = Uh(), { getPanelProps: a, isOpen: c } = Zh(), l = a(i, n), u = oe("chakra-accordion__panel", r), d = fu();
    s || delete l.hidden;
    const f = /* @__PURE__ */ b(z.div, { ...l, __css: d.panel, className: u });
    return s ? f : /* @__PURE__ */ b(Jh, { in: c, ...o, children: f });
  }
);
Ax.displayName = "AccordionPanel";
const f4 = X(
  function(e, t) {
    const { ratio: n = 4 / 3, children: r, className: o, ...i } = e, s = yr.only(r), a = oe("chakra-aspect-ratio", o);
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: t,
        position: "relative",
        className: a,
        _before: {
          height: 0,
          content: '""',
          display: "block",
          paddingBottom: Sa(n, (c) => `${1 / c * 100}%`)
        },
        __css: {
          "& > *:not(style)": {
            overflow: "hidden",
            position: "absolute",
            top: "0",
            right: "0",
            bottom: "0",
            left: "0",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "100%",
            height: "100%"
          },
          "& > img, & > video": {
            objectFit: "cover"
          }
        },
        ...i,
        children: s
      }
    );
  }
);
f4.displayName = "AspectRatio";
const [p4, Tx] = De({
  name: "AvatarStylesContext",
  hookName: "useAvatarStyles",
  providerName: "<Avatar/>"
});
function h4(e) {
  const t = e.trim().split(" "), n = t[0] ?? "", r = t.length > 1 ? t[t.length - 1] : "";
  return n && r ? `${n.charAt(0)}${r.charAt(0)}` : n.charAt(0);
}
function Ex(e) {
  const { name: t, getInitials: n, ...r } = e, o = Tx();
  return /* @__PURE__ */ b(z.div, { role: "img", "aria-label": t, ...r, __css: o.label, children: t ? n?.(t) : null });
}
Ex.displayName = "AvatarName";
const Rx = (e) => /* @__PURE__ */ Ae(
  z.svg,
  {
    viewBox: "0 0 128 128",
    color: "#fff",
    width: "100%",
    height: "100%",
    className: "chakra-avatar__svg",
    ...e,
    children: [
      /* @__PURE__ */ b(
        "path",
        {
          fill: "currentColor",
          d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
        }
      ),
      /* @__PURE__ */ b(
        "path",
        {
          fill: "currentColor",
          d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
        }
      )
    ]
  }
);
function _x(e) {
  const {
    loading: t,
    src: n,
    srcSet: r,
    onLoad: o,
    onError: i,
    crossOrigin: s,
    sizes: a,
    ignoreFallback: c
  } = e, [l, u] = ue("pending");
  ge(() => {
    u(n ? "loading" : "pending");
  }, [n]);
  const d = se(null), f = R(() => {
    if (!n)
      return;
    p();
    const m = new Image();
    m.src = n, s && (m.crossOrigin = s), r && (m.srcset = r), a && (m.sizes = a), t && (m.loading = t), m.onload = (h) => {
      p(), u("loaded"), o?.(h);
    }, m.onerror = (h) => {
      p(), u("failed"), i?.(h);
    }, d.current = m;
  }, [n, s, r, a, o, i, t]), p = () => {
    d.current && (d.current.onload = null, d.current.onerror = null, d.current = null);
  };
  return Dn(() => {
    if (!c)
      return l === "loading" && f(), () => {
        p();
      };
  }, [l, f, c]), c ? "loaded" : l;
}
const m4 = (e, t) => e !== "loaded" && t === "beforeLoadOrError" || e === "failed" && t === "onError";
function Ox(e) {
  const {
    src: t,
    srcSet: n,
    onError: r,
    onLoad: o,
    getInitials: i,
    name: s,
    borderRadius: a,
    loading: c,
    iconLabel: l,
    icon: u = /* @__PURE__ */ b(Rx, {}),
    ignoreFallback: d,
    referrerPolicy: f,
    crossOrigin: p
  } = e, h = _x({ src: t, onError: r, crossOrigin: p, ignoreFallback: d }) === "loaded";
  return !t || !h ? s ? /* @__PURE__ */ b(
    Ex,
    {
      className: "chakra-avatar__initials",
      getInitials: i,
      name: s
    }
  ) : Lt(u, {
    role: "img",
    "aria-label": l
  }) : /* @__PURE__ */ b(
    z.img,
    {
      src: t,
      srcSet: n,
      alt: s ?? l,
      onLoad: o,
      referrerPolicy: f,
      crossOrigin: p ?? void 0,
      className: "chakra-avatar__img",
      loading: c,
      __css: {
        width: "100%",
        height: "100%",
        objectFit: "cover",
        borderRadius: a
      }
    }
  );
}
Ox.displayName = "AvatarImage";
const Nx = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  textTransform: "uppercase",
  fontWeight: "medium",
  position: "relative",
  flexShrink: 0
}, g4 = X((e, t) => {
  const n = We("Avatar", e), [r, o] = ue(!1), {
    src: i,
    srcSet: s,
    name: a,
    showBorder: c,
    borderRadius: l = "full",
    onError: u,
    onLoad: d,
    getInitials: f = h4,
    icon: p = /* @__PURE__ */ b(Rx, {}),
    iconLabel: m = " avatar",
    loading: h,
    children: g,
    borderColor: v,
    ignoreFallback: y,
    crossOrigin: x,
    referrerPolicy: S,
    ...C
  } = $e(e), w = {
    borderRadius: l,
    borderWidth: c ? "2px" : void 0,
    ...Nx,
    ...n.container
  };
  return v && (w.borderColor = v), /* @__PURE__ */ b(
    z.span,
    {
      ref: t,
      ...C,
      className: oe("chakra-avatar", e.className),
      "data-loaded": ye(r),
      __css: w,
      children: /* @__PURE__ */ Ae(p4, { value: n, children: [
        /* @__PURE__ */ b(
          Ox,
          {
            src: i,
            srcSet: s,
            loading: h,
            onLoad: fe(d, () => {
              o(!0);
            }),
            onError: u,
            getInitials: f,
            name: a,
            borderRadius: l,
            icon: p,
            iconLabel: m,
            ignoreFallback: y,
            crossOrigin: x,
            referrerPolicy: S
          }
        ),
        g
      ] })
    }
  );
});
g4.displayName = "Avatar";
const b4 = {
  "top-start": {
    top: "0",
    insetStart: "0",
    transform: "translate(-25%, -25%)"
  },
  "top-end": {
    top: "0",
    insetEnd: "0",
    transform: "translate(25%, -25%)"
  },
  "bottom-start": {
    bottom: "0",
    insetStart: "0",
    transform: "translate(-25%, 25%)"
  },
  "bottom-end": {
    bottom: "0",
    insetEnd: "0",
    transform: "translate(25%, 25%)"
  }
}, v4 = X(
  function(t, n) {
    const { placement: r = "bottom-end", className: o, ...i } = t, s = Tx(), c = {
      position: "absolute",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      ...b4[r],
      ...s.badge
    };
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        ...i,
        className: oe("chakra-avatar__badge", o),
        __css: c
      }
    );
  }
);
v4.displayName = "AvatarBadge";
const y4 = X(
  function(t, n) {
    const r = We("Avatar", t), {
      children: o,
      borderColor: i,
      max: s,
      spacing: a = "-0.75rem",
      borderRadius: c = "full",
      ...l
    } = $e(t), u = Hr(o), d = s != null ? u.slice(0, s) : u, f = s != null ? u.length - s : 0, m = d.reverse().map((v, y) => {
      const S = {
        marginEnd: y === 0 ? 0 : a,
        size: t.size,
        borderColor: v.props.borderColor ?? i,
        showBorder: !0
      };
      return Lt(v, is(S));
    }), h = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      flexDirection: "row-reverse",
      ...r.group
    }, g = {
      borderRadius: c,
      marginStart: a,
      ...Nx,
      ...r.excessLabel
    };
    return /* @__PURE__ */ Ae(
      z.div,
      {
        ref: n,
        role: "group",
        __css: h,
        ...l,
        className: oe("chakra-avatar__group", t.className),
        children: [
          f > 0 && /* @__PURE__ */ b(z.span, { className: "chakra-avatar__excess", __css: g, children: `+${f}` }),
          m
        ]
      }
    );
  }
);
y4.displayName = "AvatarGroup";
const Kh = X(function(t, n) {
  const r = Gt("Badge", t), { className: o, ...i } = $e(t);
  return /* @__PURE__ */ b(
    z.span,
    {
      ref: n,
      className: oe("chakra-badge", t.className),
      ...i,
      __css: {
        display: "inline-block",
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        ...r
      }
    }
  );
});
Kh.displayName = "Badge";
const Rt = z("div");
Rt.displayName = "Box";
const Mx = X(
  function(t, n) {
    const { size: r, centerContent: o = !0, ...i } = t;
    return /* @__PURE__ */ b(
      Rt,
      {
        ref: n,
        boxSize: r,
        __css: {
          ...o ? { display: "flex", alignItems: "center", justifyContent: "center" } : {},
          flexShrink: 0,
          flexGrow: 0
        },
        ...i
      }
    );
  }
);
Mx.displayName = "Square";
const S4 = X(
  function(t, n) {
    const { size: r, ...o } = t;
    return /* @__PURE__ */ b(Mx, { size: r, ref: n, borderRadius: "9999px", ...o });
  }
);
S4.displayName = "Circle";
const [x4, qh] = De({
  name: "BreadcrumbStylesContext",
  errorMessage: `useBreadcrumbStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Breadcrumb />" `
}), C4 = X(
  function(t, n) {
    const r = We("Breadcrumb", t), o = $e(t), {
      children: i,
      spacing: s = "0.5rem",
      separator: a = "/",
      className: c,
      listProps: l,
      ...u
    } = o, d = Hr(i), f = d.length, p = d.map(
      (h, g) => Lt(h, {
        separator: a,
        spacing: s,
        isLastChild: f === g + 1
      })
    ), m = oe("chakra-breadcrumb", c);
    return /* @__PURE__ */ b(
      z.nav,
      {
        ref: n,
        "aria-label": "breadcrumb",
        className: m,
        __css: r.container,
        ...u,
        children: /* @__PURE__ */ b(x4, { value: r, children: /* @__PURE__ */ b(
          z.ol,
          {
            className: "chakra-breadcrumb__list",
            ...l,
            __css: {
              display: "flex",
              alignItems: "center",
              ...r.list
            },
            children: p
          }
        ) })
      }
    );
  }
);
C4.displayName = "Breadcrumb";
const Bx = X(
  function(t, n) {
    const { isCurrentPage: r, as: o, className: i, href: s, ...a } = t, c = qh(), l = {
      ref: n,
      as: o,
      className: oe("chakra-breadcrumb__link", i),
      ...a
    };
    return r ? /* @__PURE__ */ b(z.span, { "aria-current": "page", __css: c.link, ...l }) : /* @__PURE__ */ b(z.a, { __css: c.link, href: s, ...l });
  }
);
Bx.displayName = "BreadcrumbLink";
const sp = X(
  function(t, n) {
    const { spacing: r, ...o } = t, i = qh(), s = {
      mx: r,
      ...i.separator
    };
    return /* @__PURE__ */ b(
      z.span,
      {
        ref: n,
        role: "presentation",
        ...o,
        __css: s
      }
    );
  }
);
sp.displayName = "BreadcrumbSeparator";
const I4 = X(
  function(t, n) {
    const {
      isCurrentPage: r,
      separator: o,
      isLastChild: i,
      spacing: s,
      children: a,
      className: c,
      ...l
    } = t, d = Hr(a).map((h) => h.type === Bx ? Lt(h, {
      isCurrentPage: r
    }) : h.type === sp ? Lt(h, {
      spacing: s,
      children: h.props.children || o
    }) : h), f = qh(), p = {
      display: "inline-flex",
      alignItems: "center",
      ...f.item
    }, m = oe("chakra-breadcrumb__list-item", c);
    return /* @__PURE__ */ Ae(z.li, { ref: n, className: m, ...l, __css: p, children: [
      d,
      !i && /* @__PURE__ */ b(sp, { spacing: s, children: o })
    ] });
  }
);
I4.displayName = "BreadcrumbItem";
const [w4, P4] = De({
  strict: !1,
  name: "ButtonGroupContext"
});
function Ns(e) {
  const { children: t, className: n, ...r } = e, o = ao(t) ? Lt(t, {
    "aria-hidden": !0,
    focusable: !1
  }) : t, i = oe("chakra-button__icon", n);
  return /* @__PURE__ */ b(
    z.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...r,
      className: i,
      children: o
    }
  );
}
Ns.displayName = "ButtonIcon";
function ap(e) {
  const {
    label: t,
    placement: n,
    spacing: r = "0.5rem",
    children: o = /* @__PURE__ */ b(lu, { color: "currentColor", width: "1em", height: "1em" }),
    className: i,
    __css: s,
    ...a
  } = e, c = oe("chakra-button__spinner", i), l = n === "start" ? "marginEnd" : "marginStart", u = be(
    () => ({
      display: "flex",
      alignItems: "center",
      position: t ? "relative" : "absolute",
      [l]: t ? r : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...s
    }),
    [s, t, l, r]
  );
  return /* @__PURE__ */ b(z.div, { className: c, ...a, __css: u, children: o });
}
ap.displayName = "ButtonSpinner";
function k4(e) {
  const [t, n] = ue(!e);
  return { ref: R((i) => {
    i && n(i.tagName === "BUTTON");
  }, []), type: t ? "button" : void 0 };
}
const bl = X((e, t) => {
  const n = P4(), r = Gt("Button", { ...n, ...e }), {
    isDisabled: o = n?.isDisabled,
    isLoading: i,
    isActive: s,
    children: a,
    leftIcon: c,
    rightIcon: l,
    loadingText: u,
    iconSpacing: d = "0.5rem",
    type: f,
    spinner: p,
    spinnerPlacement: m = "start",
    className: h,
    as: g,
    shouldWrapChildren: v,
    ...y
  } = $e(e), x = be(() => {
    const I = { ...r?._focus, zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...r,
      ...!!n && { _focus: I }
    };
  }, [r, n]), { ref: S, type: C } = k4(g), w = {
    rightIcon: l,
    leftIcon: c,
    iconSpacing: d,
    children: a,
    shouldWrapChildren: v
  };
  return /* @__PURE__ */ Ae(
    z.button,
    {
      disabled: o || i,
      ref: QA(t, S),
      as: g,
      type: f ?? C,
      "data-active": ye(s),
      "data-loading": ye(i),
      __css: x,
      className: oe("chakra-button", h),
      ...y,
      children: [
        i && m === "start" && /* @__PURE__ */ b(
          ap,
          {
            className: "chakra-button__spinner--start",
            label: u,
            placement: "start",
            spacing: d,
            children: p
          }
        ),
        i ? u || /* @__PURE__ */ b(z.span, { opacity: 0, children: /* @__PURE__ */ b(wv, { ...w }) }) : /* @__PURE__ */ b(wv, { ...w }),
        i && m === "end" && /* @__PURE__ */ b(
          ap,
          {
            className: "chakra-button__spinner--end",
            label: u,
            placement: "end",
            spacing: d,
            children: p
          }
        )
      ]
    }
  );
});
bl.displayName = "Button";
function wv(e) {
  const { leftIcon: t, rightIcon: n, children: r, iconSpacing: o, shouldWrapChildren: i } = e;
  return i ? /* @__PURE__ */ Ae("span", { style: { display: "contents" }, children: [
    t && /* @__PURE__ */ b(Ns, { marginEnd: o, children: t }),
    r,
    n && /* @__PURE__ */ b(Ns, { marginStart: o, children: n })
  ] }) : /* @__PURE__ */ Ae(Vr, { children: [
    t && /* @__PURE__ */ b(Ns, { marginEnd: o, children: t }),
    r,
    n && /* @__PURE__ */ b(Ns, { marginStart: o, children: n })
  ] });
}
const A4 = {
  horizontal: {
    "> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 }
  },
  vertical: {
    "> *:first-of-type:not(:last-of-type)": { borderBottomRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderTopRadius: 0 }
  }
}, T4 = {
  horizontal: (e) => ({
    "& > *:not(style) ~ *:not(style)": { marginStart: e }
  }),
  vertical: (e) => ({
    "& > *:not(style) ~ *:not(style)": { marginTop: e }
  })
}, Fx = X(
  function(t, n) {
    const {
      size: r,
      colorScheme: o,
      variant: i,
      className: s,
      spacing: a = "0.5rem",
      isAttached: c,
      isDisabled: l,
      orientation: u = "horizontal",
      ...d
    } = t, f = oe("chakra-button__group", s), p = be(
      () => ({ size: r, colorScheme: o, variant: i, isDisabled: l }),
      [r, o, i, l]
    );
    let m = {
      display: "inline-flex",
      ...c ? A4[u] : T4[u](a)
    };
    const h = u === "vertical";
    return /* @__PURE__ */ b(w4, { value: p, children: /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        role: "group",
        __css: m,
        className: f,
        "data-attached": c ? "" : void 0,
        "data-orientation": u,
        flexDir: h ? "column" : void 0,
        ...d
      }
    ) });
  }
);
Fx.displayName = "ButtonGroup";
const cp = X(
  (e, t) => {
    const { icon: n, children: r, isRound: o, "aria-label": i, ...s } = e, a = n || r, c = ao(a) ? Lt(a, {
      "aria-hidden": !0,
      focusable: !1
    }) : null;
    return /* @__PURE__ */ b(
      bl,
      {
        px: "0",
        py: "0",
        borderRadius: o ? "full" : void 0,
        ref: t,
        "aria-label": i,
        ...s,
        children: c
      }
    );
  }
);
cp.displayName = "IconButton";
const [E4, Qh] = D1("Card"), EQ = X(function(t, n) {
  const {
    className: r,
    children: o,
    direction: i = "column",
    justify: s,
    align: a,
    ...c
  } = $e(t), l = We("Card", t);
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: n,
      className: oe("chakra-card", r),
      __css: {
        display: "flex",
        flexDirection: i,
        justifyContent: s,
        alignItems: a,
        position: "relative",
        minWidth: 0,
        wordWrap: "break-word",
        ...l.container
      },
      ...c,
      children: /* @__PURE__ */ b(E4, { value: l, children: o })
    }
  );
}), RQ = X(
  function(t, n) {
    const { className: r, ...o } = t, i = Qh();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        className: oe("chakra-card__body", r),
        __css: i.body,
        ...o
      }
    );
  }
), _Q = X(
  function(t, n) {
    const { className: r, justify: o, ...i } = t, s = Qh();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        className: oe("chakra-card__footer", r),
        __css: {
          display: "flex",
          justifyContent: o,
          ...s.footer
        },
        ...i
      }
    );
  }
), OQ = X(
  function(t, n) {
    const { className: r, ...o } = t, i = Qh();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        className: oe("chakra-card__header", r),
        __css: i.header,
        ...o
      }
    );
  }
), R4 = z("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }
});
R4.displayName = "Center";
const _4 = {
  horizontal: {
    insetStart: "50%",
    transform: "translateX(-50%)"
  },
  vertical: {
    top: "50%",
    transform: "translateY(-50%)"
  },
  both: {
    insetStart: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }
};
X(
  function(t, n) {
    const { axis: r = "both", ...o } = t;
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        __css: _4[r],
        ...o,
        position: "absolute"
      }
    );
  }
);
const [O4, N4] = De({
  name: "CheckboxGroupContext",
  strict: !1
});
function M4(e) {
  return /* @__PURE__ */ b(
    z.svg,
    {
      width: "1.2em",
      viewBox: "0 0 12 10",
      style: {
        fill: "none",
        strokeWidth: 2,
        stroke: "currentColor",
        strokeDasharray: 16
      },
      ...e,
      children: /* @__PURE__ */ b("polyline", { points: "1.5 6 4.5 9 10.5 1" })
    }
  );
}
function B4(e) {
  return /* @__PURE__ */ b(
    z.svg,
    {
      width: "1.2em",
      viewBox: "0 0 24 24",
      style: { stroke: "currentColor", strokeWidth: 4 },
      ...e,
      children: /* @__PURE__ */ b("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
    }
  );
}
function F4(e) {
  const { isIndeterminate: t, isChecked: n, ...r } = e, o = t ? B4 : M4;
  return n || t ? /* @__PURE__ */ b(
    z.div,
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%"
      },
      children: /* @__PURE__ */ b(o, { ...r })
    }
  ) : null;
}
var D4 = () => typeof document < "u", Pv = !1, Oa = null, zo = !1, lp = !1, up = /* @__PURE__ */ new Set();
function em(e, t) {
  up.forEach((n) => n(e, t));
}
var $4 = typeof window < "u" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : !1;
function V4(e) {
  return !(e.metaKey || !$4 && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function kv(e) {
  zo = !0, V4(e) && (Oa = "keyboard", em("keyboard", e));
}
function ai(e) {
  if (Oa = "pointer", e.type === "mousedown" || e.type === "pointerdown") {
    zo = !0;
    const t = e.composedPath ? e.composedPath()[0] : e.target;
    let n = !1;
    try {
      n = t.matches(":focus-visible");
    } catch {
    }
    if (n)
      return;
    em("pointer", e);
  }
}
function L4(e) {
  return e.mozInputSource === 0 && e.isTrusted ? !0 : e.detail === 0 && !e.pointerType;
}
function z4(e) {
  L4(e) && (zo = !0, Oa = "virtual");
}
function G4(e) {
  e.target === window || e.target === document || e.target instanceof Element && e.target.hasAttribute("tabindex") || (!zo && !lp && (Oa = "virtual", em("virtual", e)), zo = !1, lp = !1);
}
function W4() {
  zo = !1, lp = !0;
}
function Av() {
  return Oa !== "pointer";
}
function H4() {
  if (!D4() || Pv)
    return;
  const { focus: e } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function(...n) {
    zo = !0, e.apply(this, n);
  }, document.addEventListener("keydown", kv, !0), document.addEventListener("keyup", kv, !0), document.addEventListener("click", z4, !0), window.addEventListener("focus", G4, !0), window.addEventListener("blur", W4, !1), typeof PointerEvent < "u" ? (document.addEventListener("pointerdown", ai, !0), document.addEventListener("pointermove", ai, !0), document.addEventListener("pointerup", ai, !0)) : (document.addEventListener("mousedown", ai, !0), document.addEventListener("mousemove", ai, !0), document.addEventListener("mouseup", ai, !0)), Pv = !0;
}
function Dx(e) {
  H4(), e(Av());
  const t = () => e(Av());
  return up.add(t), () => {
    up.delete(t);
  };
}
const [j4, $x] = De({
  name: "FormControlStylesContext",
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
}), [X4, Zo] = De({
  strict: !1,
  name: "FormControlContext"
});
function Y4(e) {
  const {
    id: t,
    isRequired: n,
    isInvalid: r,
    isDisabled: o,
    isReadOnly: i,
    ...s
  } = e, a = Xt(), c = t || `field-${a}`, l = `${c}-label`, u = `${c}-feedback`, d = `${c}-helptext`, [f, p] = ue(!1), [m, h] = ue(!1), [g, v] = ue(!1), y = R(
    (I = {}, P = null) => ({
      id: d,
      ...I,
      /**
       * Notify the field context when the help text is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: Ge(P, (k) => {
        k && h(!0);
      })
    }),
    [d]
  ), x = R(
    (I = {}, P = null) => ({
      ...I,
      ref: P,
      "data-focus": ye(g),
      "data-disabled": ye(o),
      "data-invalid": ye(r),
      "data-readonly": ye(i),
      id: I.id !== void 0 ? I.id : l,
      htmlFor: I.htmlFor !== void 0 ? I.htmlFor : c
    }),
    [c, o, g, r, i, l]
  ), S = R(
    (I = {}, P = null) => ({
      id: u,
      ...I,
      /**
       * Notify the field context when the error message is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: Ge(P, (k) => {
        k && p(!0);
      }),
      "aria-live": "polite"
    }),
    [u]
  ), C = R(
    (I = {}, P = null) => ({
      ...I,
      ...s,
      ref: P,
      role: "group",
      "data-focus": ye(g),
      "data-disabled": ye(o),
      "data-invalid": ye(r),
      "data-readonly": ye(i)
    }),
    [s, o, g, r, i]
  ), w = R(
    (I = {}, P = null) => ({
      ...I,
      ref: P,
      role: "presentation",
      "aria-hidden": !0,
      children: I.children || "*"
    }),
    []
  );
  return {
    isRequired: !!n,
    isInvalid: !!r,
    isReadOnly: !!i,
    isDisabled: !!o,
    isFocused: !!g,
    onFocus: () => v(!0),
    onBlur: () => v(!1),
    hasFeedbackText: f,
    setHasFeedbackText: p,
    hasHelpText: m,
    setHasHelpText: h,
    id: c,
    labelId: l,
    feedbackId: u,
    helpTextId: d,
    htmlProps: s,
    getHelpTextProps: y,
    getErrorMessageProps: S,
    getRootProps: C,
    getLabelProps: x,
    getRequiredIndicatorProps: w
  };
}
const Vx = X(
  function(t, n) {
    const r = We("Form", t), o = $e(t), {
      getRootProps: i,
      htmlProps: s,
      ...a
    } = Y4(o), c = oe("chakra-form-control", t.className);
    return /* @__PURE__ */ b(X4, { value: a, children: /* @__PURE__ */ b(j4, { value: r, children: /* @__PURE__ */ b(
      z.div,
      {
        ...i({}, n),
        className: c,
        __css: r.container
      }
    ) }) });
  }
);
Vx.displayName = "FormControl";
const Z4 = X(
  function(t, n) {
    const r = Zo(), o = $x(), i = oe("chakra-form__helper-text", t.className);
    return /* @__PURE__ */ b(
      z.div,
      {
        ...r?.getHelpTextProps(t, n),
        __css: o.helperText,
        className: i
      }
    );
  }
);
Z4.displayName = "FormHelperText";
function as(e) {
  const { isDisabled: t, isInvalid: n, isReadOnly: r, isRequired: o, ...i } = tm(e);
  return {
    ...i,
    disabled: t,
    readOnly: r,
    required: o,
    "aria-invalid": Vt(n),
    "aria-required": Vt(o),
    "aria-readonly": Vt(r)
  };
}
function tm(e) {
  const t = Zo(), {
    id: n,
    disabled: r,
    readOnly: o,
    required: i,
    isRequired: s,
    isInvalid: a,
    isReadOnly: c,
    isDisabled: l,
    onFocus: u,
    onBlur: d,
    ...f
  } = e, p = e["aria-describedby"] ? [e["aria-describedby"]] : [];
  return t?.hasFeedbackText && t?.isInvalid && p.push(t.feedbackId), t?.hasHelpText && p.push(t.helpTextId), {
    ...f,
    "aria-describedby": p.join(" ") || void 0,
    id: n ?? t?.id,
    isDisabled: r ?? l ?? t?.isDisabled,
    isReadOnly: o ?? c ?? t?.isReadOnly,
    isRequired: i ?? s ?? t?.isRequired,
    isInvalid: a ?? t?.isInvalid,
    onFocus: fe(t?.onFocus, u),
    onBlur: fe(t?.onBlur, d)
  };
}
const pu = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
function Lx(e = {}) {
  const t = tm(e), {
    isDisabled: n,
    isReadOnly: r,
    isRequired: o,
    isInvalid: i,
    id: s,
    onBlur: a,
    onFocus: c,
    "aria-describedby": l
  } = t, {
    defaultChecked: u,
    isChecked: d,
    isFocusable: f,
    onChange: p,
    isIndeterminate: m,
    name: h,
    value: g,
    tabIndex: v = void 0,
    "aria-label": y,
    "aria-labelledby": x,
    "aria-invalid": S,
    ...C
  } = e, w = ya(C, [
    "isDisabled",
    "isReadOnly",
    "isRequired",
    "isInvalid",
    "id",
    "onBlur",
    "onFocus",
    "aria-describedby"
  ]), I = pt(p), P = pt(a), k = pt(c), [A, N] = ue(!1), [B, L] = ue(!1), [Z, ne] = ue(!1), W = se(!1);
  ge(() => Dx((re) => {
    W.current = re;
  }), []);
  const O = se(null), [J, ee] = ue(!0), [H, _] = ue(!!u), j = d !== void 0, E = j ? d : H, M = R(
    (re) => {
      if (r || n) {
        re.preventDefault();
        return;
      }
      j || _(E ? re.currentTarget.checked : m ? !0 : re.currentTarget.checked), I?.(re);
    },
    [
      r,
      n,
      E,
      j,
      m,
      I
    ]
  );
  Dn(() => {
    O.current && (O.current.indeterminate = !!m);
  }, [m]), Jn(() => {
    n && N(!1);
  }, [n, N]), Dn(() => {
    const re = O.current;
    if (!re?.form)
      return;
    const Ce = () => {
      _(!!u);
    };
    return re.form.addEventListener("reset", Ce), () => re.form?.removeEventListener("reset", Ce);
  }, []);
  const F = n && !f, G = R(
    (re) => {
      re.key === " " && ne(!0);
    },
    [ne]
  ), q = R(
    (re) => {
      re.key === " " && ne(!1);
    },
    [ne]
  );
  Dn(() => {
    if (!O.current)
      return;
    O.current.checked !== E && _(O.current.checked);
  }, [O.current]);
  const te = R(
    (re = {}, Ce = null) => {
      const Ve = (le) => {
        A && le.preventDefault(), ne(!0);
      };
      return {
        ...re,
        ref: Ce,
        "data-active": ye(Z),
        "data-hover": ye(B),
        "data-checked": ye(E),
        "data-focus": ye(A),
        "data-focus-visible": ye(A && W.current),
        "data-indeterminate": ye(m),
        "data-disabled": ye(n),
        "data-invalid": ye(i),
        "data-readonly": ye(r),
        "aria-hidden": !0,
        onMouseDown: fe(re.onMouseDown, Ve),
        onMouseUp: fe(re.onMouseUp, () => ne(!1)),
        onMouseEnter: fe(
          re.onMouseEnter,
          () => L(!0)
        ),
        onMouseLeave: fe(
          re.onMouseLeave,
          () => L(!1)
        )
      };
    },
    [
      Z,
      E,
      n,
      A,
      B,
      m,
      i,
      r
    ]
  ), U = R(
    (re = {}, Ce = null) => ({
      ...re,
      ref: Ce,
      "data-active": ye(Z),
      "data-hover": ye(B),
      "data-checked": ye(E),
      "data-focus": ye(A),
      "data-focus-visible": ye(A && W.current),
      "data-indeterminate": ye(m),
      "data-disabled": ye(n),
      "data-invalid": ye(i),
      "data-readonly": ye(r)
    }),
    [
      Z,
      E,
      n,
      A,
      B,
      m,
      i,
      r
    ]
  ), K = R(
    (re = {}, Ce = null) => ({
      ...w,
      ...re,
      ref: Ge(Ce, (Ve) => {
        Ve && ee(Ve.tagName === "LABEL");
      }),
      onClick: fe(re.onClick, () => {
        J || (O.current?.click(), requestAnimationFrame(() => {
          O.current?.focus({ preventScroll: !0 });
        }));
      }),
      "data-disabled": ye(n),
      "data-checked": ye(E),
      "data-invalid": ye(i)
    }),
    [w, n, E, i, J]
  ), ae = R(
    (re = {}, Ce = null) => ({
      ...re,
      ref: Ge(O, Ce),
      type: "checkbox",
      name: h,
      value: g,
      id: s,
      tabIndex: v,
      onChange: fe(re.onChange, M),
      onBlur: fe(
        re.onBlur,
        P,
        () => N(!1)
      ),
      onFocus: fe(
        re.onFocus,
        k,
        () => N(!0)
      ),
      onKeyDown: fe(re.onKeyDown, G),
      onKeyUp: fe(re.onKeyUp, q),
      required: o,
      checked: E,
      disabled: F,
      readOnly: r,
      "aria-label": y,
      "aria-labelledby": x,
      "aria-invalid": S ? !!S : i,
      "aria-describedby": l,
      "aria-disabled": n,
      "aria-checked": m ? "mixed" : E,
      style: pu
    }),
    [
      h,
      g,
      s,
      v,
      M,
      P,
      k,
      G,
      q,
      o,
      E,
      F,
      r,
      y,
      x,
      S,
      i,
      l,
      n,
      m
    ]
  ), Y = R(
    (re = {}, Ce = null) => ({
      ...re,
      ref: Ce,
      onMouseDown: fe(re.onMouseDown, U4),
      "data-disabled": ye(n),
      "data-checked": ye(E),
      "data-invalid": ye(i)
    }),
    [E, n, i]
  );
  return {
    state: {
      isInvalid: i,
      isFocused: A,
      isChecked: E,
      isActive: Z,
      isHovered: B,
      isIndeterminate: m,
      isDisabled: n,
      isReadOnly: r,
      isRequired: o
    },
    getRootProps: K,
    getCheckboxProps: te,
    getIndicatorProps: U,
    getInputProps: ae,
    getLabelProps: Y,
    htmlProps: w
  };
}
function U4(e) {
  e.preventDefault(), e.stopPropagation();
}
function J4(e) {
  const [t, n] = ue(e), [r, o] = ue(!1);
  return e !== t && (o(!0), n(e)), r;
}
const K4 = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  verticalAlign: "top",
  userSelect: "none",
  flexShrink: 0
}, q4 = {
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "top",
  position: "relative"
}, Q4 = An({
  from: {
    opacity: 0,
    strokeDashoffset: 16,
    transform: "scale(0.95)"
  },
  to: {
    opacity: 1,
    strokeDashoffset: 0,
    transform: "scale(1)"
  }
}), eL = An({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
}), tL = An({
  from: {
    transform: "scaleX(0.65)"
  },
  to: {
    transform: "scaleX(1)"
  }
}), nL = X(
  function(t, n) {
    const r = N4(), o = { ...r, ...t }, i = We("Checkbox", o), s = $e(t), {
      spacing: a = "0.5rem",
      className: c,
      children: l,
      iconColor: u,
      iconSize: d,
      icon: f = /* @__PURE__ */ b(F4, {}),
      isChecked: p,
      isDisabled: m = r?.isDisabled,
      onChange: h,
      inputProps: g,
      ...v
    } = s;
    let y = p;
    r?.value && s.value && (y = r.value.includes(s.value));
    let x = h;
    r?.onChange && s.value && (x = Gl(r.onChange, h));
    const {
      state: S,
      getInputProps: C,
      getCheckboxProps: w,
      getLabelProps: I,
      getRootProps: P
    } = Lx({
      ...v,
      isDisabled: m,
      isChecked: y,
      onChange: x
    }), k = J4(S.isChecked), A = be(
      () => ({
        animation: k ? S.isIndeterminate ? `${eL} 20ms linear, ${tL} 200ms linear` : `${Q4} 200ms linear` : void 0,
        ...i.icon,
        ...is({
          fontSize: d,
          color: u
        })
      }),
      [u, d, k, S.isIndeterminate, i.icon]
    ), N = Lt(f, {
      __css: A,
      isIndeterminate: S.isIndeterminate,
      isChecked: S.isChecked
    });
    return /* @__PURE__ */ Ae(
      z.label,
      {
        __css: { ...q4, ...i.container },
        className: oe("chakra-checkbox", c),
        ...P(),
        children: [
          /* @__PURE__ */ b(
            "input",
            {
              className: "chakra-checkbox__input",
              ...C(g, n)
            }
          ),
          /* @__PURE__ */ b(
            z.span,
            {
              __css: { ...K4, ...i.control },
              className: "chakra-checkbox__control",
              ...w(),
              children: N
            }
          ),
          l && /* @__PURE__ */ b(
            z.span,
            {
              className: "chakra-checkbox__label",
              ...I(),
              __css: {
                marginStart: a,
                ...i.label
              },
              children: l
            }
          )
        ]
      }
    );
  }
);
nL.displayName = "Checkbox";
function Tv(e) {
  return e && Mt(e) && Mt(e.target);
}
function rL(e = {}) {
  const {
    defaultValue: t,
    value: n,
    onChange: r,
    isDisabled: o,
    isNative: i
  } = e, s = pt(r), [a, c] = co({
    value: n,
    defaultValue: t || [],
    onChange: s
  }), l = R(
    (d) => {
      if (!a)
        return;
      const f = Tv(d) ? d.target.checked : !a.includes(d), p = Tv(d) ? d.target.value : d, m = f ? [...a, p] : a.filter((h) => String(h) !== String(p));
      c(m);
    },
    [c, a]
  ), u = R(
    (d = {}) => ({
      ...d,
      [i ? "checked" : "isChecked"]: a.some((p) => String(d.value) === String(p)),
      onChange: l
    }),
    [l, i, a]
  );
  return {
    value: a,
    isDisabled: o,
    onChange: l,
    setValue: c,
    getCheckboxProps: u
  };
}
function oL(e) {
  const { colorScheme: t, size: n, variant: r, children: o, isDisabled: i } = e, { value: s, onChange: a } = rL(e), c = be(
    () => ({
      size: n,
      onChange: a,
      colorScheme: t,
      value: s,
      variant: r,
      isDisabled: i
    }),
    [n, a, t, s, r, i]
  );
  return /* @__PURE__ */ b(O4, { value: c, children: o });
}
oL.displayName = "CheckboxGroup";
const iL = X(function(t, n) {
  const r = Gt("Code", t), { className: o, ...i } = $e(t);
  return /* @__PURE__ */ b(
    z.code,
    {
      ref: n,
      className: oe("chakra-code", t.className),
      ...i,
      __css: {
        display: "inline-block",
        ...r
      }
    }
  );
});
iL.displayName = "Code";
const sL = X(
  function(t, n) {
    const { className: r, centerContent: o, ...i } = $e(t), s = Gt("Container", t);
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        className: oe("chakra-container", r),
        ...i,
        __css: {
          ...s,
          ...o && {
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
          }
        }
      }
    );
  }
);
sL.displayName = "Container";
const zx = X(
  function(t, n) {
    const {
      borderLeftWidth: r,
      borderBottomWidth: o,
      borderTopWidth: i,
      borderRightWidth: s,
      borderWidth: a,
      borderStyle: c,
      borderColor: l,
      ...u
    } = Gt("Divider", t), {
      className: d,
      orientation: f = "horizontal",
      __css: p,
      ...m
    } = $e(t), h = {
      vertical: {
        borderLeftWidth: r || s || a || "1px",
        height: "100%"
      },
      horizontal: {
        borderBottomWidth: o || i || a || "1px",
        width: "100%"
      }
    };
    return /* @__PURE__ */ b(
      z.hr,
      {
        ref: n,
        "aria-orientation": f,
        ...m,
        __css: {
          ...u,
          border: "0",
          borderColor: l,
          borderStyle: c,
          ...h[f],
          ...p
        },
        className: oe("chakra-divider", d)
      }
    );
  }
);
zx.displayName = "Divider";
const [aL, nm] = De({
  name: "EditableStylesContext",
  errorMessage: `useEditableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Editable />" `
}), [cL, hu] = De({
  name: "EditableContext",
  errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
});
function Ev(e, t) {
  return e ? e === t || e.contains(t) : !1;
}
function lL(e = {}) {
  const {
    onChange: t,
    onCancel: n,
    onSubmit: r,
    onBlur: o,
    value: i,
    isDisabled: s,
    defaultValue: a,
    startWithEditView: c,
    isPreviewFocusable: l = !0,
    submitOnBlur: u = !0,
    selectAllOnFocus: d = !0,
    placeholder: f,
    onEdit: p,
    finalFocusRef: m,
    ...h
  } = e, g = pt(p), v = !!(c && !s), [y, x] = ue(v), [S, C] = co({
    defaultValue: a || "",
    value: i,
    onChange: t
  }), [w, I] = ue(S), P = se(null), k = se(null), A = se(null), N = se(null), B = se(null);
  Y0({
    ref: P,
    enabled: y,
    elements: [N, B]
  });
  const L = !y && !s;
  Dn(() => {
    y && (P.current?.focus(), d && P.current?.select());
  }, []), Jn(() => {
    if (!y) {
      m ? m.current?.focus() : A.current?.focus();
      return;
    }
    P.current?.focus(), d && P.current?.select(), g?.();
  }, [y, g, d]);
  const Z = R(() => {
    L && x(!0);
  }, [L]), ne = R(() => {
    I(S);
  }, [S]), W = R(() => {
    x(!1), C(w), n?.(w), o?.(w);
  }, [n, o, C, w]), O = R(() => {
    x(!1), I(S), r?.(S), o?.(w);
  }, [S, r, o, w]);
  ge(() => {
    if (y)
      return;
    const U = P.current;
    U?.ownerDocument.activeElement === U && U?.blur();
  }, [y]);
  const J = R(
    (U) => {
      C(U.currentTarget.value);
    },
    [C]
  ), ee = R(
    (U) => {
      const K = U.key, Y = {
        Escape: W,
        Enter: (ce) => {
          !ce.shiftKey && !ce.metaKey && O();
        }
      }[K];
      Y && (U.preventDefault(), Y(U));
    },
    [W, O]
  ), H = R(
    (U) => {
      const K = U.key, Y = {
        Escape: W
      }[K];
      Y && (U.preventDefault(), Y(U));
    },
    [W]
  ), _ = S.length === 0, j = R(
    (U) => {
      if (!y)
        return;
      const K = U.currentTarget.ownerDocument, ae = U.relatedTarget ?? K.activeElement, Y = Ev(N.current, ae), ce = Ev(B.current, ae);
      !Y && !ce && (u ? O() : W());
    },
    [u, O, W, y]
  ), E = R(
    (U = {}, K = null) => {
      const ae = L && l ? 0 : void 0;
      return {
        ...U,
        ref: Ge(K, k),
        children: _ ? f : S,
        hidden: y,
        "aria-disabled": Vt(s),
        tabIndex: ae,
        onFocus: fe(U.onFocus, Z, ne)
      };
    },
    [
      s,
      y,
      L,
      l,
      _,
      Z,
      ne,
      f,
      S
    ]
  ), M = R(
    (U = {}, K = null) => ({
      ...U,
      hidden: !y,
      placeholder: f,
      ref: Ge(K, P),
      disabled: s,
      "aria-disabled": Vt(s),
      value: S,
      onBlur: fe(U.onBlur, j),
      onChange: fe(U.onChange, J),
      onKeyDown: fe(U.onKeyDown, ee),
      onFocus: fe(U.onFocus, ne)
    }),
    [
      s,
      y,
      j,
      J,
      ee,
      ne,
      f,
      S
    ]
  ), F = R(
    (U = {}, K = null) => ({
      ...U,
      hidden: !y,
      placeholder: f,
      ref: Ge(K, P),
      disabled: s,
      "aria-disabled": Vt(s),
      value: S,
      onBlur: fe(U.onBlur, j),
      onChange: fe(U.onChange, J),
      onKeyDown: fe(U.onKeyDown, H),
      onFocus: fe(U.onFocus, ne)
    }),
    [
      s,
      y,
      j,
      J,
      H,
      ne,
      f,
      S
    ]
  ), G = R(
    (U = {}, K = null) => ({
      "aria-label": "Edit",
      ...U,
      type: "button",
      onClick: fe(U.onClick, Z),
      ref: Ge(K, A),
      disabled: s
    }),
    [Z, s]
  ), q = R(
    (U = {}, K = null) => ({
      ...U,
      "aria-label": "Submit",
      ref: Ge(B, K),
      type: "button",
      onClick: fe(U.onClick, O),
      disabled: s
    }),
    [O, s]
  ), te = R(
    (U = {}, K = null) => ({
      "aria-label": "Cancel",
      id: "cancel",
      ...U,
      ref: Ge(N, K),
      type: "button",
      onClick: fe(U.onClick, W),
      disabled: s
    }),
    [W, s]
  );
  return {
    isEditing: y,
    isDisabled: s,
    isValueEmpty: _,
    value: S,
    onEdit: Z,
    onCancel: W,
    onSubmit: O,
    getPreviewProps: E,
    getInputProps: M,
    getTextareaProps: F,
    getEditButtonProps: G,
    getSubmitButtonProps: q,
    getCancelButtonProps: te,
    htmlProps: h
  };
}
const uL = X(
  function(t, n) {
    const r = We("Editable", t), o = $e(t), { htmlProps: i, ...s } = lL(o), { isEditing: a, onSubmit: c, onCancel: l, onEdit: u } = s, d = oe("chakra-editable", t.className), f = jt(t.children, {
      isEditing: a,
      onSubmit: c,
      onCancel: l,
      onEdit: u
    });
    return /* @__PURE__ */ b(cL, { value: s, children: /* @__PURE__ */ b(aL, { value: r, children: /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        ...i,
        className: d,
        children: f
      }
    ) }) });
  }
);
uL.displayName = "Editable";
const rm = {
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent"
}, dL = X(
  function(t, n) {
    const { getInputProps: r } = hu(), o = nm(), i = r(t, n), s = oe("chakra-editable__input", t.className);
    return /* @__PURE__ */ b(
      z.input,
      {
        ...i,
        __css: {
          outline: 0,
          ...rm,
          ...o.input
        },
        className: s
      }
    );
  }
);
dL.displayName = "EditableInput";
const fL = X(
  function(t, n) {
    const { getPreviewProps: r } = hu(), o = nm(), i = r(t, n), s = oe("chakra-editable__preview", t.className);
    return /* @__PURE__ */ b(
      z.span,
      {
        ...i,
        __css: {
          cursor: "text",
          display: "inline-block",
          ...rm,
          ...o.preview
        },
        className: s
      }
    );
  }
);
fL.displayName = "EditablePreview";
const pL = X(
  function(t, n) {
    const { getTextareaProps: r } = hu(), o = nm(), i = r(t, n), s = oe("chakra-editable__textarea", t.className);
    return /* @__PURE__ */ b(
      z.textarea,
      {
        ...i,
        __css: {
          outline: 0,
          ...rm,
          ...o.textarea
        },
        className: s
      }
    );
  }
);
pL.displayName = "EditableTextarea";
function NQ() {
  const {
    isEditing: e,
    getEditButtonProps: t,
    getCancelButtonProps: n,
    getSubmitButtonProps: r
  } = hu();
  return {
    isEditing: e,
    getEditButtonProps: t,
    getCancelButtonProps: n,
    getSubmitButtonProps: r
  };
}
function Ms(e) {
  return typeof e == "function";
}
function hL(...e) {
  return (t) => e.reduce((n, r) => r(n), t);
}
const mL = (e) => function(...n) {
  let r = [...n], o = n[n.length - 1];
  return NM(o) && // this ensures backward compatibility
  // previously only `extendTheme(override, activeTheme?)` was allowed
  r.length > 1 ? r = r.slice(0, r.length - 1) : o = e, hL(
    ...r.map(
      (i) => (s) => Ms(i) ? i(s) : gL(s, i)
    )
  )(o);
}, MQ = mL(dh);
function gL(...e) {
  return Ot({}, ...e, Gx);
}
function Gx(e, t, n, r) {
  if ((Ms(e) || Ms(t)) && Object.prototype.hasOwnProperty.call(r, n))
    return (...o) => {
      const i = Ms(e) ? e(...o) : e, s = Ms(t) ? t(...o) : t;
      return Ot({}, i, s, Gx);
    };
  if (Mt(e) && Tf(t) || Tf(e) && Mt(t))
    return t;
}
const Pi = X(function(t, n) {
  const { direction: r, align: o, justify: i, wrap: s, basis: a, grow: c, shrink: l, ...u } = t, d = {
    display: "flex",
    flexDirection: r,
    alignItems: o,
    justifyContent: i,
    flexWrap: s,
    flexBasis: a,
    flexGrow: c,
    flexShrink: l
  };
  return /* @__PURE__ */ b(z.div, { ref: n, __css: d, ...u });
});
Pi.displayName = "Flex";
function Wx(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
var ac = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Hd, Rv;
function bL() {
  if (Rv) return Hd;
  Rv = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(s).map(function(u) {
        return s[u];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        l[u] = u;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Hd = o() ? Object.assign : function(i, s) {
    for (var a, c = r(i), l, u = 1; u < arguments.length; u++) {
      a = Object(arguments[u]);
      for (var d in a)
        t.call(a, d) && (c[d] = a[d]);
      if (e) {
        l = e(a);
        for (var f = 0; f < l.length; f++)
          n.call(a, l[f]) && (c[l[f]] = a[l[f]]);
      }
    }
    return c;
  }, Hd;
}
var jd, _v;
function om() {
  if (_v) return jd;
  _v = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jd = e, jd;
}
var Xd, Ov;
function Hx() {
  return Ov || (Ov = 1, Xd = Function.call.bind(Object.prototype.hasOwnProperty)), Xd;
}
var Yd, Nv;
function vL() {
  if (Nv) return Yd;
  Nv = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ om(), n = {}, r = /* @__PURE__ */ Hx();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in i)
        if (r(i, u)) {
          var d;
          try {
            if (typeof i[u] != "function") {
              var f = Error(
                (c || "React class") + ": " + a + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            d = i[u](s, u, c, a, null, t);
          } catch (m) {
            d = m;
          }
          if (d && !(d instanceof Error) && e(
            (c || "React class") + ": type specification of " + a + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var p = l ? l() : "";
            e(
              "Failed " + a + " type: " + d.message + (p ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Yd = o, Yd;
}
var Zd, Mv;
function yL() {
  if (Mv) return Zd;
  Mv = 1;
  var e = mh(), t = bL(), n = /* @__PURE__ */ om(), r = /* @__PURE__ */ Hx(), o = /* @__PURE__ */ vL(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var c = "Warning: " + a;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Zd = function(a, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function d(H) {
      var _ = H && (l && H[l] || H[u]);
      if (typeof _ == "function")
        return _;
    }
    var f = "<<anonymous>>", p = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: y(),
      arrayOf: x,
      element: S(),
      elementType: C(),
      instanceOf: w,
      node: A(),
      objectOf: P,
      oneOf: I,
      oneOfType: k,
      shape: B,
      exact: L
    };
    function m(H, _) {
      return H === _ ? H !== 0 || 1 / H === 1 / _ : H !== H && _ !== _;
    }
    function h(H, _) {
      this.message = H, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function g(H) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, j = 0;
      function E(F, G, q, te, U, K, ae) {
        if (te = te || f, K = K || q, ae !== n) {
          if (c) {
            var Y = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Y.name = "Invariant Violation", Y;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ce = te + ":" + q;
            !_[ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            j < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + K + "` prop on `" + te + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ce] = !0, j++);
          }
        }
        return G[q] == null ? F ? G[q] === null ? new h("The " + U + " `" + K + "` is marked as required " + ("in `" + te + "`, but its value is `null`.")) : new h("The " + U + " `" + K + "` is marked as required in " + ("`" + te + "`, but its value is `undefined`.")) : null : H(G, q, te, U, K);
      }
      var M = E.bind(null, !1);
      return M.isRequired = E.bind(null, !0), M;
    }
    function v(H) {
      function _(j, E, M, F, G, q) {
        var te = j[E], U = W(te);
        if (U !== H) {
          var K = O(te);
          return new h(
            "Invalid " + F + " `" + G + "` of type " + ("`" + K + "` supplied to `" + M + "`, expected ") + ("`" + H + "`."),
            { expectedType: H }
          );
        }
        return null;
      }
      return g(_);
    }
    function y() {
      return g(s);
    }
    function x(H) {
      function _(j, E, M, F, G) {
        if (typeof H != "function")
          return new h("Property `" + G + "` of component `" + M + "` has invalid PropType notation inside arrayOf.");
        var q = j[E];
        if (!Array.isArray(q)) {
          var te = W(q);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + te + "` supplied to `" + M + "`, expected an array."));
        }
        for (var U = 0; U < q.length; U++) {
          var K = H(q, U, M, F, G + "[" + U + "]", n);
          if (K instanceof Error)
            return K;
        }
        return null;
      }
      return g(_);
    }
    function S() {
      function H(_, j, E, M, F) {
        var G = _[j];
        if (!a(G)) {
          var q = W(G);
          return new h("Invalid " + M + " `" + F + "` of type " + ("`" + q + "` supplied to `" + E + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(H);
    }
    function C() {
      function H(_, j, E, M, F) {
        var G = _[j];
        if (!e.isValidElementType(G)) {
          var q = W(G);
          return new h("Invalid " + M + " `" + F + "` of type " + ("`" + q + "` supplied to `" + E + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(H);
    }
    function w(H) {
      function _(j, E, M, F, G) {
        if (!(j[E] instanceof H)) {
          var q = H.name || f, te = ee(j[E]);
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + te + "` supplied to `" + M + "`, expected ") + ("instance of `" + q + "`."));
        }
        return null;
      }
      return g(_);
    }
    function I(H) {
      if (!Array.isArray(H))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function _(j, E, M, F, G) {
        for (var q = j[E], te = 0; te < H.length; te++)
          if (m(q, H[te]))
            return null;
        var U = JSON.stringify(H, function(ae, Y) {
          var ce = O(Y);
          return ce === "symbol" ? String(Y) : Y;
        });
        return new h("Invalid " + F + " `" + G + "` of value `" + String(q) + "` " + ("supplied to `" + M + "`, expected one of " + U + "."));
      }
      return g(_);
    }
    function P(H) {
      function _(j, E, M, F, G) {
        if (typeof H != "function")
          return new h("Property `" + G + "` of component `" + M + "` has invalid PropType notation inside objectOf.");
        var q = j[E], te = W(q);
        if (te !== "object")
          return new h("Invalid " + F + " `" + G + "` of type " + ("`" + te + "` supplied to `" + M + "`, expected an object."));
        for (var U in q)
          if (r(q, U)) {
            var K = H(q, U, M, F, G + "." + U, n);
            if (K instanceof Error)
              return K;
          }
        return null;
      }
      return g(_);
    }
    function k(H) {
      if (!Array.isArray(H))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var _ = 0; _ < H.length; _++) {
        var j = H[_];
        if (typeof j != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(j) + " at index " + _ + "."
          ), s;
      }
      function E(M, F, G, q, te) {
        for (var U = [], K = 0; K < H.length; K++) {
          var ae = H[K], Y = ae(M, F, G, q, te, n);
          if (Y == null)
            return null;
          Y.data && r(Y.data, "expectedType") && U.push(Y.data.expectedType);
        }
        var ce = U.length > 0 ? ", expected one of type [" + U.join(", ") + "]" : "";
        return new h("Invalid " + q + " `" + te + "` supplied to " + ("`" + G + "`" + ce + "."));
      }
      return g(E);
    }
    function A() {
      function H(_, j, E, M, F) {
        return Z(_[j]) ? null : new h("Invalid " + M + " `" + F + "` supplied to " + ("`" + E + "`, expected a ReactNode."));
      }
      return g(H);
    }
    function N(H, _, j, E, M) {
      return new h(
        (H || "React class") + ": " + _ + " type `" + j + "." + E + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + M + "`."
      );
    }
    function B(H) {
      function _(j, E, M, F, G) {
        var q = j[E], te = W(q);
        if (te !== "object")
          return new h("Invalid " + F + " `" + G + "` of type `" + te + "` " + ("supplied to `" + M + "`, expected `object`."));
        for (var U in H) {
          var K = H[U];
          if (typeof K != "function")
            return N(M, F, G, U, O(K));
          var ae = K(q, U, M, F, G + "." + U, n);
          if (ae)
            return ae;
        }
        return null;
      }
      return g(_);
    }
    function L(H) {
      function _(j, E, M, F, G) {
        var q = j[E], te = W(q);
        if (te !== "object")
          return new h("Invalid " + F + " `" + G + "` of type `" + te + "` " + ("supplied to `" + M + "`, expected `object`."));
        var U = t({}, j[E], H);
        for (var K in U) {
          var ae = H[K];
          if (r(H, K) && typeof ae != "function")
            return N(M, F, G, K, O(ae));
          if (!ae)
            return new h(
              "Invalid " + F + " `" + G + "` key `" + K + "` supplied to `" + M + "`.\nBad object: " + JSON.stringify(j[E], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(H), null, "  ")
            );
          var Y = ae(q, K, M, F, G + "." + K, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return g(_);
    }
    function Z(H) {
      switch (typeof H) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !H;
        case "object":
          if (Array.isArray(H))
            return H.every(Z);
          if (H === null || a(H))
            return !0;
          var _ = d(H);
          if (_) {
            var j = _.call(H), E;
            if (_ !== H.entries) {
              for (; !(E = j.next()).done; )
                if (!Z(E.value))
                  return !1;
            } else
              for (; !(E = j.next()).done; ) {
                var M = E.value;
                if (M && !Z(M[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function ne(H, _) {
      return H === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function W(H) {
      var _ = typeof H;
      return Array.isArray(H) ? "array" : H instanceof RegExp ? "object" : ne(_, H) ? "symbol" : _;
    }
    function O(H) {
      if (typeof H > "u" || H === null)
        return "" + H;
      var _ = W(H);
      if (_ === "object") {
        if (H instanceof Date)
          return "date";
        if (H instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function J(H) {
      var _ = O(H);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function ee(H) {
      return !H.constructor || !H.constructor.name ? f : H.constructor.name;
    }
    return p.checkPropTypes = o, p.resetWarningCache = o.resetWarningCache, p.PropTypes = p, p;
  }, Zd;
}
var Ud, Bv;
function SL() {
  if (Bv) return Ud;
  Bv = 1;
  var e = /* @__PURE__ */ om();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Ud = function() {
    function r(s, a, c, l, u, d) {
      if (d !== e) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Ud;
}
var Fv;
function xL() {
  if (Fv) return ac.exports;
  if (Fv = 1, process.env.NODE_ENV !== "production") {
    var e = mh(), t = !0;
    ac.exports = /* @__PURE__ */ yL()(e.isElement, t);
  } else
    ac.exports = /* @__PURE__ */ SL()();
  return ac.exports;
}
var ft = /* @__PURE__ */ xL();
const jx = /* @__PURE__ */ Wl(ft);
var dp = "data-focus-lock", Xx = "data-focus-lock-disabled", CL = "data-no-focus-lock", IL = "data-autofocus-inside", wL = "data-no-autofocus";
function Jd(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function PL(e, t) {
  var n = ue(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var kL = typeof window < "u" ? ie.useLayoutEffect : ie.useEffect, Dv = /* @__PURE__ */ new WeakMap();
function Yx(e, t) {
  var n = PL(null, function(r) {
    return e.forEach(function(o) {
      return Jd(o, r);
    });
  });
  return kL(function() {
    var r = Dv.get(n);
    if (r) {
      var o = new Set(r), i = new Set(e), s = n.current;
      o.forEach(function(a) {
        i.has(a) || Jd(a, null);
      }), i.forEach(function(a) {
        o.has(a) || Jd(a, s);
      });
    }
    Dv.set(n, e);
  }, [e]), n;
}
var Kd = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
process.env.NODE_ENV !== "production" && jx.node;
var dr = function() {
  return dr = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, dr.apply(this, arguments);
};
function Zx(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function AL(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, i; r < o; r++)
    (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
}
function Ux(e) {
  return e;
}
function Jx(e, t) {
  t === void 0 && (t = Ux);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(i) {
      var s = t(i, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(i);
      }
      n = {
        push: function(a) {
          return i(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(i), s = n;
      }
      var c = function() {
        var u = s;
        s = [], u.forEach(i);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(u) {
          s.push(u), l();
        },
        filter: function(u) {
          return s = s.filter(u), n;
        }
      };
    }
  };
  return o;
}
function im(e, t) {
  return t === void 0 && (t = Ux), Jx(e, t);
}
function Kx(e) {
  e === void 0 && (e = {});
  var t = Jx(null);
  return t.options = dr({ async: !0, ssr: !1 }, e), t;
}
var qx = function(e) {
  var t = e.sideCar, n = Zx(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return ie.createElement(r, dr({}, n));
};
qx.isSideCarExport = !0;
function TL(e, t) {
  return e.useMedium(t), qx;
}
var Qx = im({}, function(e) {
  var t = e.target, n = e.currentTarget;
  return {
    target: t,
    currentTarget: n
  };
}), eC = im(), EL = im(), RL = Kx({
  async: !0,
  ssr: typeof document < "u"
}), _L = /* @__PURE__ */ an(void 0), OL = [], sm = /* @__PURE__ */ _t(function(t, n) {
  var r, o = ue(), i = o[0], s = o[1], a = se(), c = se(!1), l = se(null), u = ue({}), d = u[1], f = t.children, p = t.disabled, m = p === void 0 ? !1 : p, h = t.noFocusGuards, g = h === void 0 ? !1 : h, v = t.persistentFocus, y = v === void 0 ? !1 : v, x = t.crossFrame, S = x === void 0 ? !0 : x, C = t.autoFocus, w = C === void 0 ? !0 : C, I = t.allowTextSelection, P = t.group, k = t.className, A = t.whiteList, N = t.hasPositiveIndices, B = t.shards, L = B === void 0 ? OL : B, Z = t.as, ne = Z === void 0 ? "div" : Z, W = t.lockProps, O = W === void 0 ? {} : W, J = t.sideCar, ee = t.returnFocus, H = ee === void 0 ? !1 : ee, _ = t.focusOptions, j = t.onActivation, E = t.onDeactivation, M = ue({}), F = M[0], G = R(function(le) {
    var Pe = le.captureFocusRestore;
    if (!l.current) {
      var ve, he = (ve = document) == null ? void 0 : ve.activeElement;
      l.current = he, he !== document.body && (l.current = Pe(he));
    }
    a.current && j && j(a.current), c.current = !0, d();
  }, [j]), q = R(function() {
    c.current = !1, E && E(a.current), d();
  }, [E]), te = R(function(le) {
    var Pe = l.current;
    if (Pe) {
      var ve = (typeof Pe == "function" ? Pe() : Pe) || document.body, he = typeof H == "function" ? H(ve) : H;
      if (he) {
        var _e = typeof he == "object" ? he : void 0;
        l.current = null, le ? Promise.resolve().then(function() {
          return ve.focus(_e);
        }) : ve.focus(_e);
      }
    }
  }, [H]), U = R(function(le) {
    c.current && Qx.useMedium(le);
  }, []), K = eC.useMedium, ae = R(function(le) {
    a.current !== le && (a.current = le, s(le));
  }, []);
  process.env.NODE_ENV !== "production" && (typeof I < "u" && console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default"), ge(function() {
    !a.current && typeof ne != "string" && console.error("FocusLock: could not obtain ref to internal node");
  }, []));
  var Y = Ie((r = {}, r[Xx] = m && "disabled", r[dp] = P, r), O), ce = g !== !0, re = ce && g !== "tail", Ce = Yx([n, ae]), Ve = be(function() {
    return {
      observed: a,
      shards: L,
      enabled: !m,
      active: c.current
    };
  }, [m, c.current, L, i]);
  return /* @__PURE__ */ At.createElement(Hi, null, ce && [
    /* @__PURE__ */ At.createElement("div", {
      key: "guard-first",
      "data-focus-guard": !0,
      tabIndex: m ? -1 : 0,
      style: Kd
    }),
    N ? /* @__PURE__ */ At.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": !0,
      tabIndex: m ? -1 : 1,
      style: Kd
    }) : null
  ], !m && /* @__PURE__ */ At.createElement(J, {
    id: F,
    sideCar: RL,
    observed: i,
    disabled: m,
    persistentFocus: y,
    crossFrame: S,
    autoFocus: w,
    whiteList: A,
    shards: L,
    onActivation: G,
    onDeactivation: q,
    returnFocus: te,
    focusOptions: _,
    noFocusGuards: g
  }), /* @__PURE__ */ At.createElement(ne, Ie({
    ref: Ce
  }, Y, {
    className: k,
    onBlur: K,
    onFocus: U
  }), /* @__PURE__ */ At.createElement(_L.Provider, {
    value: Ve
  }, f)), re && /* @__PURE__ */ At.createElement("div", {
    "data-focus-guard": !0,
    tabIndex: m ? -1 : 0,
    style: Kd
  }));
});
sm.propTypes = process.env.NODE_ENV !== "production" ? {
  children: ft.node,
  disabled: ft.bool,
  returnFocus: ft.oneOfType([ft.bool, ft.object, ft.func]),
  focusOptions: ft.object,
  noFocusGuards: ft.bool,
  hasPositiveIndices: ft.bool,
  allowTextSelection: ft.bool,
  autoFocus: ft.bool,
  persistentFocus: ft.bool,
  crossFrame: ft.bool,
  group: ft.string,
  className: ft.string,
  whiteList: ft.func,
  shards: ft.arrayOf(ft.any),
  as: ft.oneOfType([ft.string, ft.func, ft.object]),
  lockProps: ft.object,
  onActivation: ft.func,
  onDeactivation: ft.func,
  sideCar: ft.any.isRequired
} : {};
function vl(e, t) {
  return vl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, vl(e, t);
}
function NL(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, vl(e, t);
}
function Go(e) {
  "@babel/helpers - typeof";
  return Go = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Go(e);
}
function ML(e, t) {
  if (Go(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Go(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tC(e) {
  var t = ML(e, "string");
  return Go(t) == "symbol" ? t : t + "";
}
function Ao(e, t, n) {
  return (t = tC(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function BL(e, t) {
  if (process.env.NODE_ENV !== "production") {
    if (typeof e != "function")
      throw new Error("Expected reducePropsToState to be a function.");
    if (typeof t != "function")
      throw new Error("Expected handleStateChangeOnClient to be a function.");
  }
  function n(r) {
    return r.displayName || r.name || "Component";
  }
  return function(o) {
    if (process.env.NODE_ENV !== "production" && typeof o != "function")
      throw new Error("Expected WrappedComponent to be a React component.");
    var i = [], s;
    function a() {
      s = e(i.map(function(l) {
        return l.props;
      })), t(s);
    }
    var c = /* @__PURE__ */ (function(l) {
      NL(u, l);
      function u() {
        return l.apply(this, arguments) || this;
      }
      u.peek = function() {
        return s;
      };
      var d = u.prototype;
      return d.componentDidMount = function() {
        i.push(this), a();
      }, d.componentDidUpdate = function() {
        a();
      }, d.componentWillUnmount = function() {
        var p = i.indexOf(this);
        i.splice(p, 1), a();
      }, d.render = function() {
        return /* @__PURE__ */ At.createElement(o, this.props);
      }, u;
    })(eA);
    return Ao(c, "displayName", "SideEffect(" + n(o) + ")"), c;
  };
}
var xr = function(e) {
  for (var t = Array(e.length), n = 0; n < e.length; ++n)
    t[n] = e[n];
  return t;
}, Wo = function(e) {
  return Array.isArray(e) ? e : [e];
}, nC = function(e) {
  return Array.isArray(e) ? e[0] : e;
}, FL = function(e) {
  if (e.nodeType !== Node.ELEMENT_NODE)
    return !1;
  var t = window.getComputedStyle(e, null);
  return !t || !t.getPropertyValue ? !1 : t.getPropertyValue("display") === "none" || t.getPropertyValue("visibility") === "hidden";
}, rC = function(e) {
  return e.parentNode && e.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.parentNode.host
  ) : e.parentNode;
}, oC = function(e) {
  return e === document || e && e.nodeType === Node.DOCUMENT_NODE;
}, DL = function(e) {
  return e.hasAttribute("inert");
}, $L = function(e, t) {
  return !e || oC(e) || !FL(e) && !DL(e) && t(rC(e));
}, iC = function(e, t) {
  var n = e.get(t);
  if (n !== void 0)
    return n;
  var r = $L(t, iC.bind(void 0, e));
  return e.set(t, r), r;
}, VL = function(e, t) {
  return e && !oC(e) ? GL(e) ? t(rC(e)) : !1 : !0;
}, sC = function(e, t) {
  var n = e.get(t);
  if (n !== void 0)
    return n;
  var r = VL(t, sC.bind(void 0, e));
  return e.set(t, r), r;
}, aC = function(e) {
  return e.dataset;
}, LL = function(e) {
  return e.tagName === "BUTTON";
}, cC = function(e) {
  return e.tagName === "INPUT";
}, lC = function(e) {
  return cC(e) && e.type === "radio";
}, zL = function(e) {
  return !((cC(e) || LL(e)) && (e.type === "hidden" || e.disabled));
}, GL = function(e) {
  var t = e.getAttribute(wL);
  return ![!0, "true", ""].includes(t);
}, am = function(e) {
  var t;
  return !!(e && (!((t = aC(e)) === null || t === void 0) && t.focusGuard));
}, fp = function(e) {
  return !am(e);
}, WL = function(e) {
  return !!e;
}, HL = function(e, t) {
  var n = Math.max(0, e.tabIndex), r = Math.max(0, t.tabIndex), o = n - r, i = e.index - t.index;
  if (o) {
    if (!n)
      return 1;
    if (!r)
      return -1;
  }
  return o || i;
}, jL = function(e) {
  return e.tabIndex < 0 && !e.hasAttribute("tabindex") ? 0 : e.tabIndex;
}, cm = function(e, t, n) {
  return xr(e).map(function(r, o) {
    var i = jL(r);
    return {
      node: r,
      index: o,
      tabIndex: n && i === -1 ? (r.dataset || {}).focusGuard ? 0 : -1 : i
    };
  }).filter(function(r) {
    return !t || r.tabIndex >= 0;
  }).sort(HL);
}, XL = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
], lm = XL.join(","), YL = "".concat(lm, ", [data-focus-guard]"), uC = function(e, t) {
  return xr((e.shadowRoot || e).children).reduce(function(n, r) {
    return n.concat(r.matches(t ? YL : lm) ? [r] : [], uC(r));
  }, []);
}, ZL = function(e, t) {
  var n;
  return e instanceof HTMLIFrameElement && (!((n = e.contentDocument) === null || n === void 0) && n.body) ? Ji([e.contentDocument.body], t) : [e];
}, Ji = function(e, t) {
  return e.reduce(function(n, r) {
    var o, i = uC(r, t), s = (o = []).concat.apply(o, i.map(function(a) {
      return ZL(a, t);
    }));
    return n.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      s,
      // add if node is tabbable itself
      r.parentNode ? xr(r.parentNode.querySelectorAll(lm)).filter(function(a) {
        return a === r;
      }) : []
    );
  }, []);
}, UL = function(e) {
  var t = e.querySelectorAll("[".concat(IL, "]"));
  return xr(t).map(function(n) {
    return Ji([n]);
  }).reduce(function(n, r) {
    return n.concat(r);
  }, []);
}, um = function(e, t) {
  return xr(e).filter(function(n) {
    return iC(t, n);
  }).filter(function(n) {
    return zL(n);
  });
}, $v = function(e, t) {
  return t === void 0 && (t = /* @__PURE__ */ new Map()), xr(e).filter(function(n) {
    return sC(t, n);
  });
}, dm = function(e, t, n) {
  return cm(um(Ji(e, n), t), !0, n);
}, ca = function(e, t) {
  return cm(um(Ji(e), t), !1);
}, JL = function(e, t) {
  return um(UL(e), t);
}, Mo = function(e, t) {
  return e.shadowRoot ? Mo(e.shadowRoot, t) : Object.getPrototypeOf(e).contains !== void 0 && Object.getPrototypeOf(e).contains.call(e, t) ? !0 : xr(e.children).some(function(n) {
    var r;
    if (n instanceof HTMLIFrameElement) {
      var o = (r = n.contentDocument) === null || r === void 0 ? void 0 : r.body;
      return o ? Mo(o, t) : !1;
    }
    return Mo(n, t);
  });
}, KL = function(e) {
  for (var t = /* @__PURE__ */ new Set(), n = e.length, r = 0; r < n; r += 1)
    for (var o = r + 1; o < n; o += 1) {
      var i = e[r].compareDocumentPosition(e[o]);
      (i & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && t.add(o), (i & Node.DOCUMENT_POSITION_CONTAINS) > 0 && t.add(r);
    }
  return e.filter(function(s, a) {
    return !t.has(a);
  });
}, dC = function(e) {
  return e.parentNode ? dC(e.parentNode) : e;
}, fm = function(e) {
  var t = Wo(e);
  return t.filter(Boolean).reduce(function(n, r) {
    var o = r.getAttribute(dp);
    return n.push.apply(n, o ? KL(xr(dC(r).querySelectorAll("[".concat(dp, '="').concat(o, '"]:not([').concat(Xx, '="disabled"])')))) : [r]), n;
  }, []);
}, qL = function(e) {
  try {
    return e();
  } catch {
    return;
  }
}, la = function(e) {
  if (e === void 0 && (e = document), !(!e || !e.activeElement)) {
    var t = e.activeElement;
    return t.shadowRoot ? la(t.shadowRoot) : t instanceof HTMLIFrameElement && qL(function() {
      return t.contentWindow.document;
    }) ? la(t.contentWindow.document) : t;
  }
}, QL = function(e, t) {
  return e === t;
}, ez = function(e, t) {
  return !!xr(e.querySelectorAll("iframe")).some(function(n) {
    return QL(n, t);
  });
}, fC = function(e, t) {
  return t === void 0 && (t = la(nC(e).ownerDocument)), !t || t.dataset && t.dataset.focusGuard ? !1 : fm(e).some(function(n) {
    return Mo(n, t) || ez(n, t);
  });
}, tz = function(e) {
  e === void 0 && (e = document);
  var t = la(e);
  return t ? xr(e.querySelectorAll("[".concat(CL, "]"))).some(function(n) {
    return Mo(n, t);
  }) : !1;
}, nz = function(e, t) {
  return t.filter(lC).filter(function(n) {
    return n.name === e.name;
  }).filter(function(n) {
    return n.checked;
  })[0] || e;
}, pm = function(e, t) {
  return lC(e) && e.name ? nz(e, t) : e;
}, rz = function(e) {
  var t = /* @__PURE__ */ new Set();
  return e.forEach(function(n) {
    return t.add(pm(n, e));
  }), e.filter(function(n) {
    return t.has(n);
  });
}, Vv = function(e) {
  return e[0] && e.length > 1 ? pm(e[0], e) : e[0];
}, Lv = function(e, t) {
  return e.indexOf(pm(t, e));
}, pp = "NEW_FOCUS", oz = function(e, t, n, r, o) {
  var i = e.length, s = e[0], a = e[i - 1], c = am(r);
  if (!(r && e.indexOf(r) >= 0)) {
    var l = r !== void 0 ? n.indexOf(r) : -1, u = o ? n.indexOf(o) : l, d = o ? e.indexOf(o) : -1;
    if (l === -1)
      return d !== -1 ? d : pp;
    if (d === -1)
      return pp;
    var f = l - u, p = n.indexOf(s), m = n.indexOf(a), h = rz(n), g = r !== void 0 ? h.indexOf(r) : -1, v = o ? h.indexOf(o) : g, y = h.filter(function(P) {
      return P.tabIndex >= 0;
    }), x = r !== void 0 ? y.indexOf(r) : -1, S = o ? y.indexOf(o) : x, C = x >= 0 && S >= 0 ? (
      // old/new are tabbables, measure distance in tabbable space
      S - x
    ) : (
      // or else measure in focusable space
      v - g
    );
    if (!f && d >= 0 || t.length === 0)
      return d;
    var w = Lv(e, t[0]), I = Lv(e, t[t.length - 1]);
    if (l <= p && c && Math.abs(f) > 1)
      return I;
    if (l >= m && c && Math.abs(f) > 1)
      return w;
    if (f && Math.abs(C) > 1)
      return d;
    if (l <= p)
      return I;
    if (l > m)
      return w;
    if (f)
      return Math.abs(f) > 1 ? d : (i + d + f) % i;
  }
}, iz = function(e) {
  return function(t) {
    var n, r = (n = aC(t)) === null || n === void 0 ? void 0 : n.autofocus;
    return (
      // @ts-expect-error
      t.autofocus || //
      r !== void 0 && r !== "false" || //
      e.indexOf(t) >= 0
    );
  };
}, zv = function(e, t, n) {
  var r = e.map(function(i) {
    var s = i.node;
    return s;
  }), o = $v(r.filter(iz(n)));
  return o && o.length ? Vv(o) : Vv($v(t));
}, hp = function(e, t) {
  return t === void 0 && (t = []), t.push(e), e.parentNode && hp(e.parentNode.host || e.parentNode, t), t;
}, qd = function(e, t) {
  for (var n = hp(e), r = hp(t), o = 0; o < n.length; o += 1) {
    var i = n[o];
    if (r.indexOf(i) >= 0)
      return i;
  }
  return !1;
}, pC = function(e, t, n) {
  var r = Wo(e), o = Wo(t), i = r[0], s = !1;
  return o.filter(Boolean).forEach(function(a) {
    s = qd(s || a, a) || s, n.filter(Boolean).forEach(function(c) {
      var l = qd(i, c);
      l && (!s || Mo(l, s) ? s = l : s = qd(l, s));
    });
  }), s;
}, Gv = function(e, t) {
  return e.reduce(function(n, r) {
    return n.concat(JL(r, t));
  }, []);
}, sz = function(e, t) {
  var n = /* @__PURE__ */ new Map();
  return t.forEach(function(r) {
    return n.set(r.node, r);
  }), e.map(function(r) {
    return n.get(r);
  }).filter(WL);
}, az = function(e, t) {
  var n = la(Wo(e).length > 0 ? document : nC(e).ownerDocument), r = fm(e).filter(fp), o = pC(n || e, e, r), i = /* @__PURE__ */ new Map(), s = ca(r, i), a = s.filter(function(m) {
    var h = m.node;
    return fp(h);
  });
  if (a[0]) {
    var c = ca([o], i).map(function(m) {
      var h = m.node;
      return h;
    }), l = sz(c, a), u = l.map(function(m) {
      var h = m.node;
      return h;
    }), d = l.filter(function(m) {
      var h = m.tabIndex;
      return h >= 0;
    }).map(function(m) {
      var h = m.node;
      return h;
    }), f = oz(u, d, c, n, t);
    if (f === pp) {
      var p = (
        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
        zv(s, d, Gv(r, i)) || zv(s, u, Gv(r, i))
      );
      if (p)
        return { node: p };
      console.warn("focus-lock: cannot find any node to move focus into");
      return;
    }
    return f === void 0 ? f : l[f];
  }
}, cz = function(e) {
  var t = fm(e).filter(fp), n = pC(e, e, t), r = cm(Ji([n], !0), !0, !0), o = Ji(t, !1);
  return r.map(function(i) {
    var s = i.node, a = i.index;
    return {
      node: s,
      index: a,
      lockItem: o.indexOf(s) >= 0,
      guard: am(s)
    };
  });
}, hm = function(e, t) {
  e && ("focus" in e && e.focus(t), "contentWindow" in e && e.contentWindow && e.contentWindow.focus());
}, Qd = 0, ef = !1, hC = function(e, t, n) {
  n === void 0 && (n = {});
  var r = az(e, t);
  if (!ef && r) {
    if (Qd > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), ef = !0, setTimeout(function() {
        ef = !1;
      }, 1);
      return;
    }
    Qd++, hm(r.node, n.focusOptions), Qd--;
  }
};
function Ss(e) {
  if (!e)
    return null;
  if (typeof WeakRef > "u")
    return function() {
      return e || null;
    };
  var t = e ? new WeakRef(e) : null;
  return function() {
    return t?.deref() || null;
  };
}
var lz = function(e) {
  if (!e)
    return null;
  for (var t = [], n = e; n && n !== document.body; )
    t.push({
      current: Ss(n),
      parent: Ss(n.parentElement),
      left: Ss(n.previousElementSibling),
      right: Ss(n.nextElementSibling)
    }), n = n.parentElement;
  return {
    element: Ss(e),
    stack: t,
    ownerDocument: e.ownerDocument
  };
}, uz = function(e) {
  var t, n, r, o, i;
  if (e)
    for (var s = e.stack, a = e.ownerDocument, c = /* @__PURE__ */ new Map(), l = 0, u = s; l < u.length; l++) {
      var d = u[l], f = (t = d.parent) === null || t === void 0 ? void 0 : t.call(d);
      if (f && a.contains(f)) {
        for (var p = (n = d.left) === null || n === void 0 ? void 0 : n.call(d), m = d.current(), h = f.contains(m) ? m : void 0, g = (r = d.right) === null || r === void 0 ? void 0 : r.call(d), v = dm([f], c), y = (
          // that is element itself
          (i = (o = h ?? p?.nextElementSibling) !== null && o !== void 0 ? o : (
            // or somebody to the right, still close enough
            g
          )) !== null && i !== void 0 ? i : (
            // or somebody to the left, something?
            p
          )
        ); y; ) {
          for (var x = 0, S = v; x < S.length; x++) {
            var C = S[x];
            if (y?.contains(C.node))
              return C.node;
          }
          y = y.nextElementSibling;
        }
        if (v.length)
          return v[0].node;
      }
    }
}, mC = function(e) {
  var t = lz(e);
  return function() {
    return uz(t);
  };
}, dz = function(e, t, n) {
  if (!e || !t)
    return console.error("no element or scope given"), {};
  var r = Wo(t);
  if (r.every(function(s) {
    return !Mo(s, e);
  }))
    return console.error("Active element is not contained in the scope"), {};
  var o = n ? dm(r, /* @__PURE__ */ new Map()) : ca(r, /* @__PURE__ */ new Map()), i = o.findIndex(function(s) {
    var a = s.node;
    return a === e;
  });
  if (i !== -1)
    return {
      prev: o[i - 1],
      next: o[i + 1],
      first: o[0],
      last: o[o.length - 1]
    };
}, fz = function(e, t) {
  var n = t ? dm(Wo(e), /* @__PURE__ */ new Map()) : ca(Wo(e), /* @__PURE__ */ new Map());
  return {
    first: n[0],
    last: n[n.length - 1]
  };
}, pz = function(e) {
  return Object.assign({
    scope: document.body,
    cycle: !0,
    onlyTabbable: !0
  }, e);
}, gC = function(e, t, n) {
  t === void 0 && (t = {});
  var r = pz(t), o = dz(e, r.scope, r.onlyTabbable);
  if (o) {
    var i = n(o, r.cycle);
    i && hm(i.node, r.focusOptions);
  }
}, hz = function(e, t) {
  t === void 0 && (t = {}), gC(e, t, function(n, r) {
    var o = n.next, i = n.first;
    return o || r && i;
  });
}, mz = function(e, t) {
  t === void 0 && (t = {}), gC(e, t, function(n, r) {
    var o = n.prev, i = n.last;
    return o || r && i;
  });
}, bC = function(e, t, n) {
  var r, o = fz(e, (r = t.onlyTabbable) !== null && r !== void 0 ? r : !0), i = o[n];
  i && hm(i.node, t.focusOptions);
}, gz = function(e, t) {
  t === void 0 && (t = {}), bC(e, t, "first");
}, bz = function(e, t) {
  t === void 0 && (t = {}), bC(e, t, "last");
};
function mm(e) {
  setTimeout(e, 1);
}
var vz = function(t) {
  return t && "current" in t ? t.current : t;
}, vC = function() {
  return document && document.activeElement === document.body;
}, yz = function() {
  return vC() || tz();
}, $i = null, ln = null, Wv = function() {
  return null;
}, Vi = null, ua = !1, gm = !1, Sz = function() {
  return !0;
}, xz = function(t) {
  return ($i.whiteList || Sz)(t);
}, Cz = function(t, n) {
  Vi = {
    observerNode: t,
    portaledElement: n
  };
}, Iz = function(t) {
  return Vi && Vi.portaledElement === t;
};
function Hv(e, t, n, r) {
  var o = null, i = e;
  do {
    var s = r[i];
    if (s.guard)
      s.node.dataset.focusAutoGuard && (o = s);
    else if (s.lockItem) {
      if (i !== e)
        return;
      o = null;
    } else
      break;
  } while ((i += n) !== t);
  o && (o.node.tabIndex = 0);
}
var wz = function(t) {
  return t ? !!ua : ua === "meanwhile";
}, Pz = function e(t, n, r) {
  return n && (n.host === t && (!n.activeElement || r.contains(n.activeElement)) || n.parentNode && e(t, n.parentNode, r));
}, kz = function(t, n) {
  return n.some(function(r) {
    return Pz(t, r, r);
  });
}, yC = function(t) {
  return ca(t, /* @__PURE__ */ new Map());
}, Az = function(t) {
  return !yC([t.parentNode]).some(function(n) {
    return n.node === t;
  });
}, yl = function() {
  var t = !1;
  if ($i) {
    var n = $i, r = n.observed, o = n.persistentFocus, i = n.autoFocus, s = n.shards, a = n.crossFrame, c = n.focusOptions, l = n.noFocusGuards, u = r || Vi && Vi.portaledElement;
    if (vC() && ln && ln !== document.body && (!document.body.contains(ln) || Az(ln))) {
      var d = Wv();
      d && d.focus();
    }
    var f = document && document.activeElement;
    if (u) {
      var p = [u].concat(s.map(vz).filter(Boolean)), m = function() {
        if (!wz(a) || !l || !ln || gm)
          return !1;
        var x = yC(p), S = x.findIndex(function(C) {
          var w = C.node;
          return w === ln;
        });
        return S === 0 || S === x.length - 1;
      };
      if ((!f || xz(f)) && (o || m() || !yz() || !ln && i) && (u && !(fC(p) || f && kz(f, p) || Iz(f)) && (document && !ln && f && !i ? (f.blur && f.blur(), document.body.focus()) : (t = hC(p, ln, {
        focusOptions: c
      }), Vi = {})), ln = document && document.activeElement, ln !== document.body && (Wv = mC(ln)), ua = !1), document && f !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
        var h = document && document.activeElement, g = cz(p), v = g.map(function(y) {
          var x = y.node;
          return x;
        }).indexOf(h);
        v > -1 && (g.filter(function(y) {
          var x = y.guard, S = y.node;
          return x && S.dataset.focusAutoGuard;
        }).forEach(function(y) {
          var x = y.node;
          return x.removeAttribute("tabIndex");
        }), Hv(v, g.length, 1, g), Hv(v, -1, -1, g));
      }
    }
  }
  return t;
}, SC = function(t) {
  yl() && t && (t.stopPropagation(), t.preventDefault());
}, bm = function() {
  return mm(yl);
}, Tz = function(t) {
  var n = t.target, r = t.currentTarget;
  r.contains(n) || Cz(r, n);
}, Ez = function() {
  return null;
};
process.env.NODE_ENV !== "production" && jx.node.isRequired;
var xC = function() {
  gm = !0;
}, CC = function() {
  gm = !1, ua = "just", mm(function() {
    ua = "meanwhile";
  });
}, Rz = function() {
  document.addEventListener("focusin", SC), document.addEventListener("focusout", bm), window.addEventListener("focus", xC), window.addEventListener("blur", CC);
}, _z = function() {
  document.removeEventListener("focusin", SC), document.removeEventListener("focusout", bm), window.removeEventListener("focus", xC), window.removeEventListener("blur", CC);
};
function Oz(e) {
  return e.filter(function(t) {
    var n = t.disabled;
    return !n;
  });
}
var IC = {
  moveFocusInside: hC,
  focusInside: fC,
  focusNextElement: hz,
  focusPrevElement: mz,
  focusFirstElement: gz,
  focusLastElement: bz,
  captureFocusRestore: mC
};
function Nz(e) {
  var t = e.slice(-1)[0];
  t && !$i && Rz();
  var n = $i, r = n && t && t.id === n.id;
  $i = t, n && !r && (n.onDeactivation(), e.filter(function(o) {
    var i = o.id;
    return i === n.id;
  }).length || n.returnFocus(!t)), t ? (ln = null, (!r || n.observed !== t.observed) && t.onActivation(IC), yl(), mm(yl)) : (_z(), ln = null);
}
Qx.assignSyncMedium(Tz);
eC.assignMedium(bm);
EL.assignMedium(function(e) {
  return e(IC);
});
const Mz = BL(Oz, Nz)(Ez);
var mp = /* @__PURE__ */ _t(function(t, n) {
  return /* @__PURE__ */ At.createElement(sm, Ie({
    sideCar: Mz,
    ref: n
  }, t));
}), wC = sm.propTypes || {};
wC.sideCar;
var Bz = Wx(wC, ["sideCar"]);
mp.propTypes = process.env.NODE_ENV !== "production" ? Bz : {};
const Fz = mp.default ?? mp, PC = (e) => {
  const {
    initialFocusRef: t,
    finalFocusRef: n,
    contentRef: r,
    restoreFocus: o,
    children: i,
    isDisabled: s,
    autoFocus: a,
    persistentFocus: c,
    lockFocusAcrossFrames: l
  } = e, u = R(() => {
    t?.current ? t.current.focus() : r?.current && F0(r.current).length === 0 && requestAnimationFrame(() => {
      r.current?.focus();
    });
  }, [t, r]), d = R(() => {
    n?.current?.focus();
  }, [n]);
  return /* @__PURE__ */ b(
    Fz,
    {
      crossFrame: l,
      persistentFocus: c,
      autoFocus: a,
      disabled: s,
      onActivation: u,
      onDeactivation: d,
      returnFocus: o && !n,
      children: i
    }
  );
};
PC.displayName = "FocusLock";
const [Dz, $z] = De({
  name: "FormErrorStylesContext",
  errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `
}), Vz = X(
  (e, t) => {
    const n = We("FormError", e), r = $e(e), o = Zo();
    return o?.isInvalid ? /* @__PURE__ */ b(Dz, { value: n, children: /* @__PURE__ */ b(
      z.div,
      {
        ...o?.getErrorMessageProps(r, t),
        className: oe("chakra-form__error-message", e.className),
        __css: {
          display: "flex",
          alignItems: "center",
          ...n.text
        }
      }
    ) }) : null;
  }
);
Vz.displayName = "FormErrorMessage";
const Lz = X((e, t) => {
  const n = $z();
  if (!Zo()?.isInvalid)
    return null;
  const o = oe("chakra-form__error-icon", e.className);
  return /* @__PURE__ */ b(
    It,
    {
      ref: t,
      "aria-hidden": !0,
      ...e,
      __css: n.icon,
      className: o,
      children: /* @__PURE__ */ b(
        "path",
        {
          fill: "currentColor",
          d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
        }
      )
    }
  );
});
Lz.displayName = "FormErrorIcon";
const kC = X(
  function(t, n) {
    const r = Gt("FormLabel", t), o = $e(t), {
      className: i,
      children: s,
      requiredIndicator: a = /* @__PURE__ */ b(AC, {}),
      optionalIndicator: c = null,
      ...l
    } = o, u = Zo(), d = u?.getLabelProps(l, n) ?? { ref: n, ...l };
    return /* @__PURE__ */ Ae(
      z.label,
      {
        ...d,
        className: oe("chakra-form__label", o.className),
        __css: {
          display: "block",
          textAlign: "start",
          ...r
        },
        children: [
          s,
          u?.isRequired ? a : c
        ]
      }
    );
  }
);
kC.displayName = "FormLabel";
const AC = X(
  function(t, n) {
    const r = Zo(), o = $x();
    if (!r?.isRequired)
      return null;
    const i = oe("chakra-form__required-indicator", t.className);
    return /* @__PURE__ */ b(
      z.span,
      {
        ...r?.getRequiredIndicatorProps(t, n),
        __css: o.requiredIndicator,
        className: i
      }
    );
  }
);
AC.displayName = "RequiredIndicator";
const TC = X(function(t, n) {
  const {
    templateAreas: r,
    gap: o,
    rowGap: i,
    columnGap: s,
    column: a,
    row: c,
    autoFlow: l,
    autoRows: u,
    templateRows: d,
    autoColumns: f,
    templateColumns: p,
    ...m
  } = t, h = {
    display: "grid",
    gridTemplateAreas: r,
    gridGap: o,
    gridRowGap: i,
    gridColumnGap: s,
    gridAutoColumns: f,
    gridColumn: a,
    gridRow: c,
    gridAutoFlow: l,
    gridAutoRows: u,
    gridTemplateRows: d,
    gridTemplateColumns: p
  };
  return /* @__PURE__ */ b(z.div, { ref: n, __css: h, ...m });
});
TC.displayName = "Grid";
function jv(e) {
  return Sa(
    e,
    (t) => t === "auto" ? "auto" : `span ${t}/span ${t}`
  );
}
const zz = X(
  function(t, n) {
    const {
      area: r,
      colSpan: o,
      colStart: i,
      colEnd: s,
      rowEnd: a,
      rowSpan: c,
      rowStart: l,
      ...u
    } = t, d = is({
      gridArea: r,
      gridColumn: jv(o),
      gridRow: jv(c),
      gridColumnStart: i,
      gridColumnEnd: s,
      gridRowStart: l,
      gridRowEnd: a
    });
    return /* @__PURE__ */ b(z.div, { ref: n, __css: d, ...u });
  }
);
zz.displayName = "GridItem";
const Gz = X(
  function(t, n) {
    const { columns: r, spacingX: o, spacingY: i, spacing: s, minChildWidth: a, ...c } = t, l = bn(), u = a ? Hz(a, l) : jz(r);
    return /* @__PURE__ */ b(
      TC,
      {
        ref: n,
        gap: s,
        columnGap: o,
        rowGap: i,
        templateColumns: u,
        ...c
      }
    );
  }
);
Gz.displayName = "SimpleGrid";
function Wz(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function Hz(e, t) {
  return Sa(e, (n) => {
    const r = px("sizes", n, Wz(n))(t);
    return n === null ? null : `repeat(auto-fit, minmax(${r}, 1fr))`;
  });
}
function jz(e) {
  return Sa(
    e,
    (t) => t === null ? null : `repeat(${t}, minmax(0, 1fr))`
  );
}
const Xz = X(function(t, n) {
  const r = Gt("Mark", t), o = $e(t);
  return /* @__PURE__ */ b(
    Rt,
    {
      ref: n,
      ...o,
      as: "mark",
      __css: { bg: "transparent", whiteSpace: "nowrap", ...r }
    }
  );
}), Yz = (e) => e.replace(/[|\\{}()[\]^$+*?.-]/g, (t) => `\\${t}`);
function Zz(e) {
  const t = e.filter((n) => n.length !== 0).map((n) => Yz(n.trim()));
  return t.length ? new RegExp(`(${t.join("|")})`, "ig") : null;
}
function Uz({ text: e, query: t }) {
  const n = Zz(Array.isArray(t) ? t : [t]);
  return n ? e.split(n).filter(Boolean).map((o) => ({ text: o, match: n.test(o) })) : [{ text: e, match: !1 }];
}
function Jz(e) {
  const { text: t, query: n } = e;
  return be(() => Uz({ text: t, query: n }), [t, n]);
}
function BQ(e) {
  const { children: t, query: n, styles: r } = e;
  if (typeof t != "string")
    throw new Error("The children prop of Highlight must be a string");
  const o = Jz({ query: n, text: t });
  return /* @__PURE__ */ b(Vr, { children: o.map((i, s) => i.match ? /* @__PURE__ */ b(Xz, { sx: r, children: i.text }, s) : /* @__PURE__ */ b(Hi, { children: i.text }, s)) });
}
function EC(e) {
  const {
    viewBox: t = "0 0 24 24",
    d: n,
    displayName: r,
    defaultProps: o = {}
  } = e, i = yr.toArray(e.path), s = X((a, c) => /* @__PURE__ */ b(It, { ref: c, viewBox: t, ...o, ...a, children: i.length ? i : /* @__PURE__ */ b("path", { fill: "currentColor", d: n }) }));
  return s.displayName = r, s;
}
const gp = X(function(t, n) {
  const { htmlWidth: r, htmlHeight: o, alt: i, ...s } = t;
  return /* @__PURE__ */ b("img", { width: r, height: o, ref: n, alt: i, ...s });
});
gp.displayName = "NativeImage";
const Kz = X(function(t, n) {
  const {
    fallbackSrc: r,
    fallback: o,
    src: i,
    srcSet: s,
    align: a,
    fit: c,
    loading: l,
    ignoreFallback: u,
    crossOrigin: d,
    fallbackStrategy: f = "beforeLoadOrError",
    referrerPolicy: p,
    ...m
  } = t, h = r !== void 0 || o !== void 0, g = l != null || // use can opt out of fallback image
  u || // if the user doesn't provide any kind of fallback we should ignore it
  !h, v = _x({
    ...t,
    crossOrigin: d,
    ignoreFallback: g
  }), y = m4(v, f), x = {
    ref: n,
    objectFit: c,
    objectPosition: a,
    ...g ? m : ya(m, ["onError", "onLoad"])
  };
  return y ? o || /* @__PURE__ */ b(
    z.img,
    {
      as: gp,
      className: "chakra-image__placeholder",
      src: r,
      ...x
    }
  ) : /* @__PURE__ */ b(
    z.img,
    {
      as: gp,
      src: i,
      srcSet: s,
      crossOrigin: d,
      loading: l,
      referrerPolicy: p,
      className: "chakra-image",
      ...x
    }
  );
});
Kz.displayName = "Image";
const vm = X(
  function(t, n) {
    const { htmlSize: r, ...o } = t, i = We("Input", o), s = $e(o), a = as(s), c = oe("chakra-input", t.className);
    return /* @__PURE__ */ b(
      z.input,
      {
        size: r,
        ...a,
        __css: i.field,
        ref: n,
        className: c
      }
    );
  }
);
vm.displayName = "Input";
vm.id = "Input";
const [qz, Qz] = De({
  name: "InputGroupStylesContext",
  errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
}), e3 = X(
  function(t, n) {
    const r = We("Input", t), { children: o, className: i, ...s } = $e(t), a = oe("chakra-input__group", i), c = {}, l = Hr(o), u = r.field;
    l.forEach((f) => {
      r && (u && f.type.id === "InputLeftElement" && (c.paddingStart = u.height ?? u.h), u && f.type.id === "InputRightElement" && (c.paddingEnd = u.height ?? u.h), f.type.id === "InputRightAddon" && (c.borderEndRadius = 0), f.type.id === "InputLeftAddon" && (c.borderStartRadius = 0));
    });
    const d = l.map((f) => {
      const p = is({
        size: f.props?.size || t.size,
        variant: f.props?.variant || t.variant
      });
      return f.type.id !== "Input" ? Lt(f, p) : Lt(f, Object.assign(p, c, f.props));
    });
    return /* @__PURE__ */ b(
      z.div,
      {
        className: a,
        ref: n,
        __css: {
          width: "100%",
          display: "flex",
          position: "relative",
          // Parts of inputs override z-index to ensure that they stack correctly on each other
          // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
          isolation: "isolate",
          ...r.group
        },
        "data-group": !0,
        ...s,
        children: /* @__PURE__ */ b(qz, { value: r, children: d })
      }
    );
  }
);
e3.displayName = "InputGroup";
const t3 = z("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: "0",
    zIndex: 2
  }
}), mu = X(
  function(t, n) {
    const { placement: r = "left", ...o } = t, i = Qz(), s = i.field, c = {
      [r === "left" ? "insetStart" : "insetEnd"]: "0",
      width: s?.height ?? s?.h,
      height: s?.height ?? s?.h,
      fontSize: s?.fontSize,
      ...i.element
    };
    return /* @__PURE__ */ b(t3, { ref: n, __css: c, ...o });
  }
);
mu.id = "InputElement";
mu.displayName = "InputElement";
const RC = X(
  function(t, n) {
    const { className: r, ...o } = t, i = oe("chakra-input__left-element", r);
    return /* @__PURE__ */ b(
      mu,
      {
        ref: n,
        placement: "left",
        className: i,
        ...o
      }
    );
  }
);
RC.id = "InputLeftElement";
RC.displayName = "InputLeftElement";
const _C = X(
  function(t, n) {
    const { className: r, ...o } = t, i = oe("chakra-input__right-element", r);
    return /* @__PURE__ */ b(
      mu,
      {
        ref: n,
        placement: "right",
        className: i,
        ...o
      }
    );
  }
);
_C.id = "InputRightElement";
_C.displayName = "InputRightElement";
const n3 = X(function(t, n) {
  const r = Gt("Kbd", t), { className: o, ...i } = $e(t);
  return /* @__PURE__ */ b(
    z.kbd,
    {
      ref: n,
      className: oe("chakra-kbd", o),
      ...i,
      __css: {
        fontFamily: "mono",
        ...r
      }
    }
  );
});
n3.displayName = "Kbd";
const OC = X(function(t, n) {
  const r = Gt("Link", t), { className: o, isExternal: i, ...s } = $e(t);
  return /* @__PURE__ */ b(
    z.a,
    {
      target: i ? "_blank" : void 0,
      rel: i ? "noopener" : void 0,
      ref: n,
      className: oe("chakra-link", o),
      ...s,
      __css: r
    }
  );
});
OC.displayName = "Link";
const [r3, NC] = De({
  name: "ListStylesContext",
  errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
}), ym = X(function(t, n) {
  const r = We("List", t), {
    children: o,
    styleType: i = "none",
    stylePosition: s,
    spacing: a,
    ...c
  } = $e(t), l = Hr(o), d = a ? { "& > *:not(style) ~ *:not(style)": { mt: a } } : {};
  return /* @__PURE__ */ b(r3, { value: r, children: /* @__PURE__ */ b(
    z.ul,
    {
      ref: n,
      listStyleType: i,
      listStylePosition: s,
      role: "list",
      __css: { ...r.container, ...d },
      ...c,
      children: l
    }
  ) });
});
ym.displayName = "List";
const o3 = X((e, t) => {
  const { as: n, ...r } = e;
  return /* @__PURE__ */ b(ym, { ref: t, as: "ol", styleType: "decimal", marginStart: "1em", ...r });
});
o3.displayName = "OrderedList";
const i3 = X(
  function(t, n) {
    const { as: r, ...o } = t;
    return /* @__PURE__ */ b(ym, { ref: n, as: "ul", styleType: "initial", marginStart: "1em", ...o });
  }
);
i3.displayName = "UnorderedList";
const s3 = X(
  function(t, n) {
    const r = NC();
    return /* @__PURE__ */ b(z.li, { ref: n, ...t, __css: r.item });
  }
);
s3.displayName = "ListItem";
const a3 = X(
  function(t, n) {
    const r = NC();
    return /* @__PURE__ */ b(It, { ref: n, role: "presentation", ...t, __css: r.icon });
  }
);
a3.displayName = "ListIcon";
const Xv = (e, t) => e?.breakpoints?.[t] ?? t;
function MC(e) {
  const { breakpoint: t = "", below: n, above: r } = e, o = bn(), i = Xv(o, n), s = Xv(o, r);
  let a = t;
  return i ? a = `(max-width: ${i})` : s && (a = `(min-width: ${s})`), a;
}
function BC(e, t = {}) {
  const { ssr: n = !0, fallback: r } = t, { getWindow: o } = zB(), i = Array.isArray(e) ? e : [e];
  let s = Array.isArray(r) ? r : [r];
  s = s.filter((l) => l != null);
  const [a, c] = ue(() => i.map((l, u) => ({
    media: l,
    matches: n ? !!s[u] : o().matchMedia(l).matches
  })));
  return ge(() => {
    const l = o();
    c(
      i.map((f) => ({
        media: f,
        matches: l.matchMedia(f).matches
      }))
    );
    const u = i.map((f) => l.matchMedia(f)), d = (f) => {
      c((p) => p.slice().map((m) => m.media === f.media ? { ...m, matches: f.matches } : m));
    };
    return u.forEach((f) => {
      typeof f.addListener == "function" ? f.addListener(d) : f.addEventListener("change", d);
    }), () => {
      u.forEach((f) => {
        typeof f.removeListener == "function" ? f.removeListener(d) : f.removeEventListener("change", d);
      });
    };
  }, [o]), a.map((l) => l.matches);
}
function FC(e) {
  const { breakpoint: t, hide: n, children: r, ssr: o } = e, [i] = BC(t, { ssr: o });
  return (n ? !i : i) ? r : null;
}
function c3(e) {
  const { children: t, ssr: n } = e, r = MC(e);
  return /* @__PURE__ */ b(FC, { breakpoint: r, hide: !0, ssr: n, children: t });
}
c3.displayName = "Hide";
function l3(e) {
  const { children: t, ssr: n } = e, r = MC(e);
  return /* @__PURE__ */ b(FC, { breakpoint: r, ssr: n, children: t });
}
l3.displayName = "Show";
function u3(e) {
  const t = Mt(e) ? e : { fallback: e ?? "base" }, r = bn().__breakpoints.details.map(
    ({ minMaxQuery: a, breakpoint: c }) => ({
      breakpoint: c,
      query: a.replace("@media screen and ", "")
    })
  ), o = r.map((a) => a.breakpoint === t.fallback), s = BC(
    r.map((a) => a.query),
    { fallback: o, ssr: t.ssr }
  ).findIndex((a) => a == !0);
  return r[s]?.breakpoint ?? t.fallback;
}
function d3(e, t, n = L0) {
  let r = Object.keys(e).indexOf(t);
  if (r !== -1)
    return e[t];
  let o = n.indexOf(t);
  for (; o >= 0; ) {
    const i = n[o];
    if (e.hasOwnProperty(i)) {
      r = o;
      break;
    }
    o -= 1;
  }
  if (r !== -1) {
    const i = n[r];
    return e[i];
  }
}
function f3(e, t) {
  const n = Mt(t) ? t : { fallback: t ?? "base" }, r = u3(n), o = bn();
  if (!r)
    return;
  const i = Array.from(o.__breakpoints?.keys || []), s = Array.isArray(e) ? Object.fromEntries(
    Object.entries(_A(e, i)).map(
      ([a, c]) => [a, c]
    )
  ) : e;
  return d3(s, r, i);
}
function p3(e, t, n, r) {
  if (t == null)
    return r;
  if (!r)
    return e.find(
      (s) => n(s).toLowerCase().startsWith(t.toLowerCase())
    );
  const o = e.filter(
    (i) => n(i).toLowerCase().startsWith(t.toLowerCase())
  );
  if (o.length > 0) {
    let i;
    return o.includes(r) ? (i = o.indexOf(r) + 1, i === o.length && (i = 0), o[i]) : (i = e.indexOf(o[0]), e[i]);
  }
  return r;
}
function h3(e) {
  const { key: t } = e;
  return t.length === 1 || t.length > 1 && /[^a-zA-Z0-9]/.test(t);
}
function m3(e = {}) {
  const { timeout: t = 300, preventDefault: n = () => !0 } = e, [r, o] = ue([]), i = se(void 0), s = () => {
    i.current && (clearTimeout(i.current), i.current = null);
  }, a = () => {
    s(), i.current = setTimeout(() => {
      o([]), i.current = null;
    }, t);
  };
  ge(() => s, []);
  function c(l) {
    return (u) => {
      if (u.key === "Backspace") {
        const d = [...r];
        d.pop(), o(d);
        return;
      }
      if (h3(u)) {
        const d = r.concat(u.key);
        n(u) && (u.preventDefault(), u.stopPropagation()), o(d), l(d.join("")), a();
      }
    };
  }
  return c;
}
var pn = "top", Ln = "bottom", zn = "right", hn = "left", Sm = "auto", Na = [pn, Ln, zn, hn], Ki = "start", da = "end", g3 = "clippingParents", DC = "viewport", xs = "popper", b3 = "reference", Yv = /* @__PURE__ */ Na.reduce(function(e, t) {
  return e.concat([t + "-" + Ki, t + "-" + da]);
}, []), $C = /* @__PURE__ */ [].concat(Na, [Sm]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Ki, t + "-" + da]);
}, []), v3 = "beforeRead", y3 = "read", S3 = "afterRead", x3 = "beforeMain", C3 = "main", I3 = "afterMain", w3 = "beforeWrite", P3 = "write", k3 = "afterWrite", A3 = [v3, y3, S3, x3, C3, I3, w3, P3, k3];
function br(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function kn(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Ho(e) {
  var t = kn(e).Element;
  return e instanceof t || e instanceof Element;
}
function $n(e) {
  var t = kn(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function xm(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = kn(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function T3(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, o = t.attributes[n] || {}, i = t.elements[n];
    !$n(i) || !br(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(s) {
      var a = o[s];
      a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function E3(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var o = t.elements[r], i = t.attributes[r] || {}, s = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), a = s.reduce(function(c, l) {
        return c[l] = "", c;
      }, {});
      !$n(o) || !br(o) || (Object.assign(o.style, a), Object.keys(i).forEach(function(c) {
        o.removeAttribute(c);
      }));
    });
  };
}
const R3 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: T3,
  effect: E3,
  requires: ["computeStyles"]
};
function gr(e) {
  return e.split("-")[0];
}
var Bo = Math.max, Sl = Math.min, qi = Math.round;
function bp() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function VC() {
  return !/^((?!chrome|android).)*safari/i.test(bp());
}
function Qi(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), o = 1, i = 1;
  t && $n(e) && (o = e.offsetWidth > 0 && qi(r.width) / e.offsetWidth || 1, i = e.offsetHeight > 0 && qi(r.height) / e.offsetHeight || 1);
  var s = Ho(e) ? kn(e) : window, a = s.visualViewport, c = !VC() && n, l = (r.left + (c && a ? a.offsetLeft : 0)) / o, u = (r.top + (c && a ? a.offsetTop : 0)) / i, d = r.width / o, f = r.height / i;
  return {
    width: d,
    height: f,
    top: u,
    right: l + d,
    bottom: u + f,
    left: l,
    x: l,
    y: u
  };
}
function Cm(e) {
  var t = Qi(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function LC(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && xm(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Gr(e) {
  return kn(e).getComputedStyle(e);
}
function _3(e) {
  return ["table", "td", "th"].indexOf(br(e)) >= 0;
}
function uo(e) {
  return ((Ho(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function gu(e) {
  return br(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (xm(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    uo(e)
  );
}
function Zv(e) {
  return !$n(e) || // https://github.com/popperjs/popper-core/issues/837
  Gr(e).position === "fixed" ? null : e.offsetParent;
}
function O3(e) {
  var t = /firefox/i.test(bp()), n = /Trident/i.test(bp());
  if (n && $n(e)) {
    var r = Gr(e);
    if (r.position === "fixed")
      return null;
  }
  var o = gu(e);
  for (xm(o) && (o = o.host); $n(o) && ["html", "body"].indexOf(br(o)) < 0; ) {
    var i = Gr(o);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || t && i.willChange === "filter" || t && i.filter && i.filter !== "none")
      return o;
    o = o.parentNode;
  }
  return null;
}
function Ma(e) {
  for (var t = kn(e), n = Zv(e); n && _3(n) && Gr(n).position === "static"; )
    n = Zv(n);
  return n && (br(n) === "html" || br(n) === "body" && Gr(n).position === "static") ? t : n || O3(e) || t;
}
function Im(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Zs(e, t, n) {
  return Bo(e, Sl(t, n));
}
function N3(e, t, n) {
  var r = Zs(e, t, n);
  return r > n ? n : r;
}
function zC() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function GC(e) {
  return Object.assign({}, zC(), e);
}
function WC(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var M3 = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, GC(typeof t != "number" ? t : WC(t, Na));
};
function B3(e) {
  var t, n = e.state, r = e.name, o = e.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, a = gr(n.placement), c = Im(a), l = [hn, zn].indexOf(a) >= 0, u = l ? "height" : "width";
  if (!(!i || !s)) {
    var d = M3(o.padding, n), f = Cm(i), p = c === "y" ? pn : hn, m = c === "y" ? Ln : zn, h = n.rects.reference[u] + n.rects.reference[c] - s[c] - n.rects.popper[u], g = s[c] - n.rects.reference[c], v = Ma(i), y = v ? c === "y" ? v.clientHeight || 0 : v.clientWidth || 0 : 0, x = h / 2 - g / 2, S = d[p], C = y - f[u] - d[m], w = y / 2 - f[u] / 2 + x, I = Zs(S, w, C), P = c;
    n.modifiersData[r] = (t = {}, t[P] = I, t.centerOffset = I - w, t);
  }
}
function F3(e) {
  var t = e.state, n = e.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || LC(t.elements.popper, o) && (t.elements.arrow = o));
}
const D3 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: B3,
  effect: F3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function es(e) {
  return e.split("-")[1];
}
var $3 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function V3(e, t) {
  var n = e.x, r = e.y, o = t.devicePixelRatio || 1;
  return {
    x: qi(n * o) / o || 0,
    y: qi(r * o) / o || 0
  };
}
function Uv(e) {
  var t, n = e.popper, r = e.popperRect, o = e.placement, i = e.variation, s = e.offsets, a = e.position, c = e.gpuAcceleration, l = e.adaptive, u = e.roundOffsets, d = e.isFixed, f = s.x, p = f === void 0 ? 0 : f, m = s.y, h = m === void 0 ? 0 : m, g = typeof u == "function" ? u({
    x: p,
    y: h
  }) : {
    x: p,
    y: h
  };
  p = g.x, h = g.y;
  var v = s.hasOwnProperty("x"), y = s.hasOwnProperty("y"), x = hn, S = pn, C = window;
  if (l) {
    var w = Ma(n), I = "clientHeight", P = "clientWidth";
    if (w === kn(n) && (w = uo(n), Gr(w).position !== "static" && a === "absolute" && (I = "scrollHeight", P = "scrollWidth")), w = w, o === pn || (o === hn || o === zn) && i === da) {
      S = Ln;
      var k = d && w === C && C.visualViewport ? C.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[I]
      );
      h -= k - r.height, h *= c ? 1 : -1;
    }
    if (o === hn || (o === pn || o === Ln) && i === da) {
      x = zn;
      var A = d && w === C && C.visualViewport ? C.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[P]
      );
      p -= A - r.width, p *= c ? 1 : -1;
    }
  }
  var N = Object.assign({
    position: a
  }, l && $3), B = u === !0 ? V3({
    x: p,
    y: h
  }, kn(n)) : {
    x: p,
    y: h
  };
  if (p = B.x, h = B.y, c) {
    var L;
    return Object.assign({}, N, (L = {}, L[S] = y ? "0" : "", L[x] = v ? "0" : "", L.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + h + "px)" : "translate3d(" + p + "px, " + h + "px, 0)", L));
  }
  return Object.assign({}, N, (t = {}, t[S] = y ? h + "px" : "", t[x] = v ? p + "px" : "", t.transform = "", t));
}
function L3(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, o = r === void 0 ? !0 : r, i = n.adaptive, s = i === void 0 ? !0 : i, a = n.roundOffsets, c = a === void 0 ? !0 : a, l = {
    placement: gr(t.placement),
    variation: es(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: o,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Uv(Object.assign({}, l, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: s,
    roundOffsets: c
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Uv(Object.assign({}, l, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const z3 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: L3,
  data: {}
};
var cc = {
  passive: !0
};
function G3(e) {
  var t = e.state, n = e.instance, r = e.options, o = r.scroll, i = o === void 0 ? !0 : o, s = r.resize, a = s === void 0 ? !0 : s, c = kn(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return i && l.forEach(function(u) {
    u.addEventListener("scroll", n.update, cc);
  }), a && c.addEventListener("resize", n.update, cc), function() {
    i && l.forEach(function(u) {
      u.removeEventListener("scroll", n.update, cc);
    }), a && c.removeEventListener("resize", n.update, cc);
  };
}
const W3 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: G3,
  data: {}
};
var H3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function zc(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return H3[t];
  });
}
var j3 = {
  start: "end",
  end: "start"
};
function Jv(e) {
  return e.replace(/start|end/g, function(t) {
    return j3[t];
  });
}
function wm(e) {
  var t = kn(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function Pm(e) {
  return Qi(uo(e)).left + wm(e).scrollLeft;
}
function X3(e, t) {
  var n = kn(e), r = uo(e), o = n.visualViewport, i = r.clientWidth, s = r.clientHeight, a = 0, c = 0;
  if (o) {
    i = o.width, s = o.height;
    var l = VC();
    (l || !l && t === "fixed") && (a = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: a + Pm(e),
    y: c
  };
}
function Y3(e) {
  var t, n = uo(e), r = wm(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, i = Bo(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = Bo(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), a = -r.scrollLeft + Pm(e), c = -r.scrollTop;
  return Gr(o || n).direction === "rtl" && (a += Bo(n.clientWidth, o ? o.clientWidth : 0) - i), {
    width: i,
    height: s,
    x: a,
    y: c
  };
}
function km(e) {
  var t = Gr(e), n = t.overflow, r = t.overflowX, o = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function HC(e) {
  return ["html", "body", "#document"].indexOf(br(e)) >= 0 ? e.ownerDocument.body : $n(e) && km(e) ? e : HC(gu(e));
}
function Us(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = HC(e), o = r === ((n = e.ownerDocument) == null ? void 0 : n.body), i = kn(r), s = o ? [i].concat(i.visualViewport || [], km(r) ? r : []) : r, a = t.concat(s);
  return o ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Us(gu(s)))
  );
}
function vp(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function Z3(e, t) {
  var n = Qi(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function Kv(e, t, n) {
  return t === DC ? vp(X3(e, n)) : Ho(t) ? Z3(t, n) : vp(Y3(uo(e)));
}
function U3(e) {
  var t = Us(gu(e)), n = ["absolute", "fixed"].indexOf(Gr(e).position) >= 0, r = n && $n(e) ? Ma(e) : e;
  return Ho(r) ? t.filter(function(o) {
    return Ho(o) && LC(o, r) && br(o) !== "body";
  }) : [];
}
function J3(e, t, n, r) {
  var o = t === "clippingParents" ? U3(e) : [].concat(t), i = [].concat(o, [n]), s = i[0], a = i.reduce(function(c, l) {
    var u = Kv(e, l, r);
    return c.top = Bo(u.top, c.top), c.right = Sl(u.right, c.right), c.bottom = Sl(u.bottom, c.bottom), c.left = Bo(u.left, c.left), c;
  }, Kv(e, s, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function jC(e) {
  var t = e.reference, n = e.element, r = e.placement, o = r ? gr(r) : null, i = r ? es(r) : null, s = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, c;
  switch (o) {
    case pn:
      c = {
        x: s,
        y: t.y - n.height
      };
      break;
    case Ln:
      c = {
        x: s,
        y: t.y + t.height
      };
      break;
    case zn:
      c = {
        x: t.x + t.width,
        y: a
      };
      break;
    case hn:
      c = {
        x: t.x - n.width,
        y: a
      };
      break;
    default:
      c = {
        x: t.x,
        y: t.y
      };
  }
  var l = o ? Im(o) : null;
  if (l != null) {
    var u = l === "y" ? "height" : "width";
    switch (i) {
      case Ki:
        c[l] = c[l] - (t[u] / 2 - n[u] / 2);
        break;
      case da:
        c[l] = c[l] + (t[u] / 2 - n[u] / 2);
        break;
    }
  }
  return c;
}
function fa(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, o = r === void 0 ? e.placement : r, i = n.strategy, s = i === void 0 ? e.strategy : i, a = n.boundary, c = a === void 0 ? g3 : a, l = n.rootBoundary, u = l === void 0 ? DC : l, d = n.elementContext, f = d === void 0 ? xs : d, p = n.altBoundary, m = p === void 0 ? !1 : p, h = n.padding, g = h === void 0 ? 0 : h, v = GC(typeof g != "number" ? g : WC(g, Na)), y = f === xs ? b3 : xs, x = e.rects.popper, S = e.elements[m ? y : f], C = J3(Ho(S) ? S : S.contextElement || uo(e.elements.popper), c, u, s), w = Qi(e.elements.reference), I = jC({
    reference: w,
    element: x,
    placement: o
  }), P = vp(Object.assign({}, x, I)), k = f === xs ? P : w, A = {
    top: C.top - k.top + v.top,
    bottom: k.bottom - C.bottom + v.bottom,
    left: C.left - k.left + v.left,
    right: k.right - C.right + v.right
  }, N = e.modifiersData.offset;
  if (f === xs && N) {
    var B = N[o];
    Object.keys(A).forEach(function(L) {
      var Z = [zn, Ln].indexOf(L) >= 0 ? 1 : -1, ne = [pn, Ln].indexOf(L) >= 0 ? "y" : "x";
      A[L] += B[ne] * Z;
    });
  }
  return A;
}
function K3(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, o = n.boundary, i = n.rootBoundary, s = n.padding, a = n.flipVariations, c = n.allowedAutoPlacements, l = c === void 0 ? $C : c, u = es(r), d = u ? a ? Yv : Yv.filter(function(m) {
    return es(m) === u;
  }) : Na, f = d.filter(function(m) {
    return l.indexOf(m) >= 0;
  });
  f.length === 0 && (f = d);
  var p = f.reduce(function(m, h) {
    return m[h] = fa(e, {
      placement: h,
      boundary: o,
      rootBoundary: i,
      padding: s
    })[gr(h)], m;
  }, {});
  return Object.keys(p).sort(function(m, h) {
    return p[m] - p[h];
  });
}
function q3(e) {
  if (gr(e) === Sm)
    return [];
  var t = zc(e);
  return [Jv(e), t, Jv(t)];
}
function Q3(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, a = s === void 0 ? !0 : s, c = n.fallbackPlacements, l = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, h = n.allowedAutoPlacements, g = t.options.placement, v = gr(g), y = v === g, x = c || (y || !m ? [zc(g)] : q3(g)), S = [g].concat(x).reduce(function(M, F) {
      return M.concat(gr(F) === Sm ? K3(t, {
        placement: F,
        boundary: u,
        rootBoundary: d,
        padding: l,
        flipVariations: m,
        allowedAutoPlacements: h
      }) : F);
    }, []), C = t.rects.reference, w = t.rects.popper, I = /* @__PURE__ */ new Map(), P = !0, k = S[0], A = 0; A < S.length; A++) {
      var N = S[A], B = gr(N), L = es(N) === Ki, Z = [pn, Ln].indexOf(B) >= 0, ne = Z ? "width" : "height", W = fa(t, {
        placement: N,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: l
      }), O = Z ? L ? zn : hn : L ? Ln : pn;
      C[ne] > w[ne] && (O = zc(O));
      var J = zc(O), ee = [];
      if (i && ee.push(W[B] <= 0), a && ee.push(W[O] <= 0, W[J] <= 0), ee.every(function(M) {
        return M;
      })) {
        k = N, P = !1;
        break;
      }
      I.set(N, ee);
    }
    if (P)
      for (var H = m ? 3 : 1, _ = function(F) {
        var G = S.find(function(q) {
          var te = I.get(q);
          if (te)
            return te.slice(0, F).every(function(U) {
              return U;
            });
        });
        if (G)
          return k = G, "break";
      }, j = H; j > 0; j--) {
        var E = _(j);
        if (E === "break") break;
      }
    t.placement !== k && (t.modifiersData[r]._skip = !0, t.placement = k, t.reset = !0);
  }
}
const e9 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Q3,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function qv(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function Qv(e) {
  return [pn, zn, Ln, hn].some(function(t) {
    return e[t] >= 0;
  });
}
function t9(e) {
  var t = e.state, n = e.name, r = t.rects.reference, o = t.rects.popper, i = t.modifiersData.preventOverflow, s = fa(t, {
    elementContext: "reference"
  }), a = fa(t, {
    altBoundary: !0
  }), c = qv(s, r), l = qv(a, o, i), u = Qv(c), d = Qv(l);
  t.modifiersData[n] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: l,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
const n9 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: t9
};
function r9(e, t, n) {
  var r = gr(e), o = [hn, pn].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, s = i[0], a = i[1];
  return s = s || 0, a = (a || 0) * o, [hn, zn].indexOf(r) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function o9(e) {
  var t = e.state, n = e.options, r = e.name, o = n.offset, i = o === void 0 ? [0, 0] : o, s = $C.reduce(function(u, d) {
    return u[d] = r9(d, t.rects, i), u;
  }, {}), a = s[t.placement], c = a.x, l = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += l), t.modifiersData[r] = s;
}
const i9 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: o9
};
function s9(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = jC({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const a9 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: s9,
  data: {}
};
function c9(e) {
  return e === "x" ? "y" : "x";
}
function l9(e) {
  var t = e.state, n = e.options, r = e.name, o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, a = s === void 0 ? !1 : s, c = n.boundary, l = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, p = f === void 0 ? !0 : f, m = n.tetherOffset, h = m === void 0 ? 0 : m, g = fa(t, {
    boundary: c,
    rootBoundary: l,
    padding: d,
    altBoundary: u
  }), v = gr(t.placement), y = es(t.placement), x = !y, S = Im(v), C = c9(S), w = t.modifiersData.popperOffsets, I = t.rects.reference, P = t.rects.popper, k = typeof h == "function" ? h(Object.assign({}, t.rects, {
    placement: t.placement
  })) : h, A = typeof k == "number" ? {
    mainAxis: k,
    altAxis: k
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, k), N = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, B = {
    x: 0,
    y: 0
  };
  if (w) {
    if (i) {
      var L, Z = S === "y" ? pn : hn, ne = S === "y" ? Ln : zn, W = S === "y" ? "height" : "width", O = w[S], J = O + g[Z], ee = O - g[ne], H = p ? -P[W] / 2 : 0, _ = y === Ki ? I[W] : P[W], j = y === Ki ? -P[W] : -I[W], E = t.elements.arrow, M = p && E ? Cm(E) : {
        width: 0,
        height: 0
      }, F = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : zC(), G = F[Z], q = F[ne], te = Zs(0, I[W], M[W]), U = x ? I[W] / 2 - H - te - G - A.mainAxis : _ - te - G - A.mainAxis, K = x ? -I[W] / 2 + H + te + q + A.mainAxis : j + te + q + A.mainAxis, ae = t.elements.arrow && Ma(t.elements.arrow), Y = ae ? S === "y" ? ae.clientTop || 0 : ae.clientLeft || 0 : 0, ce = (L = N?.[S]) != null ? L : 0, re = O + U - ce - Y, Ce = O + K - ce, Ve = Zs(p ? Sl(J, re) : J, O, p ? Bo(ee, Ce) : ee);
      w[S] = Ve, B[S] = Ve - O;
    }
    if (a) {
      var le, Pe = S === "x" ? pn : hn, ve = S === "x" ? Ln : zn, he = w[C], _e = C === "y" ? "height" : "width", Oe = he + g[Pe], ze = he - g[ve], Ye = [pn, hn].indexOf(v) !== -1, Yt = (le = N?.[C]) != null ? le : 0, Kt = Ye ? Oe : he - I[_e] - P[_e] - Yt + A.altAxis, tn = Ye ? he + I[_e] + P[_e] - Yt - A.altAxis : ze, de = p && Ye ? N3(Kt, he, tn) : Zs(p ? Kt : Oe, he, p ? tn : ze);
      w[C] = de, B[C] = de - he;
    }
    t.modifiersData[r] = B;
  }
}
const u9 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: l9,
  requiresIfExists: ["offset"]
};
function d9(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function f9(e) {
  return e === kn(e) || !$n(e) ? wm(e) : d9(e);
}
function p9(e) {
  var t = e.getBoundingClientRect(), n = qi(t.width) / e.offsetWidth || 1, r = qi(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function h9(e, t, n) {
  n === void 0 && (n = !1);
  var r = $n(t), o = $n(t) && p9(t), i = uo(t), s = Qi(e, o, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((br(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  km(i)) && (a = f9(t)), $n(t) ? (c = Qi(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : i && (c.x = Pm(i))), {
    x: s.left + a.scrollLeft - c.x,
    y: s.top + a.scrollTop - c.y,
    width: s.width,
    height: s.height
  };
}
function m9(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(i) {
    t.set(i.name, i);
  });
  function o(i) {
    n.add(i.name);
    var s = [].concat(i.requires || [], i.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var c = t.get(a);
        c && o(c);
      }
    }), r.push(i);
  }
  return e.forEach(function(i) {
    n.has(i.name) || o(i);
  }), r;
}
function g9(e) {
  var t = m9(e);
  return A3.reduce(function(n, r) {
    return n.concat(t.filter(function(o) {
      return o.phase === r;
    }));
  }, []);
}
function b9(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function v9(e) {
  var t = e.reduce(function(n, r) {
    var o = n[r.name];
    return n[r.name] = o ? Object.assign({}, o, r, {
      options: Object.assign({}, o.options, r.options),
      data: Object.assign({}, o.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var ey = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function ty() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function y9(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, o = t.defaultOptions, i = o === void 0 ? ey : o;
  return function(a, c, l) {
    l === void 0 && (l = i);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ey, i),
      modifiersData: {},
      elements: {
        reference: a,
        popper: c
      },
      attributes: {},
      styles: {}
    }, d = [], f = !1, p = {
      state: u,
      setOptions: function(v) {
        var y = typeof v == "function" ? v(u.options) : v;
        h(), u.options = Object.assign({}, i, u.options, y), u.scrollParents = {
          reference: Ho(a) ? Us(a) : a.contextElement ? Us(a.contextElement) : [],
          popper: Us(c)
        };
        var x = g9(v9([].concat(r, u.options.modifiers)));
        return u.orderedModifiers = x.filter(function(S) {
          return S.enabled;
        }), m(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var v = u.elements, y = v.reference, x = v.popper;
          if (ty(y, x)) {
            u.rects = {
              reference: h9(y, Ma(x), u.options.strategy === "fixed"),
              popper: Cm(x)
            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(A) {
              return u.modifiersData[A.name] = Object.assign({}, A.data);
            });
            for (var S = 0; S < u.orderedModifiers.length; S++) {
              if (u.reset === !0) {
                u.reset = !1, S = -1;
                continue;
              }
              var C = u.orderedModifiers[S], w = C.fn, I = C.options, P = I === void 0 ? {} : I, k = C.name;
              typeof w == "function" && (u = w({
                state: u,
                options: P,
                name: k,
                instance: p
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: b9(function() {
        return new Promise(function(g) {
          p.forceUpdate(), g(u);
        });
      }),
      destroy: function() {
        h(), f = !0;
      }
    };
    if (!ty(a, c))
      return p;
    p.setOptions(l).then(function(g) {
      !f && l.onFirstUpdate && l.onFirstUpdate(g);
    });
    function m() {
      u.orderedModifiers.forEach(function(g) {
        var v = g.name, y = g.options, x = y === void 0 ? {} : y, S = g.effect;
        if (typeof S == "function") {
          var C = S({
            state: u,
            name: v,
            instance: p,
            options: x
          }), w = function() {
          };
          d.push(C || w);
        }
      });
    }
    function h() {
      d.forEach(function(g) {
        return g();
      }), d = [];
    }
    return p;
  };
}
var S9 = [W3, a9, z3, R3, i9, e9, u9, D3, n9], x9 = /* @__PURE__ */ y9({
  defaultModifiers: S9
});
const ci = (e, t) => ({
  var: e,
  varRef: t ? `var(${e}, ${t})` : `var(${e})`
}), Dt = {
  arrowShadowColor: ci("--popper-arrow-shadow-color"),
  arrowSize: ci("--popper-arrow-size", "8px"),
  arrowSizeHalf: ci("--popper-arrow-size-half"),
  arrowBg: ci("--popper-arrow-bg"),
  transformOrigin: ci("--popper-transform-origin"),
  arrowOffset: ci("--popper-arrow-offset")
};
function C9(e) {
  if (e.includes("top"))
    return "1px 1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("bottom"))
    return "-1px -1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("right"))
    return "-1px 1px 0px 0 var(--popper-arrow-shadow-color)";
  if (e.includes("left"))
    return "1px -1px 0px 0 var(--popper-arrow-shadow-color)";
}
const I9 = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
}, w9 = (e) => I9[e], ny = {
  scroll: !0,
  resize: !0
};
function P9(e) {
  let t;
  return typeof e == "object" ? t = {
    enabled: !0,
    options: { ...ny, ...e }
  } : t = {
    enabled: e,
    options: ny
  }, t;
}
const k9 = {
  name: "matchWidth",
  enabled: !0,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: e }) => {
    e.styles.popper.width = `${e.rects.reference.width}px`;
  },
  effect: ({ state: e }) => () => {
    const t = e.elements.reference;
    e.elements.popper.style.width = `${t.offsetWidth}px`;
  }
}, A9 = {
  name: "transformOrigin",
  enabled: !0,
  phase: "write",
  fn: ({ state: e }) => {
    ry(e);
  },
  effect: ({ state: e }) => () => {
    ry(e);
  }
}, ry = (e) => {
  e.elements.popper.style.setProperty(
    Dt.transformOrigin.var,
    w9(e.placement)
  );
}, T9 = {
  name: "positionArrow",
  enabled: !0,
  phase: "afterWrite",
  fn: ({ state: e }) => {
    E9(e);
  }
}, E9 = (e) => {
  if (!e.placement)
    return;
  const t = R9(e.placement);
  if (e.elements?.arrow && t) {
    Object.assign(e.elements.arrow.style, {
      [t.property]: t.value,
      width: Dt.arrowSize.varRef,
      height: Dt.arrowSize.varRef,
      zIndex: -1
    });
    const n = {
      [Dt.arrowSizeHalf.var]: `calc(${Dt.arrowSize.varRef} / 2 - 1px)`,
      [Dt.arrowOffset.var]: `calc(${Dt.arrowSizeHalf.varRef} * -1)`
    };
    for (const r in n)
      e.elements.arrow.style.setProperty(r, n[r]);
  }
}, R9 = (e) => {
  if (e.startsWith("top"))
    return { property: "bottom", value: Dt.arrowOffset.varRef };
  if (e.startsWith("bottom"))
    return { property: "top", value: Dt.arrowOffset.varRef };
  if (e.startsWith("left"))
    return { property: "right", value: Dt.arrowOffset.varRef };
  if (e.startsWith("right"))
    return { property: "left", value: Dt.arrowOffset.varRef };
}, _9 = {
  name: "innerArrow",
  enabled: !0,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: e }) => {
    oy(e);
  },
  effect: ({ state: e }) => () => {
    oy(e);
  }
}, oy = (e) => {
  if (!e.elements.arrow)
    return;
  const t = e.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!t)
    return;
  const n = C9(e.placement);
  n && t.style.setProperty("--popper-arrow-default-shadow", n), Object.assign(t.style, {
    transform: "rotate(45deg)",
    background: Dt.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: "var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))"
  });
}, O9 = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
}, N9 = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function M9(e, t = "ltr") {
  const n = O9[e]?.[t] || e;
  return t === "ltr" ? n : N9[e] ?? n;
}
function Am(e = {}) {
  const {
    enabled: t = !0,
    modifiers: n,
    placement: r = "bottom",
    strategy: o = "absolute",
    arrowPadding: i = 8,
    eventListeners: s = !0,
    offset: a,
    gutter: c = 8,
    flip: l = !0,
    boundary: u = "clippingParents",
    preventOverflow: d = !0,
    matchWidth: f,
    direction: p = "ltr"
  } = e, m = se(null), h = se(null), g = se(null), v = M9(r, p), y = se(() => {
  }), x = R(() => {
    !t || !m.current || !h.current || (y.current?.(), g.current = x9(m.current, h.current, {
      placement: v,
      modifiers: [
        _9,
        T9,
        A9,
        {
          ...k9,
          enabled: !!f
        },
        {
          name: "eventListeners",
          ...P9(s)
        },
        {
          name: "arrow",
          options: { padding: i }
        },
        {
          name: "offset",
          options: {
            offset: a ?? [0, c]
          }
        },
        {
          name: "flip",
          enabled: !!l,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!d,
          options: { boundary: u }
        },
        // allow users override internal modifiers
        ...n ?? []
      ],
      strategy: o
    }), g.current.forceUpdate(), y.current = g.current.destroy);
  }, [
    v,
    t,
    n,
    f,
    s,
    i,
    a,
    c,
    l,
    d,
    u,
    o
  ]);
  ge(() => () => {
    !m.current && !h.current && (g.current?.destroy(), g.current = null);
  }, []);
  const S = R(
    (A) => {
      m.current = A, x();
    },
    [x]
  ), C = R(
    (A = {}, N = null) => ({
      ...A,
      ref: Ge(S, N)
    }),
    [S]
  ), w = R(
    (A) => {
      h.current = A, x();
    },
    [x]
  ), I = R(
    (A = {}, N = null) => ({
      ...A,
      ref: Ge(w, N),
      style: {
        ...A.style,
        position: o,
        minWidth: f ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [o, w, f]
  ), P = R((A = {}, N = null) => {
    const { size: B, shadowColor: L, bg: Z, style: ne, ...W } = A;
    return {
      ...W,
      ref: N,
      "data-popper-arrow": "",
      style: B9(A)
    };
  }, []), k = R(
    (A = {}, N = null) => ({
      ...A,
      ref: N,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      g.current?.update();
    },
    forceUpdate() {
      g.current?.forceUpdate();
    },
    transformOrigin: Dt.transformOrigin.varRef,
    referenceRef: S,
    popperRef: w,
    getPopperProps: I,
    getArrowProps: P,
    getArrowInnerProps: k,
    getReferenceProps: C
  };
}
function B9(e) {
  const { size: t, shadowColor: n, bg: r, style: o } = e, i = { ...o, position: "absolute" };
  return t && (i["--popper-arrow-size"] = t), n && (i["--popper-arrow-shadow-color"] = n), r && (i["--popper-arrow-bg"] = r), i;
}
function F9() {
  const e = se(/* @__PURE__ */ new Map()), t = e.current, n = R((o, i, s, a) => {
    e.current.set(s, { type: i, el: o, options: a }), o.addEventListener(i, s, a);
  }, []), r = R(
    (o, i, s, a) => {
      o.removeEventListener(i, s, a), e.current.delete(s);
    },
    []
  );
  return ge(
    () => () => {
      t.forEach((o, i) => {
        r(o.el, o.type, i, o.options);
      });
    },
    [r, t]
  ), { add: n, remove: r };
}
function tf(e) {
  const t = e.composedPath?.()?.[0] ?? e.target, { tagName: n, isContentEditable: r } = t;
  return n !== "INPUT" && n !== "TEXTAREA" && r !== !0;
}
function XC(e = {}) {
  const {
    ref: t,
    isDisabled: n,
    isFocusable: r,
    clickOnEnter: o = !0,
    clickOnSpace: i = !0,
    onMouseDown: s,
    onMouseUp: a,
    onClick: c,
    onKeyDown: l,
    onKeyUp: u,
    tabIndex: d,
    onMouseOver: f,
    onMouseLeave: p,
    ...m
  } = e, [h, g] = ue(!0), [v, y] = ue(!1), x = F9(), S = (O) => {
    O && O.tagName !== "BUTTON" && g(!1);
  }, C = h ? d : d || 0, w = n && !r, I = R(
    (O) => {
      if (n) {
        O.stopPropagation(), O.preventDefault();
        return;
      }
      O.currentTarget.focus(), c?.(O);
    },
    [n, c]
  ), P = R(
    (O) => {
      v && tf(O) && (O.preventDefault(), O.stopPropagation(), y(!1), x.remove(document, "keyup", P, !1));
    },
    [v, x]
  ), k = R(
    (O) => {
      if (l?.(O), n || O.defaultPrevented || O.metaKey || !tf(O.nativeEvent) || h)
        return;
      const J = o && O.key === "Enter";
      i && O.key === " " && (O.preventDefault(), y(!0)), J && (O.preventDefault(), O.currentTarget.click()), x.add(document, "keyup", P, !1);
    },
    [
      n,
      h,
      l,
      o,
      i,
      x,
      P
    ]
  ), A = R(
    (O) => {
      if (u?.(O), n || O.defaultPrevented || O.metaKey || !tf(O.nativeEvent) || h)
        return;
      i && O.key === " " && (O.preventDefault(), y(!1), O.currentTarget.click());
    },
    [i, h, n, u]
  ), N = R(
    (O) => {
      O.button === 0 && (y(!1), x.remove(document, "mouseup", N, !1));
    },
    [x]
  ), B = R(
    (O) => {
      if (O.button !== 0)
        return;
      if (n) {
        O.stopPropagation(), O.preventDefault();
        return;
      }
      h || y(!0), O.currentTarget.focus({ preventScroll: !0 }), x.add(document, "mouseup", N, !1), s?.(O);
    },
    [n, h, s, x, N]
  ), L = R(
    (O) => {
      O.button === 0 && (h || y(!1), a?.(O));
    },
    [a, h]
  ), Z = R(
    (O) => {
      if (n) {
        O.preventDefault();
        return;
      }
      f?.(O);
    },
    [n, f]
  ), ne = R(
    (O) => {
      v && (O.preventDefault(), y(!1)), p?.(O);
    },
    [v, p]
  ), W = Ge(t, S);
  return h ? {
    ...m,
    ref: W,
    type: "button",
    "aria-disabled": w ? void 0 : n,
    disabled: w,
    onClick: I,
    onMouseDown: s,
    onMouseUp: a,
    onKeyUp: u,
    onKeyDown: l,
    onMouseOver: f,
    onMouseLeave: p
  } : {
    ...m,
    ref: W,
    role: "button",
    "data-active": ye(v),
    "aria-disabled": n ? "true" : void 0,
    tabIndex: w ? void 0 : C,
    onClick: I,
    onMouseDown: B,
    onMouseUp: L,
    onKeyUp: A,
    onKeyDown: k,
    onMouseOver: Z,
    onMouseLeave: ne
  };
}
const [
  D9,
  $9,
  V9,
  L9
] = du(), [z9, Ba] = De({
  strict: !1,
  name: "MenuContext"
});
function YC(e) {
  return e?.ownerDocument ?? document;
}
function G9(e) {
  return YC(e).activeElement === e;
}
function W9(e = {}) {
  const {
    id: t,
    closeOnSelect: n = !0,
    closeOnBlur: r = !0,
    initialFocusRef: o,
    autoSelect: i = !0,
    isLazy: s,
    isOpen: a,
    defaultIsOpen: c,
    onClose: l,
    onOpen: u,
    placement: d = "bottom-start",
    lazyBehavior: f = "unmount",
    direction: p,
    computePositionOnMount: m = !1,
    ...h
  } = e, g = se(null), v = se(null), y = se(!0), x = V9(), S = R(() => {
    requestAnimationFrame(() => {
      g.current?.focus({ preventScroll: !1 });
    });
  }, []), C = R(() => {
    const E = setTimeout(() => {
      if (o)
        o.current?.focus();
      else if (!x.count())
        g.current?.focus({ preventScroll: !1 });
      else {
        const M = x.firstEnabled();
        M && Z(M.index);
      }
    });
    ee.current.add(E);
  }, [x, o]), w = R(() => {
    const E = setTimeout(() => {
      if (!x.count())
        g.current?.focus({ preventScroll: !1 });
      else {
        const M = x.lastEnabled();
        M && Z(M.index);
      }
    });
    ee.current.add(E);
  }, [x]), I = R(() => {
    u?.(), i ? C() : S();
  }, [i, C, S, u]), { isOpen: P, onOpen: k, onClose: A, onToggle: N } = Hl({
    isOpen: a,
    defaultIsOpen: c,
    onClose: l,
    onOpen: I
  });
  U0({
    enabled: P && r,
    ref: g,
    handler: (E) => {
      const M = E.composedPath?.()?.[0] ?? E.target;
      v.current?.contains(M) || A();
    }
  });
  const B = Am({
    ...h,
    enabled: P || m,
    placement: d,
    direction: p
  }), [L, Z] = ue(-1);
  j0(g, {
    focusRef: v,
    visible: P,
    shouldFocus: !0
  });
  const ne = W0({ isOpen: P, ref: g }), [W, O] = JA(t, "menu-button", "menu-list"), J = R(() => {
    k(), S();
  }, [k, S]), ee = se(/* @__PURE__ */ new Set([]));
  ge(() => {
    const E = ee.current;
    return () => {
      E.forEach((M) => clearTimeout(M)), E.clear();
    };
  }, []), Jn(() => {
    P || (Z(-1), g.current?.scrollTo(0, 0));
  }, [P]), Jn(() => {
    P && L === -1 && S();
  }, [L, P]), ge(() => {
    if (!P)
      return;
    x.item(L)?.node?.focus({ preventScroll: !y.current });
  }, [x, L, P]);
  const H = R(() => {
    k(), C();
  }, [C, k]), _ = R(() => {
    y.current = !0, k(), w();
  }, [k, w]), j = R(() => {
    const E = YC(g.current), M = g.current?.contains(E.activeElement);
    if (!(P && !M))
      return;
    x.item(L)?.node?.focus({ preventScroll: !y.current });
  }, [P, L, x]);
  return {
    openAndFocusMenu: J,
    openAndFocusFirstItem: H,
    openAndFocusLastItem: _,
    onTransitionEnd: j,
    unstable__animationState: ne,
    descendants: x,
    popper: B,
    buttonId: W,
    menuId: O,
    forceUpdate: B.forceUpdate,
    orientation: "vertical",
    isOpen: P,
    onToggle: N,
    onOpen: k,
    onClose: A,
    menuRef: g,
    buttonRef: v,
    focusedIndex: L,
    closeOnSelect: n,
    closeOnBlur: r,
    autoSelect: i,
    setFocusedIndex: Z,
    isLazy: s,
    lazyBehavior: f,
    initialFocusRef: o,
    scrollIntoViewRef: y
  };
}
function H9(e = {}, t = null) {
  const n = Ba(), {
    onToggle: r,
    popper: o,
    openAndFocusFirstItem: i,
    openAndFocusLastItem: s,
    scrollIntoViewRef: a
  } = n, c = R(
    (l) => {
      const u = l.key, f = {
        Enter: i,
        ArrowDown: i,
        ArrowUp: s
      }[u];
      f && (a.current = !0, l.preventDefault(), l.stopPropagation(), f(l));
    },
    [i, s, a]
  );
  return {
    ...e,
    ref: Ge(n.buttonRef, t, o.referenceRef),
    id: n.buttonId,
    "data-active": ye(n.isOpen),
    "aria-expanded": n.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": n.menuId,
    onClick: fe(e.onClick, r),
    onKeyDown: fe(e.onKeyDown, c)
  };
}
function yp(e) {
  return U9(e) && !!e?.getAttribute("role")?.startsWith("menuitem");
}
function j9(e = {}, t = null) {
  const n = Ba();
  if (!n)
    throw new Error(
      "useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>"
    );
  const {
    focusedIndex: r,
    setFocusedIndex: o,
    menuRef: i,
    isOpen: s,
    onClose: a,
    menuId: c,
    isLazy: l,
    lazyBehavior: u,
    scrollIntoViewRef: d,
    unstable__animationState: f
  } = n, p = $9(), m = m3({
    preventDefault: (y) => y.key !== " " && yp(y.target)
  }), h = R(
    (y) => {
      if (!y.currentTarget.contains(y.target))
        return;
      const x = y.key, C = {
        Tab: (I) => I.preventDefault(),
        Escape: (I) => {
          I.stopPropagation(), a();
        },
        ArrowDown: () => {
          d.current = !0;
          const I = p.nextEnabled(r) ?? p.firstEnabled();
          I && o(I.index);
        },
        ArrowUp: () => {
          d.current = !0;
          const I = p.prevEnabled(r) ?? p.firstEnabled();
          I && o(I.index);
        }
      }[x];
      if (C) {
        y.preventDefault(), C(y);
        return;
      }
      const w = m((I) => {
        const P = p3(
          p.values(),
          I,
          (k) => k?.node?.textContent ?? "",
          p.item(r)
        );
        if (P) {
          const k = p.indexOf(P.node);
          o(k);
        }
      });
      yp(y.target) && w(y);
    },
    [
      p,
      r,
      m,
      a,
      o,
      d
    ]
  ), g = se(!1);
  s && (g.current = !0);
  const v = nh({
    wasSelected: g.current,
    enabled: l,
    mode: u,
    isSelected: f.present
  });
  return {
    ...e,
    ref: Ge(i, t),
    children: v ? e.children : null,
    tabIndex: -1,
    role: "menu",
    id: c,
    style: {
      ...e.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: fe(e.onKeyDown, h)
  };
}
function X9(e = {}) {
  const { popper: t, isOpen: n } = Ba();
  return t.getPopperProps({
    ...e,
    style: {
      visibility: n ? "visible" : "hidden",
      ...e.style
    }
  });
}
function ZC(e = {}, t = null) {
  const {
    onMouseEnter: n,
    onMouseMove: r,
    onMouseLeave: o,
    onClick: i,
    onFocus: s,
    isDisabled: a,
    isFocusable: c,
    closeOnSelect: l,
    type: u,
    ...d
  } = e, f = Ba(), {
    setFocusedIndex: p,
    focusedIndex: m,
    closeOnSelect: h,
    onClose: g,
    menuId: v,
    scrollIntoViewRef: y
  } = f, x = se(null), S = `${v}-menuitem-${Xt()}`, { index: C, register: w } = L9({
    disabled: a && !c
  }), I = R(
    (Z) => {
      n?.(Z), !a && (y.current = !1, p(C));
    },
    [p, C, a, n, y]
  ), P = R(
    (Z) => {
      r?.(Z), x.current && !G9(x.current) && I(Z);
    },
    [I, r]
  ), k = R(
    (Z) => {
      o?.(Z), !a && p(-1);
    },
    [p, a, o]
  ), A = R(
    (Z) => {
      i?.(Z), yp(Z.currentTarget) && (l ?? h) && g();
    },
    [g, i, h, l]
  ), N = R(
    (Z) => {
      s?.(Z), p(C);
    },
    [p, s, C]
  ), B = C === m, L = XC({
    onClick: A,
    onFocus: N,
    onMouseEnter: I,
    onMouseMove: P,
    onMouseLeave: k,
    ref: Ge(w, x, t),
    isDisabled: a,
    isFocusable: c
  });
  return {
    ...d,
    ...L,
    type: u ?? L.type,
    id: S,
    role: "menuitem",
    tabIndex: B ? 0 : -1
  };
}
function Y9(e = {}, t = null) {
  const { type: n = "radio", isChecked: r, ...o } = e;
  return {
    ...ZC(o, t),
    role: `menuitem${n}`,
    "aria-checked": r
  };
}
function Z9(e = {}) {
  const {
    children: t,
    type: n = "radio",
    value: r,
    defaultValue: o,
    onChange: i,
    ...s
  } = e, c = n === "radio" ? "" : [], [l, u] = co({
    defaultValue: o ?? c,
    value: r,
    onChange: i
  }), d = R(
    (m) => {
      if (n === "radio" && typeof l == "string" && u(m), n === "checkbox" && Array.isArray(l)) {
        const h = l.includes(m) ? l.filter((g) => g !== m) : l.concat(m);
        u(h);
      }
    },
    [l, u, n]
  ), p = Hr(t).map((m) => {
    if (m.type.id !== "MenuItemOption")
      return m;
    const h = (v) => {
      d(m.props.value), m.props.onClick?.(v);
    }, g = n === "radio" ? m.props.value === l : l.includes(m.props.value);
    return Lt(m, {
      type: n,
      onClick: h,
      isChecked: g
    });
  });
  return {
    ...s,
    children: p
  };
}
function U9(e) {
  if (!J9(e))
    return !1;
  const t = e.ownerDocument.defaultView ?? window;
  return e instanceof t.HTMLElement;
}
function J9(e) {
  return e != null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
const [K9, Uo] = De({
  name: "MenuStylesContext",
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
}), Tm = (e) => {
  const { children: t } = e, n = We("Menu", e), r = $e(e), { direction: o } = bn(), { descendants: i, ...s } = W9({ ...r, direction: o }), a = be(() => s, [s]), { isOpen: c, onClose: l, forceUpdate: u } = a;
  return /* @__PURE__ */ b(D9, { value: i, children: /* @__PURE__ */ b(z9, { value: a, children: /* @__PURE__ */ b(K9, { value: n, children: jt(t, { isOpen: c, onClose: l, forceUpdate: u }) }) }) });
};
Tm.displayName = "Menu";
const q9 = X((e, t) => {
  const n = Uo();
  return /* @__PURE__ */ b(
    z.button,
    {
      ref: t,
      ...e,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...n.button
      }
    }
  );
}), UC = X(
  (e, t) => {
    const { children: n, as: r, ...o } = e, i = H9(o, t);
    return /* @__PURE__ */ b(
      r || q9,
      {
        ...i,
        className: oe("chakra-menu__menu-button", e.className),
        children: /* @__PURE__ */ b(
          z.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: e.children
          }
        )
      }
    );
  }
);
UC.displayName = "MenuButton";
const JC = X(
  (e, t) => {
    const n = Uo();
    return /* @__PURE__ */ b(
      z.span,
      {
        ref: t,
        ...e,
        __css: n.command,
        className: "chakra-menu__command"
      }
    );
  }
);
JC.displayName = "MenuCommand";
const Q9 = (e) => {
  const { className: t, ...n } = e, r = Uo();
  return /* @__PURE__ */ b(
    z.hr,
    {
      "aria-orientation": "horizontal",
      className: oe("chakra-menu__divider", t),
      ...n,
      __css: r.divider
    }
  );
};
Q9.displayName = "MenuDivider";
const KC = X((e, t) => {
  const { title: n, children: r, className: o, ...i } = e, s = oe("chakra-menu__group__title", o), a = Uo();
  return /* @__PURE__ */ Ae("div", { ref: t, className: "chakra-menu__group", role: "group", children: [
    n && /* @__PURE__ */ b(z.p, { className: s, ...i, __css: a.groupTitle, children: n }),
    r
  ] });
});
KC.displayName = "MenuGroup";
const pa = (e) => {
  const { className: t, children: n, ...r } = e, o = Uo(), i = yr.only(n), s = ao(i) ? Lt(i, {
    focusable: "false",
    "aria-hidden": !0,
    className: oe("chakra-menu__icon", i.props.className)
  }) : null, a = oe("chakra-menu__icon-wrapper", t);
  return /* @__PURE__ */ b(z.span, { className: a, ...r, __css: o.icon, children: s });
};
pa.displayName = "MenuIcon";
const qC = X(
  (e, t) => {
    const { type: n, ...r } = e, o = Uo(), i = r.as || n ? n ?? void 0 : "button", s = be(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...o.item
      }),
      [o.item]
    );
    return /* @__PURE__ */ b(z.button, { ref: t, type: i, ...r, __css: s });
  }
), QC = X((e, t) => {
  const {
    icon: n,
    iconSpacing: r = "0.75rem",
    command: o,
    commandSpacing: i = "0.75rem",
    children: s,
    ...a
  } = e, c = ZC(a, t), u = n || o ? /* @__PURE__ */ b("span", { style: { pointerEvents: "none", flex: 1 }, children: s }) : s;
  return /* @__PURE__ */ Ae(
    qC,
    {
      ...c,
      className: oe("chakra-menu__menuitem", c.className),
      children: [
        n && /* @__PURE__ */ b(pa, { fontSize: "0.8em", marginEnd: r, children: n }),
        u,
        o && /* @__PURE__ */ b(JC, { marginStart: i, children: o })
      ]
    }
  );
});
QC.displayName = "MenuItem";
const iy = (e) => /* @__PURE__ */ b("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", ...e, children: /* @__PURE__ */ b(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) }), eI = X(
  (e, t) => {
    const {
      icon: n,
      iconSpacing: r = "0.75rem",
      iconPlacement: o = "start",
      ...i
    } = e, s = Y9(i, t);
    return /* @__PURE__ */ Ae(
      qC,
      {
        ...s,
        className: oe("chakra-menu__menuitem-option", i.className),
        children: [
          n !== null && o === "start" && /* @__PURE__ */ b(
            pa,
            {
              fontSize: "0.8em",
              marginEnd: r,
              opacity: e.isChecked ? 1 : 0,
              children: n || /* @__PURE__ */ b(iy, {})
            }
          ),
          /* @__PURE__ */ b("span", { style: { flex: 1 }, children: s.children }),
          n !== null && o === "end" && /* @__PURE__ */ b(
            pa,
            {
              fontSize: "0.8em",
              marginStart: r,
              opacity: e.isChecked ? 1 : 0,
              children: n || /* @__PURE__ */ b(iy, {})
            }
          )
        ]
      }
    );
  }
);
eI.id = "MenuItemOption";
eI.displayName = "MenuItemOption";
const eG = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
}, tG = z(Jt.div), tI = X(
  function(t, n) {
    const { rootProps: r, motionProps: o, ...i } = t, {
      isOpen: s,
      onTransitionEnd: a,
      unstable__animationState: c
    } = Ba(), l = j9(i, n), u = X9(r), d = Uo();
    return /* @__PURE__ */ b(
      z.div,
      {
        ...u,
        __css: { zIndex: t.zIndex ?? d.list?.zIndex },
        children: /* @__PURE__ */ b(
          tG,
          {
            variants: eG,
            initial: !1,
            animate: s ? "enter" : "exit",
            __css: { outline: 0, ...d.list },
            ...o,
            ...l,
            className: oe("chakra-menu__menu-list", l.className),
            onUpdate: a,
            onAnimationComplete: Gl(
              c.onComplete,
              l.onAnimationComplete
            )
          }
        )
      }
    );
  }
);
tI.displayName = "MenuList";
const nG = (e) => {
  const { className: t, title: n, ...r } = e, o = Z9(r);
  return /* @__PURE__ */ b(
    KC,
    {
      title: n,
      className: oe("chakra-menu__option-group", t),
      ...o
    }
  );
};
nG.displayName = "MenuOptionGroup";
var rG = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, li = /* @__PURE__ */ new WeakMap(), lc = /* @__PURE__ */ new WeakMap(), uc = {}, nf = 0, nI = function(e) {
  return e && (e.host || nI(e.parentNode));
}, oG = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = nI(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, iG = function(e, t, n, r) {
  var o = oG(t, Array.isArray(e) ? e : [e]);
  uc[n] || (uc[n] = /* @__PURE__ */ new WeakMap());
  var i = uc[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(o), l = function(d) {
    !d || a.has(d) || (a.add(d), l(d.parentNode));
  };
  o.forEach(l);
  var u = function(d) {
    !d || c.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else
        try {
          var p = f.getAttribute(r), m = p !== null && p !== "false", h = (li.get(f) || 0) + 1, g = (i.get(f) || 0) + 1;
          li.set(f, h), i.set(f, g), s.push(f), h === 1 && m && lc.set(f, !0), g === 1 && f.setAttribute(n, "true"), m || f.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", f, v);
        }
    });
  };
  return u(t), a.clear(), nf++, function() {
    s.forEach(function(d) {
      var f = li.get(d) - 1, p = i.get(d) - 1;
      li.set(d, f), i.set(d, p), f || (lc.has(d) || d.removeAttribute(r), lc.delete(d)), p || d.removeAttribute(n);
    }), nf--, nf || (li = /* @__PURE__ */ new WeakMap(), li = /* @__PURE__ */ new WeakMap(), lc = /* @__PURE__ */ new WeakMap(), uc = {});
  };
}, sG = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = rG(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), iG(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, aG = Object.defineProperty, cG = (e, t, n) => t in e ? aG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, lG = (e, t, n) => (cG(e, t + "", n), n);
class uG {
  constructor() {
    lG(this, "modals"), this.modals = /* @__PURE__ */ new Set();
  }
  add(t) {
    return this.modals.add(t), this.modals.size;
  }
  remove(t) {
    this.modals.delete(t);
  }
  isTopModal(t) {
    if (!t)
      return !1;
    const n = Array.from(this.modals)[this.modals.size - 1];
    return t === n;
  }
}
const Sp = new uG();
function rI(e, t) {
  const [n, r] = ue(0);
  return ge(() => {
    const o = e.current;
    if (o) {
      if (t) {
        const i = Sp.add(o);
        r(i);
      }
      return () => {
        Sp.remove(o), r(0);
      };
    }
  }, [t, e]), n;
}
function dG(e) {
  const {
    isOpen: t,
    onClose: n,
    id: r,
    closeOnOverlayClick: o = !0,
    closeOnEsc: i = !0,
    useInert: s = !0,
    onOverlayClick: a,
    onEsc: c
  } = e, l = se(null), u = se(null), [d, f, p] = pG(
    r,
    "chakra-modal",
    "chakra-modal--header",
    "chakra-modal--body"
  );
  fG(l, t && s);
  const m = rI(l, t), h = se(null), g = R((k) => {
    h.current = k.target;
  }, []), v = R(
    (k) => {
      k.key === "Escape" && (k.stopPropagation(), i && n?.(), c?.());
    },
    [i, n, c]
  ), [y, x] = ue(!1), [S, C] = ue(!1), w = R(
    (k = {}, A = null) => ({
      role: "dialog",
      ...k,
      ref: Ge(A, l),
      id: d,
      tabIndex: -1,
      "aria-modal": !0,
      "aria-labelledby": y ? f : void 0,
      "aria-describedby": S ? p : void 0,
      onClick: fe(
        k.onClick,
        (N) => N.stopPropagation()
      )
    }),
    [p, S, d, f, y]
  ), I = R(
    (k) => {
      k.stopPropagation(), h.current === k.target && Sp.isTopModal(l.current) && (o && n?.(), a?.());
    },
    [n, o, a]
  ), P = R(
    (k = {}, A = null) => ({
      ...k,
      ref: Ge(A, u),
      onClick: fe(k.onClick, I),
      onKeyDown: fe(k.onKeyDown, v),
      onMouseDown: fe(k.onMouseDown, g)
    }),
    [v, g, I]
  );
  return {
    isOpen: t,
    onClose: n,
    headerId: f,
    bodyId: p,
    setBodyMounted: C,
    setHeaderMounted: x,
    dialogRef: l,
    overlayRef: u,
    getDialogProps: w,
    getDialogContainerProps: P,
    index: m
  };
}
function fG(e, t) {
  const n = e.current;
  ge(() => {
    if (!(!e.current || !t))
      return sG(e.current);
  }, [t, e, n]);
}
function pG(e, ...t) {
  const n = Xt(), r = e || n;
  return be(() => t.map((o) => `${o}-${r}`), [r, t]);
}
const [hG, Jo] = De({
  name: "ModalStylesContext",
  errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
}), [mG, io] = De({
  strict: !0,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
}), Em = (e) => {
  const t = {
    scrollBehavior: "outside",
    autoFocus: !0,
    trapFocus: !0,
    returnFocusOnClose: !0,
    blockScrollOnMount: !0,
    allowPinchZoom: !1,
    preserveScrollBarGap: !0,
    motionPreset: "scale",
    ...e,
    lockFocusAcrossFrames: e.lockFocusAcrossFrames ?? !0
  }, {
    portalProps: n,
    children: r,
    autoFocus: o,
    trapFocus: i,
    initialFocusRef: s,
    finalFocusRef: a,
    returnFocusOnClose: c,
    blockScrollOnMount: l,
    allowPinchZoom: u,
    preserveScrollBarGap: d,
    motionPreset: f,
    lockFocusAcrossFrames: p,
    animatePresenceProps: m,
    onCloseComplete: h
  } = t, g = We("Modal", t), y = {
    ...dG(t),
    autoFocus: o,
    trapFocus: i,
    initialFocusRef: s,
    finalFocusRef: a,
    returnFocusOnClose: c,
    blockScrollOnMount: l,
    allowPinchZoom: u,
    preserveScrollBarGap: d,
    motionPreset: f,
    lockFocusAcrossFrames: p
  };
  return /* @__PURE__ */ b(mG, { value: y, children: /* @__PURE__ */ b(hG, { value: g, children: /* @__PURE__ */ b(
    Sr,
    {
      ...m,
      onExitComplete: h,
      children: y.isOpen && /* @__PURE__ */ b(Yo, { ...n, children: r })
    }
  ) }) });
};
Em.displayName = "Modal";
var Gc = "right-scroll-bar-position", Wc = "width-before-scroll-bar", gG = "with-scroll-bars-hidden", bG = "--removed-body-scroll-bar-size", oI = Kx(), rf = function() {
}, bu = ie.forwardRef(function(e, t) {
  var n = ie.useRef(null), r = ie.useState({
    onScrollCapture: rf,
    onWheelCapture: rf,
    onTouchMoveCapture: rf
  }), o = r[0], i = r[1], s = e.forwardProps, a = e.children, c = e.className, l = e.removeScrollBar, u = e.enabled, d = e.shards, f = e.sideCar, p = e.noRelative, m = e.noIsolation, h = e.inert, g = e.allowPinchZoom, v = e.as, y = v === void 0 ? "div" : v, x = e.gapMode, S = Zx(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), C = f, w = Yx([n, t]), I = dr(dr({}, S), o);
  return ie.createElement(
    ie.Fragment,
    null,
    u && ie.createElement(C, { sideCar: oI, removeScrollBar: l, shards: d, noRelative: p, noIsolation: m, inert: h, setCallbacks: i, allowPinchZoom: !!g, lockRef: n, gapMode: x }),
    s ? ie.cloneElement(ie.Children.only(a), dr(dr({}, I), { ref: w })) : ie.createElement(y, dr({}, I, { className: c, ref: w }), a)
  );
});
bu.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
bu.classNames = {
  fullWidth: Wc,
  zeroRight: Gc
};
var vG = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function yG() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = vG();
  return t && e.setAttribute("nonce", t), e;
}
function SG(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function xG(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var CG = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = yG()) && (SG(t, n), xG(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, IG = function() {
  var e = CG();
  return function(t, n) {
    ie.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, iI = function() {
  var e = IG(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, wG = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, of = function(e) {
  return parseInt(e || "", 10) || 0;
}, PG = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [of(n), of(r), of(o)];
}, kG = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return wG;
  var t = PG(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, AG = iI(), Li = "data-scroll-locked", TG = function(e, t, n, r) {
  var o = e.left, i = e.top, s = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(gG, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Li, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Gc, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Wc, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Gc, " .").concat(Gc, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Wc, " .").concat(Wc, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Li, `] {
    `).concat(bG, ": ").concat(a, `px;
  }
`);
}, sy = function() {
  var e = parseInt(document.body.getAttribute(Li) || "0", 10);
  return isFinite(e) ? e : 0;
}, EG = function() {
  ie.useEffect(function() {
    return document.body.setAttribute(Li, (sy() + 1).toString()), function() {
      var e = sy() - 1;
      e <= 0 ? document.body.removeAttribute(Li) : document.body.setAttribute(Li, e.toString());
    };
  }, []);
}, RG = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  EG();
  var i = ie.useMemo(function() {
    return kG(o);
  }, [o]);
  return ie.createElement(AG, { styles: TG(i, !t, o, n ? "" : "!important") });
}, xp = !1;
if (typeof window < "u")
  try {
    var dc = Object.defineProperty({}, "passive", {
      get: function() {
        return xp = !0, !0;
      }
    });
    window.addEventListener("test", dc, dc), window.removeEventListener("test", dc, dc);
  } catch {
    xp = !1;
  }
var ui = xp ? { passive: !1 } : !1, _G = function(e) {
  return e.tagName === "TEXTAREA";
}, sI = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !_G(e) && n[t] === "visible")
  );
}, OG = function(e) {
  return sI(e, "overflowY");
}, NG = function(e) {
  return sI(e, "overflowX");
}, ay = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = aI(e, r);
    if (o) {
      var i = cI(e, r), s = i[1], a = i[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, MG = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, BG = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, aI = function(e, t) {
  return e === "v" ? OG(t) : NG(t);
}, cI = function(e, t) {
  return e === "v" ? MG(t) : BG(t);
}, FG = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, DG = function(e, t, n, r, o) {
  var i = FG(e, window.getComputedStyle(t).direction), s = i * r, a = n.target, c = t.contains(a), l = !1, u = s > 0, d = 0, f = 0;
  do {
    if (!a)
      break;
    var p = cI(e, a), m = p[0], h = p[1], g = p[2], v = h - g - i * m;
    (m || v) && aI(e, a) && (d += v, f += m);
    var y = a.parentNode;
    a = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (t.contains(a) || t === a)
  );
  return (u && Math.abs(d) < 1 || !u && Math.abs(f) < 1) && (l = !0), l;
}, fc = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, cy = function(e) {
  return [e.deltaX, e.deltaY];
}, ly = function(e) {
  return e && "current" in e ? e.current : e;
}, $G = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, VG = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, LG = 0, di = [];
function zG(e) {
  var t = ie.useRef([]), n = ie.useRef([0, 0]), r = ie.useRef(), o = ie.useState(LG++)[0], i = ie.useState(iI)[0], s = ie.useRef(e);
  ie.useEffect(function() {
    s.current = e;
  }, [e]), ie.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var h = AL([e.lockRef.current], (e.shards || []).map(ly), !0).filter(Boolean);
      return h.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), h.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = ie.useCallback(function(h, g) {
    if ("touches" in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
      return !s.current.allowPinchZoom;
    var v = fc(h), y = n.current, x = "deltaX" in h ? h.deltaX : y[0] - v[0], S = "deltaY" in h ? h.deltaY : y[1] - v[1], C, w = h.target, I = Math.abs(x) > Math.abs(S) ? "h" : "v";
    if ("touches" in h && I === "h" && w.type === "range")
      return !1;
    var P = ay(I, w);
    if (!P)
      return !0;
    if (P ? C = I : (C = I === "v" ? "h" : "v", P = ay(I, w)), !P)
      return !1;
    if (!r.current && "changedTouches" in h && (x || S) && (r.current = C), !C)
      return !0;
    var k = r.current || C;
    return DG(k, g, h, k === "h" ? x : S);
  }, []), c = ie.useCallback(function(h) {
    var g = h;
    if (!(!di.length || di[di.length - 1] !== i)) {
      var v = "deltaY" in g ? cy(g) : fc(g), y = t.current.filter(function(C) {
        return C.name === g.type && (C.target === g.target || g.target === C.shadowParent) && $G(C.delta, v);
      })[0];
      if (y && y.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!y) {
        var x = (s.current.shards || []).map(ly).filter(Boolean).filter(function(C) {
          return C.contains(g.target);
        }), S = x.length > 0 ? a(g, x[0]) : !s.current.noIsolation;
        S && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = ie.useCallback(function(h, g, v, y) {
    var x = { name: h, delta: g, target: v, should: y, shadowParent: GG(v) };
    t.current.push(x), setTimeout(function() {
      t.current = t.current.filter(function(S) {
        return S !== x;
      });
    }, 1);
  }, []), u = ie.useCallback(function(h) {
    n.current = fc(h), r.current = void 0;
  }, []), d = ie.useCallback(function(h) {
    l(h.type, cy(h), h.target, a(h, e.lockRef.current));
  }, []), f = ie.useCallback(function(h) {
    l(h.type, fc(h), h.target, a(h, e.lockRef.current));
  }, []);
  ie.useEffect(function() {
    return di.push(i), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", c, ui), document.addEventListener("touchmove", c, ui), document.addEventListener("touchstart", u, ui), function() {
      di = di.filter(function(h) {
        return h !== i;
      }), document.removeEventListener("wheel", c, ui), document.removeEventListener("touchmove", c, ui), document.removeEventListener("touchstart", u, ui);
    };
  }, []);
  var p = e.removeScrollBar, m = e.inert;
  return ie.createElement(
    ie.Fragment,
    null,
    m ? ie.createElement(i, { styles: VG(o) }) : null,
    p ? ie.createElement(RG, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function GG(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const WG = TL(oI, zG);
var lI = ie.forwardRef(function(e, t) {
  return ie.createElement(bu, dr({}, e, { ref: t, sideCar: WG }));
});
lI.classNames = bu.classNames;
function uI(e) {
  const {
    autoFocus: t,
    trapFocus: n,
    dialogRef: r,
    initialFocusRef: o,
    blockScrollOnMount: i,
    allowPinchZoom: s,
    finalFocusRef: a,
    returnFocusOnClose: c,
    preserveScrollBarGap: l,
    lockFocusAcrossFrames: u,
    isOpen: d
  } = io(), [f, p] = US();
  ge(() => {
    !f && p && setTimeout(p);
  }, [f, p]);
  const m = rI(r, d);
  return /* @__PURE__ */ b(
    PC,
    {
      autoFocus: t,
      isDisabled: !n,
      initialFocusRef: o,
      finalFocusRef: a,
      restoreFocus: c,
      contentRef: r,
      lockFocusAcrossFrames: u,
      children: /* @__PURE__ */ b(
        lI,
        {
          removeScrollBar: !l,
          allowPinchZoom: s,
          enabled: m === 1 && i,
          forwardProps: !0,
          children: e.children
        }
      )
    }
  );
}
const HG = {
  initial: ({ offsetX: e, offsetY: t, transition: n, transitionEnd: r, delay: o }) => ({
    opacity: 0,
    x: e,
    y: t,
    transition: n?.exit ?? Un.exit(No.exit, o),
    transitionEnd: r?.exit
  }),
  enter: ({ transition: e, transitionEnd: t, delay: n }) => ({
    opacity: 1,
    x: 0,
    y: 0,
    transition: e?.enter ?? Un.enter(No.enter, n),
    transitionEnd: t?.enter
  }),
  exit: ({ offsetY: e, offsetX: t, transition: n, transitionEnd: r, reverse: o, delay: i }) => {
    const s = { x: t, y: e };
    return {
      opacity: 0,
      transition: n?.exit ?? Un.exit(No.exit, i),
      ...o ? { ...s, transitionEnd: r?.exit } : { transitionEnd: { ...s, ...r?.exit } }
    };
  }
}, Bs = {
  initial: "initial",
  animate: "enter",
  exit: "exit",
  variants: HG
}, jG = _t(
  function(t, n) {
    const {
      unmountOnExit: r,
      in: o,
      reverse: i = !0,
      className: s,
      offsetX: a = 0,
      offsetY: c = 8,
      transition: l,
      transitionEnd: u,
      delay: d,
      animatePresenceProps: f,
      ...p
    } = t, m = r ? o && r : !0, h = o || r ? "enter" : "exit", g = {
      offsetX: a,
      offsetY: c,
      reverse: i,
      transition: l,
      transitionEnd: u,
      delay: d
    };
    return /* @__PURE__ */ b(Sr, { ...f, custom: g, children: m && /* @__PURE__ */ b(
      Jt.div,
      {
        ref: n,
        className: oe("chakra-offset-slide", s),
        custom: g,
        ...Bs,
        animate: h,
        ...p
      }
    ) });
  }
);
jG.displayName = "SlideFade";
const XG = {
  exit: ({ reverse: e, initialScale: t, transition: n, transitionEnd: r, delay: o }) => ({
    opacity: 0,
    ...e ? { scale: t, transitionEnd: r?.exit } : { transitionEnd: { scale: t, ...r?.exit } },
    transition: n?.exit ?? Un.exit(No.exit, o)
  }),
  enter: ({ transitionEnd: e, transition: t, delay: n }) => ({
    opacity: 1,
    scale: 1,
    transition: t?.enter ?? Un.enter(No.enter, n),
    transitionEnd: e?.enter
  })
}, dI = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: XG
}, YG = _t(
  function(t, n) {
    const {
      unmountOnExit: r,
      in: o,
      reverse: i = !0,
      initialScale: s = 0.95,
      className: a,
      transition: c,
      transitionEnd: l,
      delay: u,
      animatePresenceProps: d,
      ...f
    } = t, p = r ? o && r : !0, m = o || r ? "enter" : "exit", h = { initialScale: s, reverse: i, transition: c, transitionEnd: l, delay: u };
    return /* @__PURE__ */ b(Sr, { ...d, custom: h, children: p && /* @__PURE__ */ b(
      Jt.div,
      {
        ref: n,
        className: oe("chakra-offset-slide", a),
        ...dI,
        animate: m,
        custom: h,
        ...f
      }
    ) });
  }
);
YG.displayName = "ScaleFade";
const ZG = {
  slideInBottom: {
    ...Bs,
    custom: { offsetY: 16, reverse: !0 }
  },
  slideInRight: {
    ...Bs,
    custom: { offsetX: 16, reverse: !0 }
  },
  slideInTop: {
    ...Bs,
    custom: { offsetY: -16, reverse: !0 }
  },
  slideInLeft: {
    ...Bs,
    custom: { offsetX: -16, reverse: !0 }
  },
  scale: {
    ...dI,
    custom: { initialScale: 0.95, reverse: !0 }
  },
  none: {}
}, UG = z(Jt.section), JG = (e) => ZG[e || "none"], fI = _t(
  (e, t) => {
    const { preset: n, motionProps: r = JG(n), ...o } = e;
    return /* @__PURE__ */ b(UG, { ref: t, ...r, ...o });
  }
);
fI.displayName = "ModalTransition";
const pI = X(
  (e, t) => {
    const {
      className: n,
      children: r,
      containerProps: o,
      motionProps: i,
      ...s
    } = e, { getDialogProps: a, getDialogContainerProps: c } = io(), l = a(s, t), u = c(o), d = oe("chakra-modal__content", n), f = Jo(), p = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...f.dialog
    }, m = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...f.dialogContainer
    }, { motionPreset: h } = io();
    return /* @__PURE__ */ b(uI, { children: /* @__PURE__ */ b(
      z.div,
      {
        ...u,
        className: "chakra-modal__content-container",
        tabIndex: -1,
        __css: m,
        children: /* @__PURE__ */ b(
          fI,
          {
            preset: h,
            motionProps: i,
            className: d,
            ...l,
            __css: p,
            children: r
          }
        )
      }
    ) });
  }
);
pI.displayName = "ModalContent";
const hI = X((e, t) => {
  const { className: n, ...r } = e, { bodyId: o, setBodyMounted: i } = io();
  ge(() => (i(!0), () => i(!1)), [i]);
  const s = oe("chakra-modal__body", n), a = Jo();
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: t,
      className: s,
      id: o,
      ...r,
      __css: a.body
    }
  );
});
hI.displayName = "ModalBody";
const KG = X(
  (e, t) => {
    const { onClick: n, className: r, ...o } = e, { onClose: i } = io(), s = oe("chakra-modal__close-btn", r), a = Jo();
    return /* @__PURE__ */ b(
      uu,
      {
        ref: t,
        __css: a.closeButton,
        className: s,
        onClick: fe(n, (c) => {
          c.stopPropagation(), i();
        }),
        ...o
      }
    );
  }
);
KG.displayName = "ModalCloseButton";
const mI = X(
  (e, t) => {
    const { className: n, ...r } = e, o = oe("chakra-modal__footer", n), i = Jo(), s = {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      ...i.footer
    };
    return /* @__PURE__ */ b(
      z.footer,
      {
        ref: t,
        ...r,
        __css: s,
        className: o
      }
    );
  }
);
mI.displayName = "ModalFooter";
const gI = X(
  (e, t) => {
    const { className: n, ...r } = e, { headerId: o, setHeaderMounted: i } = io();
    ge(() => (i(!0), () => i(!1)), [i]);
    const s = oe("chakra-modal__header", n), a = Jo(), c = {
      flex: 0,
      ...a.header
    };
    return /* @__PURE__ */ b(
      z.header,
      {
        ref: t,
        className: s,
        id: o,
        ...r,
        __css: c
      }
    );
  }
);
gI.displayName = "ModalHeader";
const qG = {
  enter: ({ transition: e, transitionEnd: t, delay: n } = {}) => ({
    opacity: 1,
    transition: e?.enter ?? Un.enter(No.enter, n),
    transitionEnd: t?.enter
  }),
  exit: ({ transition: e, transitionEnd: t, delay: n } = {}) => ({
    opacity: 0,
    transition: e?.exit ?? Un.exit(No.exit, n),
    transitionEnd: t?.exit
  })
}, bI = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: qG
}, QG = _t(
  function(t, n) {
    const {
      unmountOnExit: r,
      in: o,
      className: i,
      transition: s,
      transitionEnd: a,
      delay: c,
      animatePresenceProps: l,
      ...u
    } = t, d = o || r ? "enter" : "exit", f = r ? o && r : !0, p = { transition: s, transitionEnd: a, delay: c };
    return /* @__PURE__ */ b(Sr, { ...l, custom: p, children: f && /* @__PURE__ */ b(
      Jt.div,
      {
        ref: n,
        className: oe("chakra-fade", i),
        custom: p,
        ...bI,
        animate: d,
        ...u
      }
    ) });
  }
);
QG.displayName = "Fade";
const eW = z(Jt.div), vI = X(
  (e, t) => {
    const { className: n, transition: r, motionProps: o, ...i } = e, s = oe("chakra-modal__overlay", n), c = {
      pos: "fixed",
      left: "0",
      top: "0",
      w: "100vw",
      h: "100vh",
      ...Jo().overlay
    }, { motionPreset: l } = io();
    return /* @__PURE__ */ b(
      eW,
      {
        ...o || (l === "none" ? {} : bI),
        __css: c,
        ref: t,
        className: s,
        ...i
      }
    );
  }
);
vI.displayName = "ModalOverlay";
function tW(e) {
  const { leastDestructiveRef: t, ...n } = e;
  return /* @__PURE__ */ b(Em, { ...n, initialFocusRef: t });
}
const nW = X(
  (e, t) => /* @__PURE__ */ b(pI, { ref: t, role: "alertdialog", ...e })
), [rW, oW] = De(), iW = {
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
function sW(e, t) {
  if (e)
    return iW[e]?.[t] ?? e;
}
function FQ(e) {
  const {
    isOpen: t,
    onClose: n,
    placement: r = "right",
    children: o,
    ...i
  } = e, s = bn(), a = s.components?.Drawer, c = sW(r, s.direction);
  return /* @__PURE__ */ b(rW, { value: { placement: c }, children: /* @__PURE__ */ b(
    Em,
    {
      isOpen: t,
      onClose: n,
      styleConfig: a,
      ...i,
      children: o
    }
  ) });
}
const uy = {
  exit: {
    duration: 0.15,
    ease: ko.easeInOut
  },
  enter: {
    type: "spring",
    damping: 25,
    stiffness: 180
  }
}, aW = {
  exit: ({ direction: e, transition: t, transitionEnd: n, delay: r }) => {
    const { exit: o } = ip({ direction: e });
    return {
      ...o,
      transition: t?.exit ?? Un.exit(uy.exit, r),
      transitionEnd: n?.exit
    };
  },
  enter: ({ direction: e, transitionEnd: t, transition: n, delay: r }) => {
    const { enter: o } = ip({ direction: e });
    return {
      ...o,
      transition: n?.enter ?? Un.enter(uy.enter, r),
      transitionEnd: t?.enter
    };
  }
}, yI = _t(
  function(t, n) {
    const {
      direction: r = "right",
      style: o,
      unmountOnExit: i,
      in: s,
      className: a,
      transition: c,
      transitionEnd: l,
      delay: u,
      motionProps: d,
      animatePresenceProps: f,
      ...p
    } = t, m = ip({ direction: r }), h = Object.assign(
      { position: "fixed" },
      m.position,
      o
    ), g = i ? s && i : !0, v = s || i ? "enter" : "exit", y = { transitionEnd: l, transition: c, direction: r, delay: u };
    return /* @__PURE__ */ b(Sr, { ...f, custom: y, children: g && /* @__PURE__ */ b(
      Jt.div,
      {
        ...p,
        ref: n,
        initial: "exit",
        className: oe("chakra-slide", a),
        animate: v,
        exit: "exit",
        custom: y,
        variants: aW,
        style: h,
        ...d
      }
    ) });
  }
);
yI.displayName = "Slide";
const cW = z(yI), lW = X(
  (e, t) => {
    const {
      className: n,
      children: r,
      motionProps: o,
      containerProps: i,
      ...s
    } = e, { getDialogProps: a, getDialogContainerProps: c, isOpen: l } = io(), u = a(s, t), d = c(i), f = oe("chakra-modal__content", n), p = Jo(), m = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...p.dialog
    }, h = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...p.dialogContainer
    }, { placement: g } = oW();
    return /* @__PURE__ */ b(uI, { children: /* @__PURE__ */ b(
      z.div,
      {
        ...d,
        className: "chakra-modal__content-container",
        __css: h,
        children: /* @__PURE__ */ b(
          cW,
          {
            motionProps: o,
            direction: g,
            in: l,
            className: f,
            ...u,
            __css: m,
            children: r
          }
        )
      }
    ) });
  }
);
lW.displayName = "DrawerContent";
const uW = (e) => /* @__PURE__ */ b(It, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
  "path",
  {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  }
) }), dW = (e) => /* @__PURE__ */ b(It, { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
  "path",
  {
    fill: "currentColor",
    d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
  }
) });
function dy(e, t, n, r) {
  ge(() => {
    if (!e.current || !r)
      return;
    const o = e.current.ownerDocument.defaultView ?? window, i = Array.isArray(t) ? t : [t], s = new o.MutationObserver((a) => {
      for (const c of a)
        c.type === "attributes" && c.attributeName && i.includes(c.attributeName) && n(c);
    });
    return s.observe(e.current, { attributes: !0, attributeFilter: i }), () => s.disconnect();
  });
}
const fW = 50, fy = 300;
function pW(e, t) {
  const [n, r] = ue(!1), [o, i] = ue(null), [s, a] = ue(!0), c = se(null), l = () => clearTimeout(c.current);
  KA(
    () => {
      o === "increment" && e(), o === "decrement" && t();
    },
    n ? fW : null
  );
  const u = R(() => {
    s && e(), c.current = setTimeout(() => {
      a(!1), r(!0), i("increment");
    }, fy);
  }, [e, s]), d = R(() => {
    s && t(), c.current = setTimeout(() => {
      a(!1), r(!0), i("decrement");
    }, fy);
  }, [t, s]), f = R(() => {
    a(!0), r(!1), l();
  }, []);
  return ge(() => () => l(), []), { up: u, down: d, stop: f, isSpinning: n };
}
const hW = /^[Ee0-9+\-.]$/;
function mW(e) {
  return hW.test(e);
}
function gW(e, t) {
  if (e.key == null)
    return !0;
  const n = e.ctrlKey || e.altKey || e.metaKey;
  return !(e.key.length === 1) || n ? !0 : t(e.key);
}
function bW(e = {}) {
  const {
    focusInputOnChange: t = !0,
    clampValueOnBlur: n = !0,
    keepWithinRange: r = !0,
    min: o = Number.MIN_SAFE_INTEGER,
    max: i = Number.MAX_SAFE_INTEGER,
    step: s = 1,
    isReadOnly: a,
    isDisabled: c,
    isRequired: l,
    isInvalid: u,
    pattern: d = "[0-9]*(.[0-9]+)?",
    inputMode: f = "decimal",
    allowMouseWheel: p,
    id: m,
    onChange: h,
    precision: g,
    name: v,
    "aria-describedby": y,
    "aria-label": x,
    "aria-labelledby": S,
    onFocus: C,
    onBlur: w,
    onInvalid: I,
    getAriaValueText: P,
    isValidCharacter: k,
    format: A,
    parse: N,
    ...B
  } = e, L = pt(C), Z = pt(w), ne = pt(I), W = pt(
    k ?? mW
  ), O = pt(P), J = $A(e), {
    update: ee,
    increment: H,
    decrement: _
  } = J, [j, E] = ue(!1), M = !(a || c), F = se(null), G = se(null), q = se(null), te = se(null), U = R(
    (de) => de.split("").filter(W).join(""),
    [W]
  ), K = R(
    (de) => N?.(de) ?? de,
    [N]
  ), ae = R(
    (de) => (A?.(de) ?? de).toString(),
    [A]
  );
  Jn(() => {
    (J.valueAsNumber > i || J.valueAsNumber < o) && ne?.("rangeOverflow", ae(J.value), J.valueAsNumber);
  }, [J.valueAsNumber, J.value, ae, ne]), Dn(() => {
    if (!F.current)
      return;
    if (F.current.value != J.value) {
      const Ue = K(F.current.value);
      J.setValue(U(Ue));
    }
  }, [K, U]);
  const Y = R(
    (de = s) => {
      M && H(de);
    },
    [H, M, s]
  ), ce = R(
    (de = s) => {
      M && _(de);
    },
    [_, M, s]
  ), re = pW(Y, ce);
  dy(
    q,
    "disabled",
    re.stop,
    re.isSpinning
  ), dy(
    te,
    "disabled",
    re.stop,
    re.isSpinning
  );
  const Ce = R(
    (de) => {
      if (de.nativeEvent.isComposing)
        return;
      const pe = K(de.currentTarget.value);
      ee(U(pe)), G.current = {
        start: de.currentTarget.selectionStart,
        end: de.currentTarget.selectionEnd
      };
    },
    [ee, U, K]
  ), Ve = R(
    (de) => {
      L?.(de), G.current && (de.currentTarget.selectionStart = G.current.start ?? de.currentTarget.value?.length, de.currentTarget.selectionEnd = G.current.end ?? de.currentTarget.selectionStart);
    },
    [L]
  ), le = R(
    (de) => {
      if (de.nativeEvent.isComposing)
        return;
      gW(de, W) || de.preventDefault();
      const Ue = Pe(de) * s, pe = de.key, vt = {
        ArrowUp: () => Y(Ue),
        ArrowDown: () => ce(Ue),
        Home: () => ee(o),
        End: () => ee(i)
      }[pe];
      vt && (de.preventDefault(), vt(de));
    },
    [W, s, Y, ce, ee, o, i]
  ), Pe = (de) => {
    let Ue = 1;
    return (de.metaKey || de.ctrlKey) && (Ue = 0.1), de.shiftKey && (Ue = 10), Ue;
  }, ve = be(() => {
    const de = O?.(J.value);
    if (de != null)
      return de;
    const Ue = J.value.toString();
    return Ue || void 0;
  }, [J.value, O]), he = R(() => {
    let de = J.value;
    if (J.value === "")
      return;
    /^[eE]/.test(J.value.toString()) ? J.setValue("") : (J.valueAsNumber < o && (de = o), J.valueAsNumber > i && (de = i), J.cast(de));
  }, [J, i, o]), _e = R(() => {
    E(!1), n && he();
  }, [n, E, he]), Oe = R(() => {
    t && requestAnimationFrame(() => {
      F.current?.focus();
    });
  }, [t]), ze = R(
    (de) => {
      de.preventDefault(), re.up(), Oe();
    },
    [Oe, re]
  ), Ye = R(
    (de) => {
      de.preventDefault(), re.down(), Oe();
    },
    [Oe, re]
  );
  Qr(
    () => F.current,
    "wheel",
    (de) => {
      const pe = (F.current?.ownerDocument ?? document).activeElement === F.current;
      if (!p || !pe)
        return;
      de.preventDefault();
      const Se = Pe(de) * s, vt = Math.sign(de.deltaY);
      vt === -1 ? Y(Se) : vt === 1 && ce(Se);
    },
    { passive: !1 }
  );
  const Yt = R(
    (de = {}, Ue = null) => {
      const pe = c || r && J.isAtMax;
      return {
        ...de,
        ref: Ge(Ue, q),
        role: "button",
        tabIndex: -1,
        onPointerDown: fe(de.onPointerDown, (Se) => {
          Se.button !== 0 || pe || ze(Se);
        }),
        onPointerLeave: fe(de.onPointerLeave, re.stop),
        onPointerUp: fe(de.onPointerUp, re.stop),
        disabled: pe,
        "aria-disabled": Vt(pe)
      };
    },
    [J.isAtMax, r, ze, re.stop, c]
  ), Kt = R(
    (de = {}, Ue = null) => {
      const pe = c || r && J.isAtMin;
      return {
        ...de,
        ref: Ge(Ue, te),
        role: "button",
        tabIndex: -1,
        onPointerDown: fe(de.onPointerDown, (Se) => {
          Se.button !== 0 || pe || Ye(Se);
        }),
        onPointerLeave: fe(de.onPointerLeave, re.stop),
        onPointerUp: fe(de.onPointerUp, re.stop),
        disabled: pe,
        "aria-disabled": Vt(pe)
      };
    },
    [J.isAtMin, r, Ye, re.stop, c]
  ), tn = R(
    (de = {}, Ue = null) => ({
      name: v,
      inputMode: f,
      type: "text",
      pattern: d,
      "aria-labelledby": S,
      "aria-label": x,
      "aria-describedby": y,
      id: m,
      disabled: c,
      role: "spinbutton",
      ...de,
      readOnly: de.readOnly ?? a,
      "aria-readonly": de.readOnly ?? a,
      "aria-required": de.required ?? l,
      required: de.required ?? l,
      ref: Ge(F, Ue),
      value: ae(J.value),
      "aria-valuemin": o,
      "aria-valuemax": i,
      "aria-valuenow": Number.isNaN(J.valueAsNumber) ? void 0 : J.valueAsNumber,
      "aria-invalid": Vt(u ?? J.isOutOfRange),
      "aria-valuetext": ve,
      autoComplete: "off",
      autoCorrect: "off",
      onChange: fe(de.onChange, Ce),
      onKeyDown: fe(de.onKeyDown, le),
      onFocus: fe(
        de.onFocus,
        Ve,
        () => E(!0)
      ),
      onBlur: fe(de.onBlur, Z, _e)
    }),
    [
      v,
      f,
      d,
      S,
      x,
      ae,
      y,
      m,
      c,
      l,
      a,
      u,
      J.value,
      J.valueAsNumber,
      J.isOutOfRange,
      o,
      i,
      ve,
      Ce,
      le,
      Ve,
      Z,
      _e
    ]
  );
  return {
    value: ae(J.value),
    valueAsNumber: J.valueAsNumber,
    isFocused: j,
    isDisabled: c,
    isReadOnly: a,
    getIncrementButtonProps: Yt,
    getDecrementButtonProps: Kt,
    getInputProps: tn,
    htmlProps: B
  };
}
const [vW, vu] = De({
  name: "NumberInputStylesContext",
  errorMessage: `useNumberInputStyles returned is 'undefined'. Seems you forgot to wrap the components in "<NumberInput />" `
}), [yW, Rm] = De({
  name: "NumberInputContext",
  errorMessage: "useNumberInputContext: `context` is undefined. Seems you forgot to wrap number-input's components within <NumberInput />"
}), SI = X(
  function(t, n) {
    const r = We("NumberInput", t), o = $e(t), i = tm(o), { htmlProps: s, ...a } = bW(i), c = be(() => a, [a]);
    return /* @__PURE__ */ b(yW, { value: c, children: /* @__PURE__ */ b(vW, { value: r, children: /* @__PURE__ */ b(
      z.div,
      {
        ...s,
        ref: n,
        className: oe("chakra-numberinput", t.className),
        __css: {
          position: "relative",
          zIndex: 0,
          ...r.root
        }
      }
    ) }) });
  }
);
SI.displayName = "NumberInput";
const xI = X(
  function(t, n) {
    const r = vu();
    return /* @__PURE__ */ b(
      z.div,
      {
        "aria-hidden": !0,
        ref: n,
        ...t,
        __css: {
          display: "flex",
          flexDirection: "column",
          position: "absolute",
          top: "0",
          insetEnd: "0px",
          margin: "1px",
          height: "calc(100% - 2px)",
          zIndex: 1,
          ...r.stepperGroup
        }
      }
    );
  }
);
xI.displayName = "NumberInputStepper";
const CI = X(
  function(t, n) {
    const { getInputProps: r } = Rm(), o = r(t, n), i = vu();
    return /* @__PURE__ */ b(
      z.input,
      {
        ...o,
        className: oe("chakra-numberinput__field", t.className),
        __css: {
          width: "100%",
          ...i.field
        }
      }
    );
  }
);
CI.displayName = "NumberInputField";
const II = z("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
}), wI = X(function(t, n) {
  const r = vu(), { getDecrementButtonProps: o } = Rm(), i = o(t, n);
  return /* @__PURE__ */ b(II, { ...i, __css: r.stepper, children: t.children ?? /* @__PURE__ */ b(uW, {}) });
});
wI.displayName = "NumberDecrementStepper";
const PI = X(function(t, n) {
  const { getIncrementButtonProps: r } = Rm(), o = r(t, n), i = vu();
  return /* @__PURE__ */ b(II, { ...o, __css: i.stepper, children: t.children ?? /* @__PURE__ */ b(dW, {}) });
});
PI.displayName = "NumberIncrementStepper";
const [
  SW,
  DQ,
  xW,
  CW
] = du(), [IW, wW] = De({
  name: "PinInputContext",
  errorMessage: "usePinInputContext: `context` is undefined. Seems you forgot to place all pin input fields within `<PinInput />`"
}), py = (e) => e?.split("");
function hy(e, t) {
  return (t === "alphanumeric" ? /^[a-zA-Z0-9]+$/i : /^[0-9]+$/).test(e);
}
function PW(e = {}) {
  const {
    autoFocus: t,
    value: n,
    defaultValue: r,
    onChange: o,
    onComplete: i,
    placeholder: s = "○",
    manageFocus: a = !0,
    otp: c = !1,
    id: l,
    isDisabled: u,
    isInvalid: d,
    type: f = "number",
    mask: p
  } = e, m = Xt(), h = l ?? `pin-input-${m}`, g = xW(), [v, y] = ue(!0), [x, S] = ue(-1), [C, w] = co({
    defaultValue: py(r) || [],
    value: py(n),
    onChange: (B) => o?.(B.join(""))
  });
  ge(() => {
    if (t) {
      const B = g.first();
      B && requestAnimationFrame(() => {
        B.node.focus();
      });
    }
  }, [g]);
  const I = R(
    (B) => {
      if (!v || !a)
        return;
      const L = g.next(B, !1);
      L && requestAnimationFrame(() => {
        L.node.focus();
      });
    },
    [g, v, a]
  ), P = R(
    (B, L, Z = !0) => {
      const ne = [...C];
      ne[L] = B, w(ne), B !== "" && ne.length === g.count() && ne.every(
        (O) => O != null && O !== ""
      ) ? i?.(ne.join("")) : Z && I(L);
    },
    [C, w, I, i, g]
  ), k = R(() => {
    const B = Array(g.count()).fill("");
    w(B), g.first()?.node?.focus();
  }, [g, w]), A = R((B, L) => {
    let Z = L;
    return B?.length > 0 && (B[0] === L.charAt(0) ? Z = L.charAt(1) : B[0] === L.charAt(1) && (Z = L.charAt(0))), Z;
  }, []);
  return {
    // prop getter
    getInputProps: R(
      (B) => {
        const { index: L, ...Z } = B, ne = (_) => {
          const j = _.currentTarget.value, E = C[L], M = A(E, j);
          if (M === "") {
            P("", L);
            return;
          }
          if (j.length > 2) {
            if (hy(j, f)) {
              const F = j.split("").filter((G, q) => q < g.count());
              w(F), F.length === g.count() && i?.(F.join(""));
            }
          } else
            hy(M, f) && P(M, L), y(!0);
        }, W = (_) => {
          if (_.key === "Backspace" && a)
            if (_.currentTarget.value === "") {
              const j = g.prev(L, !1);
              j && (P("", L - 1, !1), j.node?.focus(), y(!0));
            } else
              y(!1);
        }, O = () => {
          S(L);
        }, J = () => {
          S(-1);
        }, ee = x === L;
        return {
          "aria-label": "Please enter your pin code",
          inputMode: f === "number" ? "numeric" : "text",
          type: p ? "password" : f === "number" ? "tel" : "text",
          ...Z,
          id: `${h}-${L}`,
          disabled: u,
          "aria-invalid": Vt(d),
          onChange: fe(Z.onChange, ne),
          onKeyDown: fe(Z.onKeyDown, W),
          onFocus: fe(Z.onFocus, O),
          onBlur: fe(Z.onBlur, J),
          value: C[L] || "",
          autoComplete: c ? "one-time-code" : "off",
          placeholder: ee ? "" : s
        };
      },
      [
        g,
        x,
        A,
        h,
        u,
        p,
        d,
        a,
        i,
        c,
        s,
        P,
        w,
        f,
        C
      ]
    ),
    // state
    id: h,
    descendants: g,
    values: C,
    // actions
    setValue: P,
    setValues: w,
    clear: k
  };
}
function kW(e = {}, t = null) {
  const { getInputProps: n } = wW(), { index: r, register: o } = CW();
  return n({
    ...e,
    ref: Ge(o, t),
    index: e.index ?? r
  });
}
function AW(e) {
  const t = Gt("PinInput", e), { children: n, ...r } = $e(e), { descendants: o, ...i } = PW(r), s = Hr(n).map(
    (a) => Lt(a, { __css: t })
  );
  return /* @__PURE__ */ b(SW, { value: o, children: /* @__PURE__ */ b(IW, { value: i, children: s }) });
}
AW.displayName = "PinInput";
const TW = X(
  function(t, n) {
    const r = kW(t, n);
    return /* @__PURE__ */ b(
      z.input,
      {
        ...r,
        className: oe("chakra-pin-input", t.className)
      }
    );
  }
);
TW.displayName = "PinInputField";
const [EW, fo] = De({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
}), [RW, cs] = De({
  name: "PopoverStylesContext",
  errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `
}), fi = {
  click: "click",
  hover: "hover"
};
function _W(e = {}) {
  const {
    closeOnBlur: t = !0,
    closeOnEsc: n = !0,
    initialFocusRef: r,
    id: o,
    returnFocusOnClose: i = !0,
    autoFocus: s = !0,
    arrowSize: a,
    arrowShadowColor: c,
    trigger: l = fi.click,
    openDelay: u = 200,
    closeDelay: d = 200,
    isLazy: f,
    lazyBehavior: p = "unmount",
    computePositionOnMount: m,
    ...h
  } = e, { isOpen: g, onClose: v, onOpen: y, onToggle: x } = Hl(e), [S, C] = ue(i);
  ge(() => C(i), [i]);
  const w = se(null), I = se(null), P = se(null), k = se(!1), A = se(!1);
  g && (A.current = !0);
  const [N, B] = ue(!1), [L, Z] = ue(!1), ne = Xt(), W = o ?? ne, [O, J, ee, H] = [
    "popover-trigger",
    "popover-content",
    "popover-header",
    "popover-body"
  ].map((le) => `${le}-${W}`), {
    referenceRef: _,
    getArrowProps: j,
    getPopperProps: E,
    getArrowInnerProps: M,
    forceUpdate: F
  } = Am({
    ...h,
    enabled: g || !!m
  }), G = W0({ isOpen: g, ref: P });
  Y0({
    enabled: g,
    ref: I
  }), j0(P, {
    focusRef: I,
    visible: g,
    shouldFocus: S && l === fi.click
  }), zA(P, {
    focusRef: r,
    visible: g,
    shouldFocus: s && l === fi.click
  }), U0({
    enabled: g && t,
    ref: P,
    handler(le) {
      const Pe = le.composedPath?.()[0] ?? [
        le.target
      ];
      pc(I.current, Pe) || (Pe && C(!tl(Pe)), v());
    }
  });
  const q = nh({
    wasSelected: A.current,
    enabled: f,
    mode: p,
    isSelected: G.present
  }), te = R(
    (le = {}, Pe = null) => {
      const ve = {
        ...le,
        style: {
          ...le.style,
          transformOrigin: Dt.transformOrigin.varRef,
          [Dt.arrowSize.var]: a ? `${a}px` : void 0,
          [Dt.arrowShadowColor.var]: c
        },
        ref: Ge(P, Pe),
        children: q ? le.children : null,
        id: J,
        tabIndex: -1,
        role: "dialog",
        onKeyDown: fe(le.onKeyDown, (he) => {
          he.nativeEvent.isComposing || n && he.key === "Escape" && (he.preventDefault(), he.stopPropagation(), v());
        }),
        onBlur: fe(le.onBlur, (he) => {
          const _e = my(he), Oe = pc(P.current, _e), ze = pc(I.current, _e), Ye = !Oe && !ze;
          _e && C(!tl(_e)), g && t && Ye && v();
        }),
        "aria-labelledby": N ? ee : void 0,
        "aria-describedby": L ? H : void 0
      };
      return l === fi.hover && (ve.role = "tooltip", ve.onMouseEnter = fe(le.onMouseEnter, () => {
        k.current = !0;
      }), ve.onMouseLeave = fe(
        le.onMouseLeave,
        (he) => {
          he.nativeEvent.relatedTarget !== null && (k.current = !1, setTimeout(() => v(), d));
        }
      )), ve;
    },
    [
      q,
      J,
      N,
      ee,
      L,
      H,
      l,
      n,
      v,
      g,
      t,
      d,
      c,
      a
    ]
  ), U = R(
    (le = {}, Pe = null) => E(
      {
        ...le,
        style: {
          visibility: g ? "visible" : "hidden",
          ...le.style
        }
      },
      Pe
    ),
    [g, E]
  ), K = R(
    (le, Pe = null) => ({
      ...le,
      // If anchor is rendered, it is used as reference.
      ref: Ge(Pe, w, _)
    }),
    [w, _]
  ), ae = se(void 0), Y = se(void 0), ce = R(
    (le) => {
      w.current == null && _(le);
    },
    [_]
  ), re = R(
    (le = {}, Pe = null) => {
      const ve = {
        ...le,
        ref: Ge(I, Pe, ce),
        id: O,
        "aria-haspopup": "dialog",
        "aria-expanded": g,
        "aria-controls": J
      };
      return l === fi.click && (ve.onClick = fe(le.onClick, x)), l === fi.hover && (ve.onFocus = fe(le.onFocus, () => {
        ae.current === void 0 && y();
      }), ve.onBlur = fe(le.onBlur, (he) => {
        const _e = my(he), Oe = !pc(P.current, _e);
        g && t && Oe && v();
      }), ve.onKeyDown = fe(le.onKeyDown, (he) => {
        he.key === "Escape" && v();
      }), ve.onMouseEnter = fe(le.onMouseEnter, () => {
        k.current = !0, ae.current = window.setTimeout(() => y(), u);
      }), ve.onMouseLeave = fe(le.onMouseLeave, () => {
        k.current = !1, ae.current && (clearTimeout(ae.current), ae.current = void 0), Y.current = window.setTimeout(() => {
          k.current === !1 && v();
        }, d);
      })), ve;
    },
    [
      O,
      g,
      J,
      l,
      ce,
      x,
      y,
      t,
      v,
      u,
      d
    ]
  );
  ge(() => () => {
    ae.current && clearTimeout(ae.current), Y.current && clearTimeout(Y.current);
  }, []);
  const Ce = R(
    (le = {}, Pe = null) => ({
      ...le,
      id: ee,
      ref: Ge(Pe, (ve) => {
        B(!!ve);
      })
    }),
    [ee]
  ), Ve = R(
    (le = {}, Pe = null) => ({
      ...le,
      id: H,
      ref: Ge(Pe, (ve) => {
        Z(!!ve);
      })
    }),
    [H]
  );
  return {
    forceUpdate: F,
    isOpen: g,
    onAnimationComplete: G.onComplete,
    onClose: v,
    getAnchorProps: K,
    getArrowProps: j,
    getArrowInnerProps: M,
    getPopoverPositionerProps: U,
    getPopoverProps: te,
    getTriggerProps: re,
    getHeaderProps: Ce,
    getBodyProps: Ve
  };
}
function pc(e, t) {
  return e === t || e?.contains(t);
}
function my(e) {
  const t = e.currentTarget.ownerDocument.activeElement;
  return e.relatedTarget ?? t;
}
function OW(e) {
  const t = We("Popover", e), { children: n, ...r } = $e(e), o = bn(), i = _W({ ...r, direction: o.direction });
  return /* @__PURE__ */ b(EW, { value: i, children: /* @__PURE__ */ b(RW, { value: t, children: jt(n, {
    isOpen: i.isOpen,
    onClose: i.onClose,
    forceUpdate: i.forceUpdate
  }) }) });
}
OW.displayName = "Popover";
function _m(e) {
  const t = ie.version;
  return typeof t != "string" || t.startsWith("18.") ? e?.ref : e?.props?.ref;
}
function NW(e) {
  const t = yr.only(e.children), { getAnchorProps: n } = fo();
  return /* @__PURE__ */ b(Vr, { children: Lt(t, n(t.props, _m(t))) });
}
NW.displayName = "PopoverAnchor";
const sf = (e, t) => t ? `${e}.${t}, ${t}` : void 0;
function MW(e) {
  const {
    bg: t,
    bgColor: n,
    backgroundColor: r,
    shadow: o,
    boxShadow: i,
    shadowColor: s,
    ...a
  } = e, { getArrowProps: c, getArrowInnerProps: l } = fo(), u = cs(), d = t ?? n ?? r, f = o ?? i;
  return /* @__PURE__ */ b(
    z.div,
    {
      ...c(),
      className: "chakra-popover__arrow-positioner",
      children: /* @__PURE__ */ b(
        z.div,
        {
          className: oe("chakra-popover__arrow", e.className),
          ...l(a),
          __css: {
            "--popper-arrow-shadow-color": sf("colors", s),
            "--popper-arrow-bg": sf("colors", d),
            "--popper-arrow-shadow": sf("shadows", f),
            ...u.arrow
          }
        }
      )
    }
  );
}
MW.displayName = "PopoverArrow";
const BW = X(
  function(t, n) {
    const { getBodyProps: r } = fo(), o = cs();
    return /* @__PURE__ */ b(
      z.div,
      {
        ...r(t, n),
        className: oe("chakra-popover__body", t.className),
        __css: o.body
      }
    );
  }
);
BW.displayName = "PopoverBody";
const FW = X(
  function(t, n) {
    const { onClose: r } = fo(), o = cs();
    return /* @__PURE__ */ b(
      uu,
      {
        size: "sm",
        onClick: r,
        className: oe("chakra-popover__close-btn", t.className),
        __css: o.closeButton,
        ref: n,
        ...t
      }
    );
  }
);
FW.displayName = "PopoverCloseButton";
function DW(e) {
  if (e)
    return {
      enter: {
        ...e.enter,
        visibility: "visible"
      },
      exit: {
        ...e.exit,
        transitionEnd: {
          visibility: "hidden"
        }
      }
    };
}
const $W = {
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: [0.4, 0, 1, 1]
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      duration: 0.15,
      ease: [0, 0, 0.2, 1]
    }
  }
}, VW = z(Jt.section), kI = X(function(t, n) {
  const { variants: r = $W, ...o } = t, { isOpen: i } = fo();
  return /* @__PURE__ */ b(
    VW,
    {
      ref: n,
      variants: DW(r),
      initial: !1,
      animate: i ? "enter" : "exit",
      ...o
    }
  );
});
kI.displayName = "PopoverTransition";
const LW = X(
  function(t, n) {
    const { rootProps: r, motionProps: o, ...i } = t, { getPopoverProps: s, getPopoverPositionerProps: a, onAnimationComplete: c } = fo(), l = cs(), u = {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      ...l.content
    };
    return /* @__PURE__ */ b(
      z.div,
      {
        ...a(r),
        __css: l.popper,
        className: "chakra-popover__popper",
        children: /* @__PURE__ */ b(
          kI,
          {
            ...o,
            ...s(i, n),
            onAnimationComplete: Gl(
              c,
              i.onAnimationComplete
            ),
            className: oe("chakra-popover__content", t.className),
            __css: u
          }
        )
      }
    );
  }
);
LW.displayName = "PopoverContent";
function zW(e) {
  const t = cs();
  return /* @__PURE__ */ b(
    z.footer,
    {
      ...e,
      className: oe("chakra-popover__footer", e.className),
      __css: t.footer
    }
  );
}
zW.displayName = "PopoverFooter";
const GW = X(
  function(t, n) {
    const { getHeaderProps: r } = fo(), o = cs();
    return /* @__PURE__ */ b(
      z.header,
      {
        ...r(t, n),
        className: oe("chakra-popover__header", t.className),
        __css: o.header
      }
    );
  }
);
GW.displayName = "PopoverHeader";
function WW(e) {
  const t = yr.only(e.children), { getTriggerProps: n } = fo();
  return /* @__PURE__ */ b(Vr, { children: Lt(t, n(t.props, _m(t))) });
}
WW.displayName = "PopoverTrigger";
const Cp = (e) => /* @__PURE__ */ b(z.circle, { cx: 50, cy: 50, r: 42, fill: "transparent", ...e });
Cp.displayName = "Circle";
function HW(e, t, n) {
  return (e - t) * 100 / (n - t);
}
const jW = An({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
}), XW = An({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
}), YW = An({
  "0%": { left: "-40%" },
  "100%": { left: "100%" }
}), ZW = An({
  from: { backgroundPosition: "1rem 0" },
  to: { backgroundPosition: "0 0" }
});
function AI(e) {
  const {
    value: t = 0,
    min: n,
    max: r,
    valueText: o,
    getValueText: i,
    isIndeterminate: s,
    role: a = "progressbar"
  } = e, c = HW(t, n, r);
  return {
    bind: {
      "data-indeterminate": s ? "" : void 0,
      "aria-valuemax": r,
      "aria-valuemin": n,
      "aria-valuenow": s ? void 0 : t,
      "aria-valuetext": (() => {
        if (t != null)
          return typeof i == "function" ? i(t, c) : o;
      })(),
      role: a
    },
    percent: c,
    value: t
  };
}
const TI = (e) => {
  const { size: t, isIndeterminate: n, ...r } = e;
  return /* @__PURE__ */ b(
    z.svg,
    {
      viewBox: "0 0 100 100",
      __css: {
        width: t,
        height: t,
        animation: n ? `${XW} 2s linear infinite` : void 0
      },
      ...r
    }
  );
};
TI.displayName = "Shape";
const UW = X(
  (e, t) => {
    const {
      size: n = "48px",
      max: r = 100,
      min: o = 0,
      valueText: i,
      getValueText: s,
      value: a,
      capIsRound: c,
      children: l,
      thickness: u = "10px",
      color: d = "#0078d4",
      trackColor: f = "#edebe9",
      isIndeterminate: p,
      ...m
    } = e, h = AI({
      min: o,
      max: r,
      value: a,
      valueText: i,
      getValueText: s,
      isIndeterminate: p
    }), g = p ? void 0 : (h.percent ?? 0) * 2.64, v = g == null ? void 0 : `${g} ${264 - g}`, y = p ? {
      css: { animation: `${jW} 1.5s linear infinite` }
    } : {
      strokeDashoffset: 66,
      strokeDasharray: v,
      transitionProperty: "stroke-dasharray, stroke",
      transitionDuration: "0.6s",
      transitionTimingFunction: "ease"
    }, x = {
      display: "inline-block",
      position: "relative",
      verticalAlign: "middle",
      fontSize: n
    };
    return /* @__PURE__ */ Ae(
      z.div,
      {
        ref: t,
        className: "chakra-progress",
        ...h.bind,
        ...m,
        __css: x,
        children: [
          /* @__PURE__ */ Ae(TI, { size: n, isIndeterminate: p, children: [
            /* @__PURE__ */ b(
              Cp,
              {
                stroke: f,
                strokeWidth: u,
                className: "chakra-progress__track"
              }
            ),
            /* @__PURE__ */ b(
              Cp,
              {
                stroke: d,
                strokeWidth: u,
                className: "chakra-progress__indicator",
                strokeLinecap: c ? "round" : void 0,
                opacity: h.value === 0 && !p ? 0 : void 0,
                ...y
              }
            )
          ] }),
          l
        ]
      }
    );
  }
);
UW.displayName = "CircularProgress";
const [JW, KW] = De({
  name: "ProgressStylesContext",
  errorMessage: `useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
}), qW = X(
  (e, t) => {
    const { min: n, max: r, value: o, isIndeterminate: i, role: s, ...a } = e, c = AI({
      value: o,
      min: n,
      max: r,
      isIndeterminate: i,
      role: s
    }), u = {
      height: "100%",
      ...KW().filledTrack
    };
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: t,
        style: { width: `${c.percent}%`, ...a.style },
        ...c.bind,
        ...a,
        __css: u
      }
    );
  }
), QW = X((e, t) => {
  const {
    value: n,
    min: r = 0,
    max: o = 100,
    hasStripe: i,
    isAnimated: s,
    children: a,
    borderRadius: c,
    isIndeterminate: l,
    "aria-label": u,
    "aria-labelledby": d,
    "aria-valuetext": f,
    title: p,
    role: m,
    ...h
  } = $e(e), g = We("Progress", e), v = c ?? g.track?.borderRadius, y = { animation: `${ZW} 1s linear infinite` }, C = {
    ...!l && i && s && y,
    ...l && {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: `${YW} 1s ease infinite normal none running`
    }
  }, w = {
    overflow: "hidden",
    position: "relative",
    ...g.track
  };
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: t,
      borderRadius: v,
      __css: w,
      ...h,
      children: /* @__PURE__ */ Ae(JW, { value: g, children: [
        /* @__PURE__ */ b(
          qW,
          {
            "aria-label": u,
            "aria-labelledby": d,
            "aria-valuetext": f,
            min: r,
            max: o,
            value: n,
            isIndeterminate: l,
            css: C,
            borderRadius: v,
            title: p,
            role: m
          }
        ),
        a
      ] })
    }
  );
});
QW.displayName = "Progress";
function eH(e) {
  return e && Mt(e) && Mt(e.target);
}
function tH(e = {}) {
  const {
    onChange: t,
    value: n,
    defaultValue: r,
    name: o,
    isDisabled: i,
    isFocusable: s,
    isNative: a,
    ...c
  } = e, [l, u] = ue(r || ""), d = typeof n < "u", f = d ? n : l, p = se(null), m = R(() => {
    const C = p.current;
    if (!C)
      return;
    let w = "input:not(:disabled):checked";
    const I = C.querySelector(
      w
    );
    if (I) {
      I.focus();
      return;
    }
    w = "input:not(:disabled)", C.querySelector(w)?.focus();
  }, []), g = `radio-${Xt()}`, v = o || g, y = R(
    (C) => {
      const w = eH(C) ? C.target.value : C;
      d || u(w), t?.(String(w));
    },
    [t, d]
  ), x = R(
    (C = {}, w = null) => ({
      ...C,
      ref: Ge(w, p),
      role: "radiogroup"
    }),
    []
  ), S = R(
    (C = {}, w = null) => ({
      ...C,
      ref: w,
      name: v,
      [a ? "checked" : "isChecked"]: f != null ? C.value === f : void 0,
      onChange(P) {
        y(P);
      },
      "data-radiogroup": !0
    }),
    [a, v, y, f]
  );
  return {
    getRootProps: x,
    getRadioProps: S,
    name: v,
    ref: p,
    focus: m,
    setValue: u,
    value: f,
    onChange: y,
    isDisabled: i,
    isFocusable: s,
    htmlProps: c
  };
}
const [nH, EI] = De({
  name: "RadioGroupContext",
  strict: !1
}), rH = X((e, t) => {
  const {
    colorScheme: n,
    size: r,
    variant: o,
    children: i,
    className: s,
    isDisabled: a,
    isFocusable: c,
    ...l
  } = e, { value: u, onChange: d, getRootProps: f, name: p, htmlProps: m } = tH(l), h = be(
    () => ({
      name: p,
      size: r,
      onChange: d,
      colorScheme: n,
      value: u,
      variant: o,
      isDisabled: a,
      isFocusable: c
    }),
    [
      p,
      r,
      d,
      n,
      u,
      o,
      a,
      c
    ]
  );
  return /* @__PURE__ */ b(nH, { value: h, children: /* @__PURE__ */ b(
    z.div,
    {
      ...f(m, t),
      className: oe("chakra-radio-group", s),
      children: i
    }
  ) });
});
rH.displayName = "RadioGroup";
function oH(e = {}) {
  const {
    defaultChecked: t,
    isChecked: n,
    isFocusable: r,
    isDisabled: o,
    isReadOnly: i,
    isRequired: s,
    onChange: a,
    isInvalid: c,
    name: l,
    value: u,
    id: d,
    "data-radiogroup": f,
    "aria-describedby": p,
    ...m
  } = e, h = `radio-${Xt()}`, g = Zo(), y = !!EI() || !!f;
  let S = !!g && !y ? g.id : h;
  S = d ?? S;
  const C = o ?? g?.isDisabled, w = i ?? g?.isReadOnly, I = s ?? g?.isRequired, P = c ?? g?.isInvalid, [k, A] = ue(!1), [N, B] = ue(!1), [L, Z] = ue(!1), [ne, W] = ue(!!t), O = typeof n < "u", J = O ? n : ne, ee = se(!1);
  ge(() => Dx((K) => {
    ee.current = K;
  }), []);
  const H = R(
    (K) => {
      if (w || C) {
        K.preventDefault();
        return;
      }
      O || W(K.currentTarget.checked), a?.(K);
    },
    [O, C, w, a]
  ), _ = R(
    (K) => {
      K.key === " " && Z(!0);
    },
    [Z]
  ), j = R(
    (K) => {
      K.key === " " && Z(!1);
    },
    [Z]
  ), E = R(
    (K = {}, ae = null) => ({
      ...K,
      ref: ae,
      "data-active": ye(L),
      "data-hover": ye(N),
      "data-disabled": ye(C),
      "data-invalid": ye(P),
      "data-checked": ye(J),
      "data-focus": ye(k),
      "data-focus-visible": ye(k && ee.current),
      "data-readonly": ye(w),
      "aria-hidden": !0,
      onMouseDown: fe(K.onMouseDown, () => Z(!0)),
      onMouseUp: fe(K.onMouseUp, () => Z(!1)),
      onMouseEnter: fe(
        K.onMouseEnter,
        () => B(!0)
      ),
      onMouseLeave: fe(
        K.onMouseLeave,
        () => B(!1)
      )
    }),
    [
      L,
      N,
      C,
      P,
      J,
      k,
      w
    ]
  ), { onFocus: M, onBlur: F } = g ?? {}, G = R(
    (K = {}, ae = null) => {
      const Y = C && !r;
      return {
        ...K,
        id: S,
        ref: ae,
        type: "radio",
        name: l,
        value: u,
        onChange: fe(K.onChange, H),
        onBlur: fe(
          F,
          K.onBlur,
          () => A(!1)
        ),
        onFocus: fe(
          M,
          K.onFocus,
          () => A(!0)
        ),
        onKeyDown: fe(K.onKeyDown, _),
        onKeyUp: fe(K.onKeyUp, j),
        checked: J,
        disabled: Y,
        readOnly: w,
        required: I,
        "aria-invalid": Vt(P),
        "aria-disabled": Vt(Y),
        "aria-required": Vt(I),
        "data-readonly": ye(w),
        "aria-describedby": p,
        style: pu
      };
    },
    [
      C,
      r,
      S,
      l,
      u,
      H,
      F,
      M,
      _,
      j,
      J,
      w,
      I,
      P,
      p
    ]
  );
  return {
    state: {
      isInvalid: P,
      isFocused: k,
      isChecked: J,
      isActive: L,
      isHovered: N,
      isDisabled: C,
      isReadOnly: w,
      isRequired: I
    },
    getRadioProps: E,
    getInputProps: G,
    getLabelProps: (K = {}, ae = null) => ({
      ...K,
      ref: ae,
      onMouseDown: fe(K.onMouseDown, iH),
      "data-disabled": ye(C),
      "data-checked": ye(J),
      "data-invalid": ye(P)
    }),
    getRootProps: (K, ae = null) => ({
      htmlFor: S,
      ...K,
      ref: ae,
      "data-disabled": ye(C),
      "data-checked": ye(J),
      "data-invalid": ye(P)
    }),
    htmlProps: m
  };
}
function iH(e) {
  e.preventDefault(), e.stopPropagation();
}
const sH = X((e, t) => {
  const n = EI(), { onChange: r, value: o } = e, i = We("Radio", { ...n, ...e }), s = $e(e), {
    spacing: a = "0.5rem",
    children: c,
    isDisabled: l = n?.isDisabled,
    isFocusable: u = n?.isFocusable,
    inputProps: d,
    ...f
  } = s;
  let p = e.isChecked;
  n?.value != null && o != null && (p = n.value === o);
  let m = r;
  n?.onChange && o != null && (m = Gl(n.onChange, r));
  const h = e?.name ?? n?.name, {
    getInputProps: g,
    getRadioProps: v,
    getLabelProps: y,
    getRootProps: x,
    htmlProps: S
  } = oH({
    ...f,
    isChecked: p,
    isFocusable: u,
    isDisabled: l,
    onChange: m,
    name: h
  }), [C, w] = G0(S, i1), I = v(w), P = g(d, t), k = y(), A = Object.assign({}, C, x()), N = {
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    cursor: "pointer",
    position: "relative",
    ...i.container
  }, B = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...i.control
  }, L = {
    userSelect: "none",
    marginStart: a,
    ...i.label
  };
  return /* @__PURE__ */ Ae(z.label, { className: "chakra-radio", ...A, __css: N, children: [
    /* @__PURE__ */ b("input", { className: "chakra-radio__input", ...P }),
    /* @__PURE__ */ b(
      z.span,
      {
        className: "chakra-radio__control",
        ...I,
        __css: B
      }
    ),
    c && /* @__PURE__ */ b(
      z.span,
      {
        className: "chakra-radio__label",
        ...k,
        __css: L,
        children: c
      }
    )
  ] });
});
sH.displayName = "Radio";
const RI = X(
  function(t, n) {
    const { children: r, placeholder: o, className: i, ...s } = t;
    return /* @__PURE__ */ Ae(
      z.select,
      {
        ...s,
        ref: n,
        className: oe("chakra-select", i),
        children: [
          o && /* @__PURE__ */ b("option", { value: "", children: o }),
          r
        ]
      }
    );
  }
);
RI.displayName = "SelectField";
const aH = X((e, t) => {
  const n = We("Select", e), {
    rootProps: r,
    placeholder: o,
    icon: i,
    color: s,
    height: a,
    h: c,
    minH: l,
    minHeight: u,
    iconColor: d,
    iconSize: f,
    ...p
  } = $e(e), [m, h] = G0(p, i1), g = as(h), v = {
    width: "100%",
    height: "fit-content",
    position: "relative",
    color: s
  }, y = {
    paddingEnd: "2rem",
    ...n.field,
    _focus: {
      zIndex: "unset",
      ...n.field?._focus
    }
  };
  return /* @__PURE__ */ Ae(
    z.div,
    {
      className: "chakra-select__wrapper",
      __css: v,
      ...m,
      ...r,
      children: [
        /* @__PURE__ */ b(
          RI,
          {
            ref: t,
            height: c ?? a,
            minH: l ?? u,
            placeholder: o,
            ...g,
            __css: y,
            children: e.children
          }
        ),
        /* @__PURE__ */ b(
          _I,
          {
            "data-disabled": ye(g.disabled),
            ...(d || s) && { color: d || s },
            __css: n.icon,
            ...f && { fontSize: f },
            children: i
          }
        )
      ]
    }
  );
});
aH.displayName = "Select";
const cH = (e) => /* @__PURE__ */ b("svg", { viewBox: "0 0 24 24", ...e, children: /* @__PURE__ */ b(
  "path",
  {
    fill: "currentColor",
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }
) }), lH = z("div", {
  baseStyle: {
    position: "absolute",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    pointerEvents: "none",
    top: "50%",
    transform: "translateY(-50%)"
  }
}), _I = (e) => {
  const { children: t = /* @__PURE__ */ b(cH, {}), ...n } = e, r = Lt(t, {
    role: "presentation",
    className: "chakra-select__icon",
    focusable: !1,
    "aria-hidden": !0,
    // force icon to adhere to `IconWrapper` styles
    style: {
      width: "1em",
      height: "1em",
      color: "currentColor"
    }
  });
  return /* @__PURE__ */ b(lH, { ...n, className: "chakra-select__icon-wrapper", children: ao(t) ? r : null });
};
_I.displayName = "SelectIcon";
function uH() {
  const e = se(!0);
  return ge(() => {
    e.current = !1;
  }, []), e.current;
}
const dH = z("div", {
  baseStyle: {
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    }
  }
}), Ip = Te("skeleton-start-color"), wp = Te("skeleton-end-color"), fH = An({
  from: { opacity: 0 },
  to: { opacity: 1 }
}), pH = An({
  from: {
    borderColor: Ip.reference,
    background: Ip.reference
  },
  to: {
    borderColor: wp.reference,
    background: wp.reference
  }
}), hH = X((e, t) => {
  const n = {
    ...e,
    fadeDuration: typeof e.fadeDuration == "number" ? e.fadeDuration : 0.4,
    speed: typeof e.speed == "number" ? e.speed : 0.8
  }, r = Gt("Skeleton", n), o = uH(), {
    startColor: i = "",
    endColor: s = "",
    isLoaded: a,
    fadeDuration: c,
    speed: l,
    className: u,
    fitContent: d,
    animation: f,
    ...p
  } = $e(n), [m, h] = k5("colors", [
    i,
    s
  ]), g = eT(a), v = oe("chakra-skeleton", u), y = {
    ...m && { [Ip.variable]: m },
    ...h && { [wp.variable]: h }
  };
  if (a) {
    const x = o || g ? "none" : `${fH} ${c}s`;
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: t,
        className: v,
        __css: { animation: x },
        ...p
      }
    );
  }
  return /* @__PURE__ */ b(
    dH,
    {
      ref: t,
      className: v,
      ...p,
      __css: {
        width: d ? "fit-content" : void 0,
        ...r,
        ...y,
        _dark: { ...r._dark, ...y },
        animation: f || `${l}s linear infinite alternate ${pH}`
      }
    }
  );
});
hH.displayName = "Skeleton";
function mH(e) {
  return {
    root: `slider-root-${e}`,
    getThumb: (t) => `slider-thumb-${e}-${t}`,
    getInput: (t) => `slider-input-${e}-${t}`,
    track: `slider-track-${e}`,
    innerTrack: `slider-filled-track-${e}`,
    getMarker: (t) => `slider-marker-${e}-${t}`,
    output: `slider-output-${e}`
  };
}
function Hc(e) {
  const { orientation: t, vertical: n, horizontal: r } = e;
  return t === "vertical" ? n : r;
}
function OI(e) {
  const { orientation: t, thumbPercents: n, isReversed: r } = e, o = (p) => ({
    position: "absolute",
    userSelect: "none",
    WebkitUserSelect: "none",
    MozUserSelect: "none",
    msUserSelect: "none",
    touchAction: "none",
    ...Hc({
      orientation: t,
      vertical: {
        bottom: `${n[p]}%`,
        transform: "translate(-50%, 50%) scale(var(--slider-thumb-scale, 1))"
      },
      horizontal: {
        left: `${n[p]}%`,
        transform: "translate(-50%, -50%) scale(var(--slider-thumb-scale, 1))"
      }
    })
  }), i = {
    position: "relative",
    touchAction: "none",
    WebkitTapHighlightColor: "rgba(0,0,0,0)",
    userSelect: "none",
    outline: 0
  }, s = {
    position: "absolute",
    ...Hc({
      orientation: t,
      vertical: {
        left: "50%",
        transform: "translateX(-50%)",
        height: "100%"
      },
      horizontal: {
        top: "50%",
        transform: "translateY(-50%)",
        width: "100%"
      }
    })
  }, a = n.length === 1, c = [0, r ? 100 - n[0] : n[0]], l = a ? c : n;
  let u = l[0];
  !a && r && (u = 100 - u);
  const d = Math.abs(l[l.length - 1] - l[0]), f = {
    ...s,
    ...Hc({
      orientation: t,
      vertical: r ? { height: `${d}%`, top: `${u}%` } : { height: `${d}%`, bottom: `${u}%` },
      horizontal: r ? { width: `${d}%`, right: `${u}%` } : { width: `${d}%`, left: `${u}%` }
    })
  };
  return { trackStyle: s, innerTrackStyle: f, rootStyle: i, getThumbStyle: o };
}
function NI(e) {
  const { isReversed: t, direction: n, orientation: r } = e;
  return n === "ltr" || r === "vertical" ? t : !t;
}
function gH(e) {
  const {
    min: t = 0,
    max: n = 100,
    onChange: r,
    value: o,
    defaultValue: i,
    isReversed: s,
    direction: a = "ltr",
    orientation: c = "horizontal",
    id: l,
    isDisabled: u,
    isReadOnly: d,
    onChangeStart: f,
    onChangeEnd: p,
    step: m = 1,
    getAriaValueText: h,
    "aria-valuetext": g,
    "aria-label": v,
    "aria-labelledby": y,
    name: x,
    focusThumbOnChange: S = !0,
    minStepsBetweenThumbs: C = 0,
    ...w
  } = e, I = pt(f), P = pt(p), k = pt(h), A = NI({
    isReversed: s,
    direction: a,
    orientation: c
  }), [N, B] = co({
    value: o,
    defaultValue: i ?? [25, 75],
    onChange: r
  });
  if (!Array.isArray(N))
    throw new TypeError(
      `[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof N}\``
    );
  const [L, Z] = ue(!1), [ne, W] = ue(!1), [O, J] = ue(-1), ee = !(u || d), H = se(N), _ = N.map((me) => _i(me, t, n)), j = C * m, E = bH(_, t, n, j), M = se({
    eventSource: null,
    value: [],
    valueBounds: []
  });
  M.current.value = _, M.current.valueBounds = E;
  const F = _.map((me) => n - me + t), q = (A ? F : _).map((me) => nl(me, t, n)), te = c === "vertical", U = se(null), K = se(null), ae = Xt(), ce = mH(l ?? ae), re = R(
    (me) => {
      if (!U.current)
        return;
      M.current.eventSource = "pointer";
      const ke = U.current.getBoundingClientRect(), { clientX: Re, clientY: Le } = me.touches?.[0] ?? me, Je = te ? ke.bottom - Le : Re - ke.left, qt = te ? ke.height : ke.width;
      let Wt = Je / qt;
      return A && (Wt = 1 - Wt), $0(Wt, t, n);
    },
    [te, A, n, t]
  ), Ce = (n - t) / 10, Ve = m || (n - t) / 100, le = be(
    () => ({
      setValueAtIndex(me, ke) {
        if (!ee)
          return;
        const Re = M.current.valueBounds[me];
        ke = parseFloat(_f(ke, Re.min, Ve)), ke = _i(ke, Re.min, Re.max);
        const Le = [...M.current.value];
        Le[me] = ke, B(Le);
      },
      setActiveIndex: J,
      stepUp(me, ke = Ve) {
        const Re = M.current.value[me], Le = A ? Re - ke : Re + ke;
        le.setValueAtIndex(me, Le);
      },
      stepDown(me, ke = Ve) {
        const Re = M.current.value[me], Le = A ? Re + ke : Re - ke;
        le.setValueAtIndex(me, Le);
      },
      reset() {
        B(H.current);
      }
    }),
    [Ve, A, B, ee]
  ), Pe = R(
    (me) => {
      const ke = me.key, Le = {
        ArrowRight: () => le.stepUp(O),
        ArrowUp: () => le.stepUp(O),
        ArrowLeft: () => le.stepDown(O),
        ArrowDown: () => le.stepDown(O),
        PageUp: () => le.stepUp(O, Ce),
        PageDown: () => le.stepDown(O, Ce),
        Home: () => {
          const { min: Je } = E[O];
          le.setValueAtIndex(O, Je);
        },
        End: () => {
          const { max: Je } = E[O];
          le.setValueAtIndex(O, Je);
        }
      }[ke];
      Le && (me.preventDefault(), me.stopPropagation(), Le(me), M.current.eventSource = "keyboard");
    },
    [le, O, Ce, E]
  ), { getThumbStyle: ve, rootStyle: he, trackStyle: _e, innerTrackStyle: Oe } = be(
    () => OI({
      isReversed: A,
      orientation: c,
      thumbPercents: q
    }),
    [A, c, q]
  ), ze = R(
    (me) => {
      const ke = me ?? O;
      if (ke !== -1 && S) {
        const Re = ce.getThumb(ke), Le = K.current?.ownerDocument.getElementById(Re);
        Le && setTimeout(() => Le.focus());
      }
    },
    [S, O, ce]
  );
  Jn(() => {
    M.current.eventSource === "keyboard" && P?.(M.current.value);
  }, [_, P]);
  const Ye = (me) => {
    const ke = re(me) || 0, Re = M.current.value.map(
      (nn) => Math.abs(nn - ke)
    ), Le = Math.min(...Re);
    let Je = Re.indexOf(Le);
    const qt = Re.filter(
      (nn) => nn === Le
    );
    qt.length > 1 && ke > M.current.value[Je] && (Je = Je + qt.length - 1), J(Je), le.setValueAtIndex(Je, ke), ze(Je);
  }, Yt = (me) => {
    if (O == -1)
      return;
    const ke = re(me) || 0;
    J(O), le.setValueAtIndex(O, ke), ze(O);
  };
  e1(K, {
    onPanSessionStart(me) {
      ee && (Z(!0), Ye(me), I?.(M.current.value));
    },
    onPanSessionEnd() {
      ee && (Z(!1), P?.(M.current.value));
    },
    onPan(me) {
      ee && Yt(me);
    }
  });
  const Kt = R(
    (me = {}, ke = null) => ({
      ...me,
      ...w,
      id: ce.root,
      ref: Ge(ke, K),
      tabIndex: -1,
      "aria-disabled": Vt(u),
      "data-focused": ye(ne),
      style: { ...me.style, ...he }
    }),
    [w, u, ne, he, ce]
  ), tn = R(
    (me = {}, ke = null) => ({
      ...me,
      ref: Ge(ke, U),
      id: ce.track,
      "data-disabled": ye(u),
      style: { ...me.style, ..._e }
    }),
    [u, _e, ce]
  ), de = R(
    (me = {}, ke = null) => ({
      ...me,
      ref: ke,
      id: ce.innerTrack,
      style: {
        ...me.style,
        ...Oe
      }
    }),
    [Oe, ce]
  ), Ue = R(
    (me, ke = null) => {
      const { index: Re, ...Le } = me, Je = _[Re];
      if (Je == null)
        throw new TypeError(
          `[range-slider > thumb] Cannot find value at index \`${Re}\`. The \`value\` or \`defaultValue\` length is : ${_.length}`
        );
      const qt = E[Re];
      return {
        ...Le,
        ref: ke,
        role: "slider",
        tabIndex: ee ? 0 : void 0,
        id: ce.getThumb(Re),
        "data-active": ye(L && O === Re),
        "aria-valuetext": k?.(Je) ?? g?.[Re],
        "aria-valuemin": qt.min,
        "aria-valuemax": qt.max,
        "aria-valuenow": Je,
        "aria-orientation": c,
        "aria-disabled": Vt(u),
        "aria-readonly": Vt(d),
        "aria-label": v?.[Re],
        "aria-labelledby": v?.[Re] ? void 0 : y?.[Re],
        style: { ...me.style, ...ve(Re) },
        onKeyDown: fe(me.onKeyDown, Pe),
        onFocus: fe(me.onFocus, () => {
          W(!0), J(Re);
        }),
        onBlur: fe(me.onBlur, () => {
          W(!1), J(-1);
        })
      };
    },
    [
      ce,
      _,
      E,
      ee,
      L,
      O,
      k,
      g,
      c,
      u,
      d,
      v,
      y,
      ve,
      Pe,
      W
    ]
  ), pe = R(
    (me = {}, ke = null) => ({
      ...me,
      ref: ke,
      id: ce.output,
      htmlFor: _.map((Re, Le) => ce.getThumb(Le)).join(" "),
      "aria-live": "off"
    }),
    [ce, _]
  ), Se = R(
    (me, ke = null) => {
      const { value: Re, ...Le } = me, Je = !(Re < t || Re > n), qt = Re >= _[0] && Re <= _[_.length - 1];
      let Wt = nl(Re, t, n);
      Wt = A ? 100 - Wt : Wt;
      const nn = {
        position: "absolute",
        pointerEvents: "none",
        ...Hc({
          orientation: c,
          vertical: { bottom: `${Wt}%` },
          horizontal: { left: `${Wt}%` }
        })
      };
      return {
        ...Le,
        ref: ke,
        id: ce.getMarker(me.value),
        role: "presentation",
        "aria-hidden": !0,
        "data-disabled": ye(u),
        "data-invalid": ye(!Je),
        "data-highlighted": ye(qt),
        style: {
          ...me.style,
          ...nn
        }
      };
    },
    [u, A, n, t, c, _, ce]
  ), vt = R(
    (me, ke = null) => {
      const { index: Re, ...Le } = me;
      return {
        ...Le,
        ref: ke,
        id: ce.getInput(Re),
        type: "hidden",
        value: _[Re],
        name: Array.isArray(x) ? x[Re] : `${x}-${Re}`
      };
    },
    [x, _, ce]
  );
  return {
    state: {
      value: _,
      isFocused: ne,
      isDragging: L,
      getThumbPercent: (me) => q[me],
      getThumbMinValue: (me) => E[me].min,
      getThumbMaxValue: (me) => E[me].max
    },
    actions: le,
    getRootProps: Kt,
    getTrackProps: tn,
    getInnerTrackProps: de,
    getThumbProps: Ue,
    getMarkerProps: Se,
    getInputProps: vt,
    getOutputProps: pe
  };
}
function bH(e, t, n, r) {
  return e.map((o, i) => {
    const s = i === 0 ? t : e[i - 1] + r, a = i === e.length - 1 ? n : e[i + 1] - r;
    return { min: s, max: a };
  });
}
const [vH, yu] = De({
  name: "SliderContext",
  errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
}), [yH, Su] = De({
  name: "RangeSliderStylesContext",
  errorMessage: `useRangeSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
}), MI = X(
  function(t, n) {
    const r = {
      orientation: "horizontal",
      ...t
    }, o = We("Slider", r), i = $e(r), { direction: s } = bn();
    i.direction = s;
    const { getRootProps: a, ...c } = gH(i), l = be(
      () => ({ ...c, name: r.name }),
      [c, r.name]
    );
    return /* @__PURE__ */ b(vH, { value: l, children: /* @__PURE__ */ b(yH, { value: o, children: /* @__PURE__ */ b(
      z.div,
      {
        ...a({}, n),
        className: "chakra-slider",
        __css: o.container,
        children: r.children
      }
    ) }) });
  }
);
MI.displayName = "RangeSlider";
const Pp = X(
  function(t, n) {
    const { getThumbProps: r, getInputProps: o, name: i } = yu(), s = Su(), a = r(t, n);
    return /* @__PURE__ */ Ae(
      z.div,
      {
        ...a,
        className: oe("chakra-slider__thumb", t.className),
        __css: s.thumb,
        children: [
          a.children,
          i && /* @__PURE__ */ b("input", { ...o({ index: t.index }) })
        ]
      }
    );
  }
);
Pp.displayName = "RangeSliderThumb";
const BI = X(
  function(t, n) {
    const { getTrackProps: r } = yu(), o = Su(), i = r(t, n);
    return /* @__PURE__ */ b(
      z.div,
      {
        ...i,
        className: oe("chakra-slider__track", t.className),
        __css: o.track,
        "data-testid": "chakra-range-slider-track"
      }
    );
  }
);
BI.displayName = "RangeSliderTrack";
const FI = X(function(t, n) {
  const { getInnerTrackProps: r } = yu(), o = Su(), i = r(t, n);
  return /* @__PURE__ */ b(
    z.div,
    {
      ...i,
      className: "chakra-slider__filled-track",
      __css: o.filledTrack
    }
  );
});
FI.displayName = "RangeSliderFilledTrack";
const jc = X(
  function(t, n) {
    const { getMarkerProps: r } = yu(), o = Su(), i = r(t, n);
    return /* @__PURE__ */ b(
      z.div,
      {
        ...i,
        className: oe("chakra-slider__marker", t.className),
        __css: o.mark
      }
    );
  }
);
jc.displayName = "RangeSliderMark";
function SH(e) {
  const {
    min: t = 0,
    max: n = 100,
    onChange: r,
    value: o,
    defaultValue: i,
    isReversed: s,
    direction: a = "ltr",
    orientation: c = "horizontal",
    id: l,
    isDisabled: u,
    isReadOnly: d,
    onChangeStart: f,
    onChangeEnd: p,
    step: m = 1,
    getAriaValueText: h,
    "aria-valuetext": g,
    "aria-label": v,
    "aria-labelledby": y,
    name: x,
    focusThumbOnChange: S = !0,
    ...C
  } = e, w = pt(f), I = pt(p), P = pt(h), k = NI({
    isReversed: s,
    direction: a,
    orientation: c
  }), [A, N] = co({
    value: o,
    defaultValue: i ?? CH(t, n),
    onChange: r
  }), [B, L] = ue(!1), [Z, ne] = ue(!1), W = !(u || d), O = (n - t) / 10, J = m || (n - t) / 100, ee = _i(A, t, n), H = n - ee + t, j = nl(k ? H : ee, t, n), E = c === "vertical", M = Z0({
    min: t,
    max: n,
    step: m,
    isDisabled: u,
    value: ee,
    isInteractive: W,
    isReversed: k,
    isVertical: E,
    eventSource: null,
    focusThumbOnChange: S,
    orientation: c
  }), F = se(null), G = se(null), q = se(null), te = Xt(), U = l ?? te, [K, ae] = [`slider-thumb-${U}`, `slider-track-${U}`], Y = R(
    (pe) => {
      if (!F.current)
        return;
      const Se = M.current;
      Se.eventSource = "pointer";
      const vt = F.current.getBoundingClientRect(), { clientX: cn, clientY: me } = pe.touches?.[0] ?? pe, ke = E ? vt.bottom - me : cn - vt.left, Re = E ? vt.height : vt.width;
      let Le = ke / Re;
      k && (Le = 1 - Le);
      let Je = $0(Le, Se.min, Se.max);
      return Se.step && (Je = parseFloat(
        _f(Je, Se.min, Se.step)
      )), Je = _i(Je, Se.min, Se.max), Je;
    },
    [E, k, M]
  ), ce = R(
    (pe) => {
      const Se = M.current;
      Se.isInteractive && (pe = parseFloat(_f(pe, Se.min, J)), pe = _i(pe, Se.min, Se.max), N(pe));
    },
    [J, N, M]
  ), re = be(
    () => ({
      stepUp(pe = J) {
        const Se = k ? ee - pe : ee + pe;
        ce(Se);
      },
      stepDown(pe = J) {
        const Se = k ? ee + pe : ee - pe;
        ce(Se);
      },
      reset() {
        ce(i || 0);
      },
      stepTo(pe) {
        ce(pe);
      }
    }),
    [ce, k, ee, J, i]
  ), Ce = R(
    (pe) => {
      const Se = M.current, cn = {
        ArrowRight: () => re.stepUp(),
        ArrowUp: () => re.stepUp(),
        ArrowLeft: () => re.stepDown(),
        ArrowDown: () => re.stepDown(),
        PageUp: () => re.stepUp(O),
        PageDown: () => re.stepDown(O),
        Home: () => ce(Se.min),
        End: () => ce(Se.max)
      }[pe.key];
      cn && (pe.preventDefault(), pe.stopPropagation(), cn(pe), Se.eventSource = "keyboard");
    },
    [re, ce, O, M]
  ), Ve = P?.(ee) ?? g, { getThumbStyle: le, rootStyle: Pe, trackStyle: ve, innerTrackStyle: he } = be(() => {
    const pe = M.current;
    return OI({
      isReversed: k,
      orientation: pe.orientation,
      thumbPercents: [j]
    });
  }, [k, j, M]), _e = R(() => {
    M.current.focusThumbOnChange && setTimeout(() => G.current?.focus());
  }, [M]);
  Jn(() => {
    const pe = M.current;
    _e(), pe.eventSource === "keyboard" && I?.(pe.value);
  }, [ee, I]);
  function Oe(pe) {
    const Se = Y(pe);
    Se != null && Se !== M.current.value && N(Se);
  }
  e1(q, {
    onPanSessionStart(pe) {
      const Se = M.current;
      Se.isInteractive && (L(!0), _e(), Oe(pe), w?.(Se.value));
    },
    onPanSessionEnd() {
      const pe = M.current;
      pe.isInteractive && (L(!1), I?.(pe.value));
    },
    onPan(pe) {
      M.current.isInteractive && Oe(pe);
    }
  });
  const ze = R(
    (pe = {}, Se = null) => ({
      ...pe,
      ...C,
      ref: Ge(Se, q),
      tabIndex: -1,
      "aria-disabled": Vt(u),
      "data-focused": ye(Z),
      style: {
        ...pe.style,
        ...Pe
      }
    }),
    [C, u, Z, Pe]
  ), Ye = R(
    (pe = {}, Se = null) => ({
      ...pe,
      ref: Ge(Se, F),
      id: ae,
      "data-disabled": ye(u),
      style: {
        ...pe.style,
        ...ve
      }
    }),
    [u, ae, ve]
  ), Yt = R(
    (pe = {}, Se = null) => ({
      ...pe,
      ref: Se,
      style: {
        ...pe.style,
        ...he
      }
    }),
    [he]
  ), Kt = R(
    (pe = {}, Se = null) => ({
      ...pe,
      ref: Ge(Se, G),
      role: "slider",
      tabIndex: W ? 0 : void 0,
      id: K,
      "data-active": ye(B),
      "aria-valuetext": Ve,
      "aria-valuemin": t,
      "aria-valuemax": n,
      "aria-valuenow": ee,
      "aria-orientation": c,
      "aria-disabled": Vt(u),
      "aria-readonly": Vt(d),
      "aria-label": v,
      "aria-labelledby": v ? void 0 : y,
      style: {
        ...pe.style,
        ...le(0)
      },
      onKeyDown: fe(pe.onKeyDown, Ce),
      onFocus: fe(pe.onFocus, () => ne(!0)),
      onBlur: fe(pe.onBlur, () => ne(!1))
    }),
    [
      W,
      K,
      B,
      Ve,
      t,
      n,
      ee,
      c,
      u,
      d,
      v,
      y,
      le,
      Ce
    ]
  ), tn = R(
    (pe, Se = null) => {
      const vt = !(pe.value < t || pe.value > n), cn = ee >= pe.value, me = nl(pe.value, t, n), ke = {
        position: "absolute",
        pointerEvents: "none",
        ...xH({
          orientation: c,
          vertical: {
            bottom: k ? `${100 - me}%` : `${me}%`
          },
          horizontal: {
            left: k ? `${100 - me}%` : `${me}%`
          }
        })
      };
      return {
        ...pe,
        ref: Se,
        role: "presentation",
        "aria-hidden": !0,
        "data-disabled": ye(u),
        "data-invalid": ye(!vt),
        "data-highlighted": ye(cn),
        style: {
          ...pe.style,
          ...ke
        }
      };
    },
    [u, k, n, t, c, ee]
  ), de = R(
    (pe = {}, Se = null) => ({
      ...pe,
      ref: Se,
      type: "hidden",
      value: ee,
      name: x
    }),
    [x, ee]
  );
  return {
    state: { value: ee, isFocused: Z, isDragging: B },
    actions: re,
    getRootProps: ze,
    getTrackProps: Ye,
    getInnerTrackProps: Yt,
    getThumbProps: Kt,
    getMarkerProps: tn,
    getInputProps: de
  };
}
function xH(e) {
  const { orientation: t, vertical: n, horizontal: r } = e;
  return t === "vertical" ? n : r;
}
function CH(e, t) {
  return t < e ? e : e + (t - e) / 2;
}
const [IH, xu] = De({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<Slider />"
}), [wH, Cu] = De({
  name: "SliderStylesContext",
  hookName: "useSliderStyles",
  providerName: "<Slider />"
}), DI = X((e, t) => {
  const n = {
    ...e,
    orientation: e?.orientation ?? "horizontal"
  }, r = We("Slider", n), o = $e(n), { direction: i } = bn();
  o.direction = i;
  const { getInputProps: s, getRootProps: a, ...c } = SH(o), l = a(), u = s({}, t);
  return /* @__PURE__ */ b(IH, { value: c, children: /* @__PURE__ */ b(wH, { value: r, children: /* @__PURE__ */ Ae(
    z.div,
    {
      ...l,
      className: oe("chakra-slider", n.className),
      __css: r.container,
      children: [
        n.children,
        /* @__PURE__ */ b("input", { ...u })
      ]
    }
  ) }) });
});
DI.displayName = "Slider";
const $I = X((e, t) => {
  const { getThumbProps: n } = xu(), r = Cu(), o = n(e, t);
  return /* @__PURE__ */ b(
    z.div,
    {
      ...o,
      className: oe("chakra-slider__thumb", e.className),
      __css: r.thumb
    }
  );
});
$I.displayName = "SliderThumb";
const VI = X((e, t) => {
  const { getTrackProps: n } = xu(), r = Cu(), o = n(e, t);
  return /* @__PURE__ */ b(
    z.div,
    {
      ...o,
      className: oe("chakra-slider__track", e.className),
      __css: r.track
    }
  );
});
VI.displayName = "SliderTrack";
const LI = X(
  (e, t) => {
    const { getInnerTrackProps: n } = xu(), r = Cu(), o = n(e, t);
    return /* @__PURE__ */ b(
      z.div,
      {
        ...o,
        className: oe("chakra-slider__filled-track", e.className),
        __css: r.filledTrack
      }
    );
  }
);
LI.displayName = "SliderFilledTrack";
const Xc = X((e, t) => {
  const { getMarkerProps: n } = xu(), r = Cu(), o = n(e, t);
  return /* @__PURE__ */ b(
    z.div,
    {
      ...o,
      className: oe("chakra-slider__marker", e.className),
      __css: r.mark
    }
  );
});
Xc.displayName = "SliderMark";
const zI = (e) => /* @__PURE__ */ b(
  z.div,
  {
    className: "chakra-stack__item",
    ...e,
    __css: {
      display: "inline-block",
      flex: "0 0 auto",
      minWidth: 0,
      ...e.__css
    }
  }
);
zI.displayName = "StackItem";
function PH(e) {
  const { spacing: t, direction: n } = e, r = {
    column: {
      my: t,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: t,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: t,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: t,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": Sa(
      n,
      (o) => r[o]
    )
  };
}
const Om = X((e, t) => {
  const {
    isInline: n,
    direction: r,
    align: o,
    justify: i,
    spacing: s = "0.5rem",
    wrap: a,
    children: c,
    divider: l,
    className: u,
    shouldWrapChildren: d,
    ...f
  } = e, p = n ? "row" : r ?? "column", m = be(
    () => PH({ spacing: s, direction: p }),
    [s, p]
  ), h = !!l, g = !d && !h, v = be(() => {
    const x = Hr(c);
    return g ? x : x.map((S, C) => {
      const w = typeof S.key < "u" ? S.key : C, I = C + 1 === x.length, k = d ? /* @__PURE__ */ b(zI, { children: S }, w) : S;
      if (!h)
        return k;
      const A = Lt(
        l,
        {
          __css: m
        }
      );
      return /* @__PURE__ */ Ae(Hi, { children: [
        k,
        I ? null : A
      ] }, w);
    });
  }, [
    l,
    m,
    h,
    g,
    d,
    c
  ]), y = oe("chakra-stack", u);
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: t,
      display: "flex",
      alignItems: o,
      justifyContent: i,
      flexDirection: p,
      flexWrap: a,
      gap: h ? void 0 : s,
      className: y,
      ...f,
      children: v
    }
  );
});
Om.displayName = "Stack";
const kH = X((e, t) => /* @__PURE__ */ b(Om, { align: "center", ...e, direction: "row", ref: t }));
kH.displayName = "HStack";
const AH = X((e, t) => /* @__PURE__ */ b(Om, { align: "center", ...e, direction: "column", ref: t }));
AH.displayName = "VStack";
const [TH, Iu] = De({
  name: "StatStylesContext",
  errorMessage: `useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `
}), EH = X(function(t, n) {
  const r = We("Stat", t), o = {
    position: "relative",
    flex: "1 1 0%",
    ...r.container
  }, { className: i, children: s, ...a } = $e(t);
  return /* @__PURE__ */ b(TH, { value: r, children: /* @__PURE__ */ b(
    z.div,
    {
      ref: n,
      ...a,
      className: oe("chakra-stat", i),
      __css: o,
      children: /* @__PURE__ */ b("dl", { children: s })
    }
  ) });
});
EH.displayName = "Stat";
const GI = (e) => /* @__PURE__ */ b(It, { color: "red.400", ...e, children: /* @__PURE__ */ b(
  "path",
  {
    fill: "currentColor",
    d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
  }
) });
GI.displayName = "StatDownArrow";
function WI(e) {
  return /* @__PURE__ */ b(It, { color: "green.400", ...e, children: /* @__PURE__ */ b(
    "path",
    {
      fill: "currentColor",
      d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
    }
  ) });
}
WI.displayName = "StatUpArrow";
function RH(e) {
  const { type: t, "aria-label": n, ...r } = e, o = Iu(), i = t === "increase" ? WI : GI, a = n || (t === "increase" ? "increased by" : "decreased by");
  return /* @__PURE__ */ Ae(Vr, { children: [
    /* @__PURE__ */ b(z.span, { srOnly: !0, children: a }),
    /* @__PURE__ */ b(i, { "aria-hidden": !0, ...r, __css: o.icon })
  ] });
}
RH.displayName = "StatArrow";
const _H = X(
  function(t, n) {
    return /* @__PURE__ */ b(
      z.div,
      {
        ...t,
        ref: n,
        role: "group",
        className: oe("chakra-stat__group", t.className),
        __css: {
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "space-around",
          alignItems: "flex-start"
        }
      }
    );
  }
);
_H.displayName = "StatGroup";
const OH = X(
  function(t, n) {
    const r = Iu();
    return /* @__PURE__ */ b(
      z.dd,
      {
        ref: n,
        ...t,
        className: oe("chakra-stat__help-text", t.className),
        __css: r.helpText
      }
    );
  }
);
OH.displayName = "StatHelpText";
const NH = X(
  function(t, n) {
    const r = Iu();
    return /* @__PURE__ */ b(
      z.dt,
      {
        ref: n,
        ...t,
        className: oe("chakra-stat__label", t.className),
        __css: r.label
      }
    );
  }
);
NH.displayName = "StatLabel";
const MH = X(
  function(t, n) {
    const r = Iu();
    return /* @__PURE__ */ b(
      z.dd,
      {
        ref: n,
        ...t,
        className: oe("chakra-stat__number", t.className),
        __css: {
          ...r.number,
          fontFeatureSettings: "pnum",
          fontVariantNumeric: "proportional-nums"
        }
      }
    );
  }
);
MH.displayName = "StatNumber";
const [BH, po] = De(
  { name: "StepContext" }
), [FH, Ko] = D1("Stepper"), $Q = X(function(t, n) {
  const { orientation: r, status: o, showLastSeparator: i } = po(), s = Ko();
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: n,
      "data-status": o,
      "data-orientation": r,
      "data-stretch": ye(i),
      __css: s.step,
      ...t,
      className: oe("chakra-step", t.className)
    }
  );
}), VQ = X(
  function(t, n) {
    const { status: r } = po(), o = Ko();
    return /* @__PURE__ */ b(
      z.p,
      {
        ref: n,
        "data-status": r,
        ...t,
        className: oe("chakra-step__description", t.className),
        __css: o.description
      }
    );
  }
);
function DH(e) {
  return /* @__PURE__ */ b(
    "svg",
    {
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0",
      viewBox: "0 0 20 20",
      "aria-hidden": "true",
      height: "1em",
      width: "1em",
      ...e,
      children: /* @__PURE__ */ b(
        "path",
        {
          fillRule: "evenodd",
          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function LQ(e) {
  const { status: t } = po(), n = Ko();
  return /* @__PURE__ */ b(
    It,
    {
      as: t === "complete" ? DH : void 0,
      __css: n.icon,
      ...e,
      className: oe("chakra-step__icon", e.className)
    }
  );
}
const zQ = X(
  function(t, n) {
    const { children: r, ...o } = t, { status: i, index: s } = po(), a = Ko();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        "data-status": i,
        __css: a.number,
        ...o,
        className: oe("chakra-step__number", t.className),
        children: r || s + 1
      }
    );
  }
);
function GQ(e) {
  const { complete: t, incomplete: n, active: r } = e, o = po();
  let i = null;
  switch (o.status) {
    case "complete":
      i = jt(t, o);
      break;
    case "incomplete":
      i = jt(n, o);
      break;
    case "active":
      i = jt(r, o);
      break;
  }
  return i ? /* @__PURE__ */ b(Vr, { children: i }) : null;
}
const WQ = X(
  function(t, n) {
    const { status: r } = po(), o = Ko();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        "data-status": r,
        ...t,
        __css: o.indicator,
        className: oe("chakra-step__indicator", t.className)
      }
    );
  }
), HQ = X(
  function(t, n) {
    const { orientation: r, status: o, isLast: i, showLastSeparator: s } = po(), a = Ko();
    return i && !s ? null : /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        role: "separator",
        "data-orientation": r,
        "data-status": o,
        __css: a.separator,
        ...t,
        className: oe("chakra-step__separator", t.className)
      }
    );
  }
), jQ = X(function(t, n) {
  const { status: r } = po(), o = Ko();
  return /* @__PURE__ */ b(
    z.h3,
    {
      ref: n,
      "data-status": r,
      ...t,
      __css: o.title,
      className: oe("chakra-step__title", t.className)
    }
  );
}), XQ = X(function(t, n) {
  const r = We("Stepper", t), {
    children: o,
    index: i,
    orientation: s = "horizontal",
    showLastSeparator: a = !1,
    ...c
  } = $e(t), l = yr.toArray(o), u = l.length;
  function d(f) {
    return f < i ? "complete" : f > i ? "incomplete" : "active";
  }
  return /* @__PURE__ */ b(
    z.div,
    {
      ref: n,
      "aria-label": "Progress",
      "data-orientation": s,
      ...c,
      __css: r.stepper,
      className: oe("chakra-stepper", t.className),
      children: /* @__PURE__ */ b(FH, { value: r, children: l.map((f, p) => /* @__PURE__ */ b(
        BH,
        {
          value: {
            index: p,
            status: d(p),
            orientation: s,
            showLastSeparator: a,
            count: u,
            isFirst: p === 0,
            isLast: p === u - 1
          },
          children: f
        },
        p
      )) })
    }
  );
});
function YQ(e = {}) {
  const { index: t = 0, count: n } = e, [r, o] = ue(t), i = typeof n == "number" ? n - 1 : 0, s = r / i;
  return {
    activeStep: r,
    setActiveStep: o,
    activeStepPercent: Number.isNaN(s) ? 0 : s,
    isActiveStep(a) {
      return a === r;
    },
    isCompleteStep(a) {
      return a < r;
    },
    isIncompleteStep(a) {
      return a > r;
    },
    getStatus(a) {
      return a < r ? "complete" : a > r ? "incomplete" : "active";
    },
    goToNext() {
      o((a) => typeof n == "number" ? Math.min(n, a + 1) : a + 1);
    },
    goToPrevious() {
      o((a) => Math.max(0, a - 1));
    }
  };
}
const $H = X(
  function(t, n) {
    const r = We("Switch", t), {
      spacing: o = "0.5rem",
      children: i,
      ...s
    } = $e(t), {
      getIndicatorProps: a,
      getInputProps: c,
      getCheckboxProps: l,
      getRootProps: u,
      getLabelProps: d
    } = Lx(s), f = be(
      () => ({
        display: "inline-block",
        position: "relative",
        verticalAlign: "middle",
        lineHeight: 0,
        ...r.container
      }),
      [r.container]
    ), p = be(
      () => ({
        display: "inline-flex",
        flexShrink: 0,
        justifyContent: "flex-start",
        boxSizing: "content-box",
        cursor: "pointer",
        ...r.track
      }),
      [r.track]
    ), m = be(
      () => ({
        userSelect: "none",
        marginStart: o,
        ...r.label
      }),
      [o, r.label]
    );
    return /* @__PURE__ */ Ae(
      z.label,
      {
        ...u(),
        className: oe("chakra-switch", t.className),
        __css: f,
        children: [
          /* @__PURE__ */ b("input", { className: "chakra-switch__input", ...c({}, n) }),
          /* @__PURE__ */ b(
            z.span,
            {
              ...l(),
              className: "chakra-switch__track",
              __css: p,
              children: /* @__PURE__ */ b(
                z.span,
                {
                  __css: r.thumb,
                  className: "chakra-switch__thumb",
                  ...a()
                }
              )
            }
          ),
          i && /* @__PURE__ */ b(
            z.span,
            {
              className: "chakra-switch__label",
              ...d(),
              __css: m,
              children: i
            }
          )
        ]
      }
    );
  }
);
$H.displayName = "Switch";
const [VH, qo] = De({
  name: "TableStylesContext",
  errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Table />" `
}), LH = X((e, t) => {
  const n = We("Table", e), { className: r, layout: o, ...i } = $e(e);
  return /* @__PURE__ */ b(VH, { value: n, children: /* @__PURE__ */ b(
    z.table,
    {
      ref: t,
      __css: { tableLayout: o, ...n.table },
      className: oe("chakra-table", r),
      ...i
    }
  ) });
});
LH.displayName = "Table";
const zH = X(
  (e, t) => {
    const { placement: n = "bottom", ...r } = e, o = qo();
    return /* @__PURE__ */ b(
      z.caption,
      {
        ...r,
        ref: t,
        __css: {
          ...o.caption,
          captionSide: n
        }
      }
    );
  }
);
zH.displayName = "TableCaption";
const ZQ = X(
  (e, t) => {
    const { overflow: n, overflowX: r, className: o, ...i } = e;
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: t,
        className: oe("chakra-table__container", o),
        ...i,
        __css: {
          display: "block",
          whiteSpace: "nowrap",
          WebkitOverflowScrolling: "touch",
          overflowX: n ?? r ?? "auto",
          overflowY: "hidden",
          maxWidth: "100%"
        }
      }
    );
  }
), UQ = X((e, t) => {
  const n = qo();
  return /* @__PURE__ */ b(z.tbody, { ...e, ref: t, __css: n.tbody });
}), JQ = X(
  ({ isNumeric: e, ...t }, n) => {
    const r = qo();
    return /* @__PURE__ */ b(
      z.td,
      {
        ...t,
        ref: n,
        __css: r.td,
        "data-is-numeric": e
      }
    );
  }
), KQ = X((e, t) => {
  const n = qo();
  return /* @__PURE__ */ b(z.tfoot, { ...e, ref: t, __css: n.tfoot });
}), qQ = X(
  ({ isNumeric: e, ...t }, n) => {
    const r = qo();
    return /* @__PURE__ */ b(
      z.th,
      {
        ...t,
        ref: n,
        __css: r.th,
        "data-is-numeric": e
      }
    );
  }
), QQ = X((e, t) => {
  const n = qo();
  return /* @__PURE__ */ b(z.thead, { ...e, ref: t, __css: n.thead });
}), eee = X((e, t) => {
  const n = qo();
  return /* @__PURE__ */ b(z.tr, { ...e, ref: t, __css: n.tr });
}), [
  GH,
  HI,
  WH,
  HH
] = du();
function jH(e) {
  const {
    defaultIndex: t,
    onChange: n,
    index: r,
    isManual: o,
    isLazy: i,
    lazyBehavior: s = "unmount",
    orientation: a = "horizontal",
    direction: c = "ltr",
    ...l
  } = e, [u, d] = ue(t ?? 0), [f, p] = co({
    defaultValue: t ?? 0,
    value: r,
    onChange: n
  });
  ge(() => {
    r != null && d(r);
  }, [r]);
  const m = WH(), h = Xt();
  return {
    id: `tabs-${e.id ?? h}`,
    selectedIndex: f,
    focusedIndex: u,
    setSelectedIndex: p,
    setFocusedIndex: d,
    isManual: o,
    isLazy: i,
    lazyBehavior: s,
    orientation: a,
    descendants: m,
    direction: c,
    htmlProps: l
  };
}
const [XH, Fa] = De({
  name: "TabsContext",
  errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
});
function YH(e) {
  const { focusedIndex: t, orientation: n, direction: r } = Fa(), o = HI(), i = R(
    (s) => {
      const a = () => {
        const y = o.nextEnabled(t);
        y && y.node?.focus();
      }, c = () => {
        const y = o.prevEnabled(t);
        y && y.node?.focus();
      }, l = () => {
        const y = o.firstEnabled();
        y && y.node?.focus();
      }, u = () => {
        const y = o.lastEnabled();
        y && y.node?.focus();
      }, d = n === "horizontal", f = n === "vertical", p = s.key, m = r === "ltr" ? "ArrowLeft" : "ArrowRight", h = r === "ltr" ? "ArrowRight" : "ArrowLeft", v = {
        [m]: () => d && c(),
        [h]: () => d && a(),
        ArrowDown: () => f && a(),
        ArrowUp: () => f && c(),
        Home: l,
        End: u
      }[p];
      v && (s.preventDefault(), v(s));
    },
    [o, t, n, r]
  );
  return {
    ...e,
    role: "tablist",
    "aria-orientation": n,
    onKeyDown: fe(e.onKeyDown, i)
  };
}
function ZH(e) {
  const { isDisabled: t = !1, isFocusable: n = !1, ...r } = e, { setSelectedIndex: o, isManual: i, id: s, setFocusedIndex: a, selectedIndex: c } = Fa(), { index: l, register: u } = HH({
    disabled: t && !n
  }), d = l === c, f = () => {
    o(l);
  }, p = () => {
    a(l), !i && !(t && n) && o(l);
  };
  return {
    ...XC({
      ...r,
      ref: Ge(u, e.ref),
      isDisabled: t,
      isFocusable: n,
      onClick: fe(e.onClick, f)
    }),
    id: jI(s, l),
    role: "tab",
    tabIndex: d ? 0 : -1,
    type: "button",
    "aria-selected": d,
    "aria-controls": XI(s, l),
    onFocus: t ? void 0 : fe(e.onFocus, p)
  };
}
const [UH, JH] = De({});
function KH(e) {
  const t = Fa(), { id: n, selectedIndex: r } = t, i = Hr(e.children).map(
    (s, a) => eh(
      UH,
      {
        key: s.key ?? a,
        value: {
          isSelected: a === r,
          id: XI(n, a),
          tabId: jI(n, a),
          selectedIndex: r
        }
      },
      s
    )
  );
  return { ...e, children: i };
}
function qH(e) {
  const { children: t, ...n } = e, { isLazy: r, lazyBehavior: o } = Fa(), { isSelected: i, id: s, tabId: a } = JH(), c = se(!1);
  i && (c.current = !0);
  const l = nh({
    wasSelected: c.current,
    isSelected: i,
    enabled: r,
    mode: o
  });
  return {
    // Puts the tabpanel in the page `Tab` sequence.
    tabIndex: 0,
    ...n,
    children: l ? t : null,
    role: "tabpanel",
    "aria-labelledby": a,
    hidden: !i,
    id: s
  };
}
function QH() {
  const e = Fa(), t = HI(), { selectedIndex: n, orientation: r } = e, o = r === "horizontal", i = r === "vertical", [s, a] = ue(() => {
    if (o)
      return { left: 0, width: 0 };
    if (i)
      return { top: 0, height: 0 };
  }), [c, l] = ue(!1);
  return Dn(() => {
    if (n == null)
      return;
    const u = t.item(n);
    if (u == null)
      return;
    o && a({ left: u.node.offsetLeft, width: u.node.offsetWidth }), i && a({ top: u.node.offsetTop, height: u.node.offsetHeight });
    const d = requestAnimationFrame(() => {
      l(!0);
    });
    return () => {
      d && cancelAnimationFrame(d);
    };
  }, [n, o, i, t]), {
    position: "absolute",
    transitionProperty: "left, right, top, bottom, height, width",
    transitionDuration: c ? "200ms" : "0ms",
    transitionTimingFunction: "cubic-bezier(0, 0, 0.2, 1)",
    ...s
  };
}
function jI(e, t) {
  return `${e}--tab-${t}`;
}
function XI(e, t) {
  return `${e}--tabpanel-${t}`;
}
const [ej, Da] = De({
  name: "TabsStylesContext",
  errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
}), tj = X(function(t, n) {
  const r = We("Tabs", t), { children: o, className: i, ...s } = $e(t), { htmlProps: a, descendants: c, ...l } = jH(s), u = be(() => l, [l]), { isFitted: d, ...f } = a, p = {
    position: "relative",
    ...r.root
  };
  return /* @__PURE__ */ b(GH, { value: c, children: /* @__PURE__ */ b(XH, { value: u, children: /* @__PURE__ */ b(ej, { value: r, children: /* @__PURE__ */ b(
    z.div,
    {
      className: oe("chakra-tabs", i),
      ref: n,
      ...f,
      __css: p,
      children: o
    }
  ) }) }) });
});
tj.displayName = "Tabs";
const YI = X(function(t, n) {
  const r = Da(), o = ZH({ ...t, ref: n }), i = {
    outline: "0",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    ...r.tab
  };
  return /* @__PURE__ */ b(
    z.button,
    {
      ...o,
      className: oe("chakra-tabs__tab", t.className),
      __css: i
    }
  );
});
YI.displayName = "Tab";
const nj = X(
  function(t, n) {
    const r = QH(), o = {
      ...t.style,
      ...r
    }, i = Da();
    return /* @__PURE__ */ b(
      z.div,
      {
        ref: n,
        ...t,
        className: oe("chakra-tabs__tab-indicator", t.className),
        style: o,
        __css: i.indicator
      }
    );
  }
);
nj.displayName = "TabIndicator";
const rj = X(
  function(t, n) {
    const r = YH({ ...t, ref: n }), o = Da(), i = {
      display: "flex",
      ...o.tablist
    };
    return /* @__PURE__ */ b(
      z.div,
      {
        ...r,
        className: oe("chakra-tabs__tablist", t.className),
        __css: i
      }
    );
  }
);
rj.displayName = "TabList";
const oj = X(
  function(t, n) {
    const r = qH({ ...t, ref: n }), o = Da();
    return /* @__PURE__ */ b(
      z.div,
      {
        outline: "0",
        ...r,
        className: oe("chakra-tabs__tab-panel", t.className),
        __css: o.tabpanel
      }
    );
  }
);
oj.displayName = "TabPanel";
const ij = X(
  function(t, n) {
    const r = KH(t), o = Da();
    return /* @__PURE__ */ b(
      z.div,
      {
        ...r,
        width: "100%",
        ref: n,
        className: oe("chakra-tabs__tab-panels", t.className),
        __css: o.tabpanels
      }
    );
  }
);
ij.displayName = "TabPanels";
const [sj, ZI] = De({
  name: "TagStylesContext",
  errorMessage: `useTagStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tag />" `
}), aj = X((e, t) => {
  const n = We("Tag", e), r = $e(e), o = {
    display: "inline-flex",
    verticalAlign: "top",
    alignItems: "center",
    maxWidth: "100%",
    ...n.container
  };
  return /* @__PURE__ */ b(sj, { value: n, children: /* @__PURE__ */ b(z.span, { ref: t, ...r, __css: o }) });
});
aj.displayName = "Tag";
const cj = X((e, t) => {
  const n = ZI();
  return /* @__PURE__ */ b(z.span, { ref: t, noOfLines: 1, ...e, __css: n.label });
});
cj.displayName = "TagLabel";
const lj = X((e, t) => /* @__PURE__ */ b(It, { ref: t, verticalAlign: "top", marginEnd: "0.5rem", ...e }));
lj.displayName = "TagLeftIcon";
const uj = X((e, t) => /* @__PURE__ */ b(It, { ref: t, verticalAlign: "top", marginStart: "0.5rem", ...e }));
uj.displayName = "TagRightIcon";
const UI = (e) => /* @__PURE__ */ b(It, { verticalAlign: "inherit", viewBox: "0 0 512 512", ...e, children: /* @__PURE__ */ b(
  "path",
  {
    fill: "currentColor",
    d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
  }
) });
UI.displayName = "TagCloseIcon";
const dj = X(
  (e, t) => {
    const { isDisabled: n, children: r, ...o } = e, s = {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      ...ZI().closeButton
    };
    return /* @__PURE__ */ b(
      z.button,
      {
        ref: t,
        "aria-label": "close",
        ...o,
        type: "button",
        disabled: n,
        __css: s,
        children: r || /* @__PURE__ */ b(UI, {})
      }
    );
  }
);
dj.displayName = "TagCloseButton";
const fj = ["h", "minH", "height", "minHeight"], JI = X((e, t) => {
  const n = Gt("Textarea", e), { className: r, rows: o, ...i } = $e(e), s = as(i), a = o ? ya(n, fj) : n;
  return /* @__PURE__ */ b(
    z.textarea,
    {
      ref: t,
      rows: o,
      ...s,
      className: oe("chakra-textarea", r),
      __css: a
    }
  );
});
JI.displayName = "Textarea";
function pj(e, t) {
  const n = e ?? "bottom";
  return {
    "top-start": { ltr: "top-left", rtl: "top-right" },
    "top-end": { ltr: "top-right", rtl: "top-left" },
    "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
    "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
  }[n]?.[t] ?? n;
}
function KI(e, t) {
  const n = (o) => ({
    ...t,
    ...o,
    position: pj(
      o?.position ?? t?.position,
      e
    )
  }), r = (o) => {
    const i = n(o), s = Sx(i);
    return ur.notify(s, i);
  };
  return r.update = (o, i) => {
    ur.update(o, n(i));
  }, r.promise = (o, i) => {
    const s = r({
      ...i.loading,
      status: "loading",
      duration: null
    });
    o.then(
      (a) => r.update(s, {
        status: "success",
        duration: 5e3,
        ...jt(i.success, a)
      })
    ).catch(
      (a) => r.update(s, {
        status: "error",
        duration: 5e3,
        ...jt(i.error, a)
      })
    );
  }, r.closeAll = ur.closeAll, r.close = ur.close, r.isActive = ur.isActive, r;
}
const hj = {
  duration: 5e3,
  variant: "solid"
}, pi = {
  theme: dh,
  colorMode: "light",
  toggleColorMode: () => {
  },
  setColorMode: () => {
  },
  defaultOptions: hj,
  forced: !1
};
function tee({
  theme: e = pi.theme,
  colorMode: t = pi.colorMode,
  toggleColorMode: n = pi.toggleColorMode,
  setColorMode: r = pi.setColorMode,
  defaultOptions: o = pi.defaultOptions,
  motionVariants: i,
  toastSpacing: s,
  component: a,
  forced: c
} = pi) {
  const l = {
    colorMode: t,
    setColorMode: r,
    toggleColorMode: n,
    forced: c
  };
  return {
    ToastContainer: () => /* @__PURE__ */ b(F1, { theme: e, children: /* @__PURE__ */ b(Pa.Provider, { value: l, children: /* @__PURE__ */ b(
      Cx,
      {
        defaultOptions: o,
        motionVariants: i,
        toastSpacing: s,
        component: a
      }
    ) }) }),
    toast: KI(e.direction, o)
  };
}
function nee(e) {
  const { theme: t } = fx(), n = X5();
  return be(
    () => KI(t.direction, {
      ...n,
      ...e
    }),
    [e, t.direction, n]
  );
}
const mj = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: { duration: 0.15, easings: "easeInOut" },
      scale: { duration: 0.2, easings: "easeInOut" }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: { easings: "easeOut", duration: 0.2 },
      scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
    }
  }
}, kp = (e) => e.current?.ownerDocument || document, Yc = (e) => e.current?.ownerDocument?.defaultView || window;
function gj(e = {}) {
  const {
    openDelay: t = 0,
    closeDelay: n = 0,
    closeOnClick: r = !0,
    closeOnMouseDown: o,
    closeOnScroll: i,
    closeOnPointerDown: s = o,
    closeOnEsc: a = !0,
    onOpen: c,
    onClose: l,
    placement: u,
    id: d,
    isOpen: f,
    defaultIsOpen: p,
    arrowSize: m = 10,
    arrowShadowColor: h,
    arrowPadding: g,
    modifiers: v,
    isDisabled: y,
    gutter: x,
    offset: S,
    direction: C,
    ...w
  } = e, { isOpen: I, onOpen: P, onClose: k } = Hl({
    isOpen: f,
    defaultIsOpen: p,
    onOpen: c,
    onClose: l
  }), { referenceRef: A, getPopperProps: N, getArrowInnerProps: B, getArrowProps: L } = Am({
    enabled: I,
    placement: u,
    arrowPadding: g,
    modifiers: v,
    gutter: x,
    offset: S,
    direction: C
  }), Z = Xt(), W = `tooltip-${d ?? Z}`, O = se(null), J = se(void 0), ee = R(() => {
    J.current && (clearTimeout(J.current), J.current = void 0);
  }, []), H = se(void 0), _ = R(() => {
    H.current && (clearTimeout(H.current), H.current = void 0);
  }, []), j = R(() => {
    _(), k();
  }, [k, _]), E = bj(O, j), M = R(() => {
    if (!y && !J.current) {
      I && E();
      const Y = Yc(O);
      J.current = Y.setTimeout(P, t);
    }
  }, [E, y, I, P, t]), F = R(() => {
    ee();
    const Y = Yc(O);
    H.current = Y.setTimeout(j, n);
  }, [n, j, ee]), G = R(() => {
    I && r && F();
  }, [r, F, I]), q = R(() => {
    I && s && F();
  }, [s, F, I]), te = R(
    (Y) => {
      I && Y.key === "Escape" && F();
    },
    [I, F]
  );
  Qr(
    () => kp(O),
    "keydown",
    a ? te : void 0
  ), Qr(
    () => {
      if (!i)
        return null;
      const Y = O.current;
      if (!Y)
        return null;
      const ce = z0(Y);
      return ce.localName === "body" ? Yc(O) : ce;
    },
    "scroll",
    () => {
      I && i && j();
    },
    { passive: !0, capture: !0 }
  ), ge(() => {
    y && (ee(), I && k());
  }, [y, I, k, ee]), ge(() => () => {
    ee(), _();
  }, [ee, _]), Qr(() => O.current, "pointerleave", F);
  const U = R(
    (Y = {}, ce = null) => ({
      ...Y,
      ref: Ge(O, ce, A),
      onPointerEnter: fe(Y.onPointerEnter, (Ce) => {
        Ce.pointerType !== "touch" && M();
      }),
      onClick: fe(Y.onClick, G),
      onPointerDown: fe(Y.onPointerDown, q),
      onFocus: fe(Y.onFocus, M),
      onBlur: fe(Y.onBlur, F),
      "aria-describedby": I ? W : void 0
    }),
    [
      M,
      F,
      q,
      I,
      W,
      G,
      A
    ]
  ), K = R(
    (Y = {}, ce = null) => N(
      {
        ...Y,
        style: {
          ...Y.style,
          [Dt.arrowSize.var]: m ? `${m}px` : void 0,
          [Dt.arrowShadowColor.var]: h
        }
      },
      ce
    ),
    [N, m, h]
  ), ae = R(
    (Y = {}, ce = null) => {
      const re = {
        ...Y.style,
        position: "relative",
        transformOrigin: Dt.transformOrigin.varRef
      };
      return {
        ref: ce,
        ...w,
        ...Y,
        id: W,
        role: "tooltip",
        style: re
      };
    },
    [w, W]
  );
  return {
    isOpen: I,
    show: M,
    hide: F,
    getTriggerProps: U,
    getTooltipProps: ae,
    getTooltipPositionerProps: K,
    getArrowProps: L,
    getArrowInnerProps: B
  };
}
const af = "chakra-ui:close-tooltip";
function bj(e, t) {
  return ge(() => {
    const n = kp(e);
    return n.addEventListener(af, t), () => n.removeEventListener(af, t);
  }, [t, e]), () => {
    const n = kp(e), r = Yc(e);
    n.dispatchEvent(new r.CustomEvent(af));
  };
}
const vj = z(Jt.div), qI = X((e, t) => {
  const n = Gt("Tooltip", e), r = $e(e), o = bn(), {
    children: i,
    label: s,
    shouldWrapChildren: a,
    "aria-label": c,
    hasArrow: l,
    bg: u,
    portalProps: d,
    background: f,
    backgroundColor: p,
    bgColor: m,
    motionProps: h,
    animatePresenceProps: g,
    ...v
  } = r, y = f ?? p ?? u ?? m;
  if (y) {
    n.bg = y;
    const A = oE(o, "colors", y);
    n[Dt.arrowBg.var] = A;
  }
  const x = gj({ ...v, direction: o.direction }), S = !ao(i) || a;
  let C;
  if (S)
    C = /* @__PURE__ */ b(
      z.span,
      {
        display: "inline-block",
        tabIndex: 0,
        ...x.getTriggerProps(),
        children: i
      }
    );
  else {
    const A = yr.only(i);
    C = Lt(
      A,
      x.getTriggerProps(A.props, _m(A))
    );
  }
  const w = !!c, I = x.getTooltipProps({}, t), P = w ? ya(I, ["role", "id"]) : I, k = V0(I, ["role", "id"]);
  return s ? /* @__PURE__ */ Ae(Vr, { children: [
    C,
    /* @__PURE__ */ b(Sr, { ...g, children: x.isOpen && /* @__PURE__ */ b(Yo, { ...d, children: /* @__PURE__ */ b(
      z.div,
      {
        ...x.getTooltipPositionerProps(),
        __css: {
          zIndex: n.zIndex,
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ Ae(
          vj,
          {
            variants: mj,
            initial: "exit",
            animate: "enter",
            exit: "exit",
            ...h,
            ...P,
            __css: n,
            children: [
              s,
              w && /* @__PURE__ */ b(z.span, { srOnly: !0, ...k, children: c }),
              l && /* @__PURE__ */ b(
                z.div,
                {
                  "data-popper-arrow": !0,
                  className: "chakra-tooltip__arrow-wrapper",
                  children: /* @__PURE__ */ b(
                    z.div,
                    {
                      "data-popper-arrow-inner": !0,
                      className: "chakra-tooltip__arrow",
                      __css: { bg: n.bg }
                    }
                  )
                }
              )
            ]
          }
        )
      }
    ) }) })
  ] }) : /* @__PURE__ */ b(Vr, { children: i });
});
qI.displayName = "Tooltip";
const yj = X(
  function(t, n) {
    const r = Gt("Heading", t), { className: o, ...i } = $e(t);
    return /* @__PURE__ */ b(
      z.h2,
      {
        ref: n,
        className: oe("chakra-heading", t.className),
        ...i,
        __css: r
      }
    );
  }
);
yj.displayName = "Heading";
const To = X(function(t, n) {
  const r = Gt("Text", t), { className: o, align: i, decoration: s, casing: a, ...c } = $e(t), l = is({
    textAlign: t.align,
    textDecoration: t.decoration,
    textTransform: t.casing
  });
  return /* @__PURE__ */ b(
    z.p,
    {
      ref: n,
      className: oe("chakra-text", t.className),
      ...l,
      ...c,
      __css: r
    }
  );
});
To.displayName = "Text";
const Sj = z("span", {
  baseStyle: pu
});
Sj.displayName = "VisuallyHidden";
const xj = z("input", {
  baseStyle: pu
});
xj.displayName = "VisuallyHiddenInput";
const Cj = X(function(t, n) {
  const {
    spacing: r = "0.5rem",
    spacingX: o,
    spacingY: i,
    children: s,
    justify: a,
    direction: c,
    align: l,
    className: u,
    shouldWrapChildren: d,
    ...f
  } = t, p = be(
    () => d ? yr.map(s, (m, h) => /* @__PURE__ */ b(QI, { children: m }, h)) : s,
    [s, d]
  );
  return /* @__PURE__ */ b(z.div, { ref: n, className: oe("chakra-wrap", u), ...f, children: /* @__PURE__ */ b(
    z.ul,
    {
      className: "chakra-wrap__list",
      __css: {
        display: "flex",
        flexWrap: "wrap",
        justifyContent: a,
        alignItems: l,
        flexDirection: c,
        listStyleType: "none",
        gap: r,
        columnGap: o,
        rowGap: i,
        padding: "0"
      },
      children: p
    }
  ) });
});
Cj.displayName = "Wrap";
const QI = X(
  function(t, n) {
    const { className: r, ...o } = t;
    return /* @__PURE__ */ b(
      z.li,
      {
        ref: n,
        __css: { display: "flex", alignItems: "flex-start" },
        className: oe("chakra-wrap__listitem", r),
        ...o
      }
    );
  }
);
QI.displayName = "WrapItem";
function Ij(e, t) {
  return `${e} returned \`undefined\`. Seems you forgot to wrap component within ${t}`;
}
function ew(e = {}) {
  const {
    name: t,
    strict: n = !0,
    hookName: r = "useContext",
    providerName: o = "Provider",
    errorMessage: i,
    defaultValue: s
  } = e, a = an(s);
  a.displayName = t;
  function c() {
    var l;
    const u = at(a);
    if (!u && n) {
      const d = new Error(
        i ?? Ij(r, o)
      );
      throw d.name = "ContextError", (l = Error.captureStackTrace) == null || l.call(Error, d, c), d;
    }
    return u;
  }
  return [a.Provider, c, a];
}
var [ree, wj] = ew({
  strict: !1,
  name: "PortalManagerContext"
}), Ap = globalThis?.document ? os : ge, [tw, Pj] = ew({
  strict: !1,
  name: "PortalContext"
}), Nm = "chakra-portal", kj = ".chakra-portal", Aj = (e) => /* @__PURE__ */ b(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: e.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: e.children
  }
), Tj = (e) => {
  const { appendToParentPortal: t, children: n } = e, [r, o] = ue(null), i = se(null), [, s] = ue({});
  ge(() => s({}), []);
  const a = Pj(), c = wj();
  Ap(() => {
    if (!r)
      return;
    const u = r.ownerDocument, d = t ? a ?? u.body : u.body;
    if (!d)
      return;
    i.current = u.createElement("div"), i.current.className = Nm, d.appendChild(i.current), s({});
    const f = i.current;
    return () => {
      d.contains(f) && d.removeChild(f);
    };
  }, [r]);
  const l = c?.zIndex ? /* @__PURE__ */ b(Aj, { zIndex: c?.zIndex, children: n }) : n;
  return i.current ? va(
    /* @__PURE__ */ b(tw, { value: i.current, children: l }),
    i.current
  ) : /* @__PURE__ */ b(
    "span",
    {
      ref: (u) => {
        u && o(u);
      }
    }
  );
}, Ej = (e) => {
  const { children: t, containerRef: n, appendToParentPortal: r } = e, o = n.current, i = o ?? (typeof window < "u" ? document.body : void 0), s = be(() => {
    const c = o?.ownerDocument.createElement("div");
    return c && (c.className = Nm), c;
  }, [o]), [, a] = ue({});
  return Ap(() => a({}), []), Ap(() => {
    if (!(!s || !i))
      return i.appendChild(s), () => {
        i.removeChild(s);
      };
  }, [s, i]), i && s ? va(
    /* @__PURE__ */ b(tw, { value: r ? s : null, children: t }),
    s
  ) : null;
};
function wu(e) {
  const t = {
    appendToParentPortal: !0,
    ...e
  }, { containerRef: n, ...r } = t;
  return n ? /* @__PURE__ */ b(Ej, { containerRef: n, ...r }) : /* @__PURE__ */ b(Tj, { ...r });
}
wu.className = Nm;
wu.selector = kj;
wu.displayName = "Portal";
function Rj() {
  const e = at(
    Lo
  );
  if (!e)
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  return e;
}
var nw = an({});
nw.displayName = "ColorModeContext";
function rw() {
  const e = at(nw);
  if (e === void 0)
    throw new Error("useColorMode must be used within a ColorModeProvider");
  return e;
}
function _j() {
  const e = rw(), t = Rj();
  return { ...e, theme: t };
}
var Oj = (...e) => e.filter(Boolean).join(" ");
function Fo(e) {
  const t = typeof e;
  return e != null && (t === "object" || t === "function") && !Array.isArray(e);
}
function Eo(e, ...t) {
  return Nj(e) ? e(...t) : e;
}
var Nj = (e) => typeof e == "function", Mj = (e) => /!(important)?$/.test(e), gy = (e) => typeof e == "string" ? e.replace(/!(important)?$/, "").trim() : e, Bj = (e, t) => (n) => {
  const r = String(t), o = Mj(r), i = gy(r), s = e ? `${e}.${i}` : i;
  let a = Fo(n.__cssMap) && s in n.__cssMap ? n.__cssMap[s].varRef : t;
  return a = gy(a), o ? `${a} !important` : a;
};
function Mm(e) {
  const { scale: t, transform: n, compose: r } = e;
  return (i, s) => {
    var a;
    const c = Bj(t, i)(s);
    let l = (a = n?.(c, s)) != null ? a : c;
    return r && (l = r(l, s)), l;
  };
}
var hc = (...e) => (t) => e.reduce((n, r) => r(n), t);
function Nn(e, t) {
  return (n) => {
    const r = { property: n, scale: e };
    return r.transform = Mm({
      scale: e,
      transform: t
    }), r;
  };
}
var Fj = ({ rtl: e, ltr: t }) => (n) => n.direction === "rtl" ? e : t;
function Dj(e) {
  const { property: t, scale: n, transform: r } = e;
  return {
    scale: n,
    property: Fj(t),
    transform: n ? Mm({
      scale: n,
      compose: r
    }) : r
  };
}
var ow = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function $j() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...ow
  ].join(" ");
}
function Vj() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...ow
  ].join(" ");
}
var Lj = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
}, zj = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function Gj(e) {
  return {
    "--chakra-ring-offset-shadow": "var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)",
    "--chakra-ring-shadow": "var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)",
    "--chakra-ring-width": e,
    boxShadow: [
      "var(--chakra-ring-offset-shadow)",
      "var(--chakra-ring-shadow)",
      "var(--chakra-shadow, 0 0 #0000)"
    ].join(", ")
  };
}
var Wj = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
}, Tp = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
}, Hj = new Set(Object.values(Tp)), Ep = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]), jj = (e) => e.trim();
function Xj(e, t) {
  if (e == null || Ep.has(e))
    return e;
  if (!(Rp(e) || Ep.has(e)))
    return `url('${e}')`;
  const o = /(^[a-z-A-Z]+)\((.*)\)/g.exec(e), i = o?.[1], s = o?.[2];
  if (!i || !s)
    return e;
  const a = i.includes("-gradient") ? i : `${i}-gradient`, [c, ...l] = s.split(",").map(jj).filter(Boolean);
  if (l?.length === 0)
    return e;
  const u = c in Tp ? Tp[c] : c;
  l.unshift(u);
  const d = l.map((f) => {
    if (Hj.has(f))
      return f;
    const p = f.indexOf(" "), [m, h] = p !== -1 ? [f.substr(0, p), f.substr(p + 1)] : [f], g = Rp(h) ? h : h && h.split(" "), v = `colors.${m}`, y = v in t.__cssMap ? t.__cssMap[v].varRef : m;
    return g ? [
      y,
      ...Array.isArray(g) ? g : [g]
    ].join(" ") : y;
  });
  return `${a}(${d.join(", ")})`;
}
var Rp = (e) => typeof e == "string" && e.includes("(") && e.includes(")"), Yj = (e, t) => Xj(e, t ?? {});
function Zj(e) {
  return /^var\(--.+\)$/.test(e);
}
var Uj = (e) => {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}, ir = (e) => (t) => `${e}(${t})`, je = {
  filter(e) {
    return e !== "auto" ? e : Lj;
  },
  backdropFilter(e) {
    return e !== "auto" ? e : zj;
  },
  ring(e) {
    return Gj(je.px(e));
  },
  bgClip(e) {
    return e === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: e };
  },
  transform(e) {
    return e === "auto" ? $j() : e === "auto-gpu" ? Vj() : e;
  },
  vh(e) {
    return e === "$100vh" ? "var(--chakra-vh)" : e;
  },
  px(e) {
    if (e == null)
      return e;
    const { unitless: t } = Uj(e);
    return t || typeof e == "number" ? `${e}px` : e;
  },
  fraction(e) {
    return typeof e != "number" || e > 1 ? e : `${e * 100}%`;
  },
  float(e, t) {
    const n = { left: "right", right: "left" };
    return t.direction === "rtl" ? n[e] : e;
  },
  degree(e) {
    if (Zj(e) || e == null)
      return e;
    const t = typeof e == "string" && !e.endsWith("deg");
    return typeof e == "number" || t ? `${e}deg` : e;
  },
  gradient: Yj,
  blur: ir("blur"),
  opacity: ir("opacity"),
  brightness: ir("brightness"),
  contrast: ir("contrast"),
  dropShadow: ir("drop-shadow"),
  grayscale: ir("grayscale"),
  hueRotate: (e) => ir("hue-rotate")(je.degree(e)),
  invert: ir("invert"),
  saturate: ir("saturate"),
  sepia: ir("sepia"),
  bgImage(e) {
    return e == null || Rp(e) || Ep.has(e) ? e : `url(${e})`;
  },
  outline(e) {
    const t = String(e) === "0" || String(e) === "none";
    return e !== null && t ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: e };
  },
  flexDirection(e) {
    var t;
    const { space: n, divide: r } = (t = Wj[e]) != null ? t : {}, o = { flexDirection: e };
    return n && (o[n] = 1), r && (o[r] = 1), o;
  }
}, $ = {
  borderWidths: Nn("borderWidths"),
  borderStyles: Nn("borderStyles"),
  colors: Nn("colors"),
  borders: Nn("borders"),
  gradients: Nn("gradients", je.gradient),
  radii: Nn("radii", je.px),
  space: Nn("space", hc(je.vh, je.px)),
  spaceT: Nn("space", hc(je.vh, je.px)),
  degreeT(e) {
    return { property: e, transform: je.degree };
  },
  prop(e, t, n) {
    return {
      property: e,
      scale: t,
      ...t && {
        transform: Mm({ scale: t, transform: n })
      }
    };
  },
  propT(e, t) {
    return { property: e, transform: t };
  },
  sizes: Nn("sizes", hc(je.vh, je.px)),
  sizesT: Nn("sizes", hc(je.vh, je.fraction)),
  shadows: Nn("shadows"),
  logical: Dj,
  blur: Nn("blur", je.blur)
}, Zc = {
  background: $.colors("background"),
  backgroundColor: $.colors("backgroundColor"),
  backgroundImage: $.gradients("backgroundImage"),
  backgroundSize: !0,
  backgroundPosition: !0,
  backgroundRepeat: !0,
  backgroundAttachment: !0,
  backgroundClip: { transform: je.bgClip },
  bgSize: $.prop("backgroundSize"),
  bgPosition: $.prop("backgroundPosition"),
  bg: $.colors("background"),
  bgColor: $.colors("backgroundColor"),
  bgPos: $.prop("backgroundPosition"),
  bgRepeat: $.prop("backgroundRepeat"),
  bgAttachment: $.prop("backgroundAttachment"),
  bgGradient: $.gradients("backgroundImage"),
  bgClip: { transform: je.bgClip }
};
Object.assign(Zc, {
  bgImage: Zc.backgroundImage,
  bgImg: Zc.backgroundImage
});
var Qe = {
  border: $.borders("border"),
  borderWidth: $.borderWidths("borderWidth"),
  borderStyle: $.borderStyles("borderStyle"),
  borderColor: $.colors("borderColor"),
  borderRadius: $.radii("borderRadius"),
  borderTop: $.borders("borderTop"),
  borderBlockStart: $.borders("borderBlockStart"),
  borderTopLeftRadius: $.radii("borderTopLeftRadius"),
  borderStartStartRadius: $.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: $.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: $.radii("borderTopRightRadius"),
  borderStartEndRadius: $.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: $.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: $.borders("borderRight"),
  borderInlineEnd: $.borders("borderInlineEnd"),
  borderBottom: $.borders("borderBottom"),
  borderBlockEnd: $.borders("borderBlockEnd"),
  borderBottomLeftRadius: $.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: $.radii("borderBottomRightRadius"),
  borderLeft: $.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: $.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: $.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: $.borders(["borderLeft", "borderRight"]),
  borderInline: $.borders("borderInline"),
  borderY: $.borders(["borderTop", "borderBottom"]),
  borderBlock: $.borders("borderBlock"),
  borderTopWidth: $.borderWidths("borderTopWidth"),
  borderBlockStartWidth: $.borderWidths("borderBlockStartWidth"),
  borderTopColor: $.colors("borderTopColor"),
  borderBlockStartColor: $.colors("borderBlockStartColor"),
  borderTopStyle: $.borderStyles("borderTopStyle"),
  borderBlockStartStyle: $.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: $.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: $.borderWidths("borderBlockEndWidth"),
  borderBottomColor: $.colors("borderBottomColor"),
  borderBlockEndColor: $.colors("borderBlockEndColor"),
  borderBottomStyle: $.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: $.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: $.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: $.borderWidths("borderInlineStartWidth"),
  borderLeftColor: $.colors("borderLeftColor"),
  borderInlineStartColor: $.colors("borderInlineStartColor"),
  borderLeftStyle: $.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: $.borderStyles("borderInlineStartStyle"),
  borderRightWidth: $.borderWidths("borderRightWidth"),
  borderInlineEndWidth: $.borderWidths("borderInlineEndWidth"),
  borderRightColor: $.colors("borderRightColor"),
  borderInlineEndColor: $.colors("borderInlineEndColor"),
  borderRightStyle: $.borderStyles("borderRightStyle"),
  borderInlineEndStyle: $.borderStyles("borderInlineEndStyle"),
  borderTopRadius: $.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: $.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: $.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: $.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(Qe, {
  rounded: Qe.borderRadius,
  roundedTop: Qe.borderTopRadius,
  roundedTopLeft: Qe.borderTopLeftRadius,
  roundedTopRight: Qe.borderTopRightRadius,
  roundedTopStart: Qe.borderStartStartRadius,
  roundedTopEnd: Qe.borderStartEndRadius,
  roundedBottom: Qe.borderBottomRadius,
  roundedBottomLeft: Qe.borderBottomLeftRadius,
  roundedBottomRight: Qe.borderBottomRightRadius,
  roundedBottomStart: Qe.borderEndStartRadius,
  roundedBottomEnd: Qe.borderEndEndRadius,
  roundedLeft: Qe.borderLeftRadius,
  roundedRight: Qe.borderRightRadius,
  roundedStart: Qe.borderInlineStartRadius,
  roundedEnd: Qe.borderInlineEndRadius,
  borderStart: Qe.borderInlineStart,
  borderEnd: Qe.borderInlineEnd,
  borderTopStartRadius: Qe.borderStartStartRadius,
  borderTopEndRadius: Qe.borderStartEndRadius,
  borderBottomStartRadius: Qe.borderEndStartRadius,
  borderBottomEndRadius: Qe.borderEndEndRadius,
  borderStartRadius: Qe.borderInlineStartRadius,
  borderEndRadius: Qe.borderInlineEndRadius,
  borderStartWidth: Qe.borderInlineStartWidth,
  borderEndWidth: Qe.borderInlineEndWidth,
  borderStartColor: Qe.borderInlineStartColor,
  borderEndColor: Qe.borderInlineEndColor,
  borderStartStyle: Qe.borderInlineStartStyle,
  borderEndStyle: Qe.borderInlineEndStyle
});
var Jj = {
  color: $.colors("color"),
  textColor: $.colors("color"),
  fill: $.colors("fill"),
  stroke: $.colors("stroke")
}, _p = {
  boxShadow: $.shadows("boxShadow"),
  mixBlendMode: !0,
  blendMode: $.prop("mixBlendMode"),
  backgroundBlendMode: !0,
  bgBlendMode: $.prop("backgroundBlendMode"),
  opacity: !0
};
Object.assign(_p, {
  shadow: _p.boxShadow
});
var Kj = {
  filter: { transform: je.filter },
  blur: $.blur("--chakra-blur"),
  brightness: $.propT("--chakra-brightness", je.brightness),
  contrast: $.propT("--chakra-contrast", je.contrast),
  hueRotate: $.propT("--chakra-hue-rotate", je.hueRotate),
  invert: $.propT("--chakra-invert", je.invert),
  saturate: $.propT("--chakra-saturate", je.saturate),
  dropShadow: $.propT("--chakra-drop-shadow", je.dropShadow),
  backdropFilter: { transform: je.backdropFilter },
  backdropBlur: $.blur("--chakra-backdrop-blur"),
  backdropBrightness: $.propT(
    "--chakra-backdrop-brightness",
    je.brightness
  ),
  backdropContrast: $.propT("--chakra-backdrop-contrast", je.contrast),
  backdropHueRotate: $.propT(
    "--chakra-backdrop-hue-rotate",
    je.hueRotate
  ),
  backdropInvert: $.propT("--chakra-backdrop-invert", je.invert),
  backdropSaturate: $.propT("--chakra-backdrop-saturate", je.saturate)
}, xl = {
  alignItems: !0,
  alignContent: !0,
  justifyItems: !0,
  justifyContent: !0,
  flexWrap: !0,
  flexDirection: { transform: je.flexDirection },
  flex: !0,
  flexFlow: !0,
  flexGrow: !0,
  flexShrink: !0,
  flexBasis: $.sizes("flexBasis"),
  justifySelf: !0,
  alignSelf: !0,
  order: !0,
  placeItems: !0,
  placeContent: !0,
  placeSelf: !0,
  gap: $.space("gap"),
  rowGap: $.space("rowGap"),
  columnGap: $.space("columnGap")
};
Object.assign(xl, {
  flexDir: xl.flexDirection
});
var iw = {
  gridGap: $.space("gridGap"),
  gridColumnGap: $.space("gridColumnGap"),
  gridRowGap: $.space("gridRowGap"),
  gridColumn: !0,
  gridRow: !0,
  gridAutoFlow: !0,
  gridAutoColumns: !0,
  gridColumnStart: !0,
  gridColumnEnd: !0,
  gridRowStart: !0,
  gridRowEnd: !0,
  gridAutoRows: !0,
  gridTemplate: !0,
  gridTemplateColumns: !0,
  gridTemplateRows: !0,
  gridTemplateAreas: !0,
  gridArea: !0
}, qj = {
  appearance: !0,
  cursor: !0,
  resize: !0,
  userSelect: !0,
  pointerEvents: !0,
  outline: { transform: je.outline },
  outlineOffset: !0,
  outlineColor: $.colors("outlineColor")
}, Fn = {
  width: $.sizesT("width"),
  inlineSize: $.sizesT("inlineSize"),
  height: $.sizes("height"),
  blockSize: $.sizes("blockSize"),
  boxSize: $.sizes(["width", "height"]),
  minWidth: $.sizes("minWidth"),
  minInlineSize: $.sizes("minInlineSize"),
  minHeight: $.sizes("minHeight"),
  minBlockSize: $.sizes("minBlockSize"),
  maxWidth: $.sizes("maxWidth"),
  maxInlineSize: $.sizes("maxInlineSize"),
  maxHeight: $.sizes("maxHeight"),
  maxBlockSize: $.sizes("maxBlockSize"),
  overflow: !0,
  overflowX: !0,
  overflowY: !0,
  overscrollBehavior: !0,
  overscrollBehaviorX: !0,
  overscrollBehaviorY: !0,
  display: !0,
  aspectRatio: !0,
  hideFrom: {
    scale: "breakpoints",
    transform: (e, t) => {
      var n, r, o;
      return { [`@media screen and (min-width: ${(o = (r = (n = t.__breakpoints) == null ? void 0 : n.get(e)) == null ? void 0 : r.minW) != null ? o : e})`]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (e, t) => {
      var n, r, o;
      return { [`@media screen and (max-width: ${(o = (r = (n = t.__breakpoints) == null ? void 0 : n.get(e)) == null ? void 0 : r._minW) != null ? o : e})`]: { display: "none" } };
    }
  },
  verticalAlign: !0,
  boxSizing: !0,
  boxDecorationBreak: !0,
  float: $.propT("float", je.float),
  objectFit: !0,
  objectPosition: !0,
  visibility: !0,
  isolation: !0
};
Object.assign(Fn, {
  w: Fn.width,
  h: Fn.height,
  minW: Fn.minWidth,
  maxW: Fn.maxWidth,
  minH: Fn.minHeight,
  maxH: Fn.maxHeight,
  overscroll: Fn.overscrollBehavior,
  overscrollX: Fn.overscrollBehaviorX,
  overscrollY: Fn.overscrollBehaviorY
});
var Qj = {
  listStyleType: !0,
  listStylePosition: !0,
  listStylePos: $.prop("listStylePosition"),
  listStyleImage: !0,
  listStyleImg: $.prop("listStyleImage")
};
function eX(e, t, n, r) {
  const o = typeof t == "string" ? t.split(".") : [t];
  for (r = 0; r < o.length && e; r += 1)
    e = e[o[r]];
  return e === void 0 ? n : e;
}
var tX = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, o, i, s) => {
    if (typeof r > "u")
      return e(r, o, i);
    t.has(r) || t.set(r, /* @__PURE__ */ new Map());
    const a = t.get(r);
    if (a.has(o))
      return a.get(o);
    const c = e(r, o, i, s);
    return a.set(o, c), c;
  };
}, nX = tX(eX), rX = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
}, oX = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
}, cf = (e, t, n) => {
  const r = {}, o = nX(e, t, {});
  for (const i in o)
    i in n && n[i] != null || (r[i] = o[i]);
  return r;
}, iX = {
  srOnly: {
    transform(e) {
      return e === !0 ? rX : e === "focusable" ? oX : {};
    }
  },
  layerStyle: {
    processResult: !0,
    transform: (e, t, n) => cf(t, `layerStyles.${e}`, n)
  },
  textStyle: {
    processResult: !0,
    transform: (e, t, n) => cf(t, `textStyles.${e}`, n)
  },
  apply: {
    processResult: !0,
    transform: (e, t, n) => cf(t, e, n)
  }
}, Js = {
  position: !0,
  pos: $.prop("position"),
  zIndex: $.prop("zIndex", "zIndices"),
  inset: $.spaceT("inset"),
  insetX: $.spaceT(["left", "right"]),
  insetInline: $.spaceT("insetInline"),
  insetY: $.spaceT(["top", "bottom"]),
  insetBlock: $.spaceT("insetBlock"),
  top: $.spaceT("top"),
  insetBlockStart: $.spaceT("insetBlockStart"),
  bottom: $.spaceT("bottom"),
  insetBlockEnd: $.spaceT("insetBlockEnd"),
  left: $.spaceT("left"),
  insetInlineStart: $.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: $.spaceT("right"),
  insetInlineEnd: $.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(Js, {
  insetStart: Js.insetInlineStart,
  insetEnd: Js.insetInlineEnd
});
var sX = {
  ring: { transform: je.ring },
  ringColor: $.colors("--chakra-ring-color"),
  ringOffset: $.prop("--chakra-ring-offset-width"),
  ringOffsetColor: $.colors("--chakra-ring-offset-color"),
  ringInset: $.prop("--chakra-ring-inset")
}, gt = {
  margin: $.spaceT("margin"),
  marginTop: $.spaceT("marginTop"),
  marginBlockStart: $.spaceT("marginBlockStart"),
  marginRight: $.spaceT("marginRight"),
  marginInlineEnd: $.spaceT("marginInlineEnd"),
  marginBottom: $.spaceT("marginBottom"),
  marginBlockEnd: $.spaceT("marginBlockEnd"),
  marginLeft: $.spaceT("marginLeft"),
  marginInlineStart: $.spaceT("marginInlineStart"),
  marginX: $.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: $.spaceT("marginInline"),
  marginY: $.spaceT(["marginTop", "marginBottom"]),
  marginBlock: $.spaceT("marginBlock"),
  padding: $.space("padding"),
  paddingTop: $.space("paddingTop"),
  paddingBlockStart: $.space("paddingBlockStart"),
  paddingRight: $.space("paddingRight"),
  paddingBottom: $.space("paddingBottom"),
  paddingBlockEnd: $.space("paddingBlockEnd"),
  paddingLeft: $.space("paddingLeft"),
  paddingInlineStart: $.space("paddingInlineStart"),
  paddingInlineEnd: $.space("paddingInlineEnd"),
  paddingX: $.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: $.space("paddingInline"),
  paddingY: $.space(["paddingTop", "paddingBottom"]),
  paddingBlock: $.space("paddingBlock")
};
Object.assign(gt, {
  m: gt.margin,
  mt: gt.marginTop,
  mr: gt.marginRight,
  me: gt.marginInlineEnd,
  marginEnd: gt.marginInlineEnd,
  mb: gt.marginBottom,
  ml: gt.marginLeft,
  ms: gt.marginInlineStart,
  marginStart: gt.marginInlineStart,
  mx: gt.marginX,
  my: gt.marginY,
  p: gt.padding,
  pt: gt.paddingTop,
  py: gt.paddingY,
  px: gt.paddingX,
  pb: gt.paddingBottom,
  pl: gt.paddingLeft,
  ps: gt.paddingInlineStart,
  paddingStart: gt.paddingInlineStart,
  pr: gt.paddingRight,
  pe: gt.paddingInlineEnd,
  paddingEnd: gt.paddingInlineEnd
});
var aX = {
  textDecorationColor: $.colors("textDecorationColor"),
  textDecoration: !0,
  textDecor: { property: "textDecoration" },
  textDecorationLine: !0,
  textDecorationStyle: !0,
  textDecorationThickness: !0,
  textUnderlineOffset: !0,
  textShadow: $.shadows("textShadow")
}, cX = {
  clipPath: !0,
  transform: $.propT("transform", je.transform),
  transformOrigin: !0,
  translateX: $.spaceT("--chakra-translate-x"),
  translateY: $.spaceT("--chakra-translate-y"),
  skewX: $.degreeT("--chakra-skew-x"),
  skewY: $.degreeT("--chakra-skew-y"),
  scaleX: $.prop("--chakra-scale-x"),
  scaleY: $.prop("--chakra-scale-y"),
  scale: $.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: $.degreeT("--chakra-rotate")
}, lX = {
  transition: !0,
  transitionDelay: !0,
  animation: !0,
  willChange: !0,
  transitionDuration: $.prop("transitionDuration", "transition.duration"),
  transitionProperty: $.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: $.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
}, uX = {
  fontFamily: $.prop("fontFamily", "fonts"),
  fontSize: $.prop("fontSize", "fontSizes", je.px),
  fontWeight: $.prop("fontWeight", "fontWeights"),
  lineHeight: $.prop("lineHeight", "lineHeights"),
  letterSpacing: $.prop("letterSpacing", "letterSpacings"),
  textAlign: !0,
  fontStyle: !0,
  textIndent: !0,
  wordBreak: !0,
  overflowWrap: !0,
  textOverflow: !0,
  textTransform: !0,
  whiteSpace: !0,
  isTruncated: {
    transform(e) {
      if (e === !0)
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
}, dX = {
  scrollBehavior: !0,
  scrollSnapAlign: !0,
  scrollSnapStop: !0,
  scrollSnapType: !0,
  // scroll margin
  scrollMargin: $.spaceT("scrollMargin"),
  scrollMarginTop: $.spaceT("scrollMarginTop"),
  scrollMarginBottom: $.spaceT("scrollMarginBottom"),
  scrollMarginLeft: $.spaceT("scrollMarginLeft"),
  scrollMarginRight: $.spaceT("scrollMarginRight"),
  scrollMarginX: $.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: $.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: $.spaceT("scrollPadding"),
  scrollPaddingTop: $.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: $.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: $.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: $.spaceT("scrollPaddingRight"),
  scrollPaddingX: $.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: $.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
function sw(e) {
  return Fo(e) && e.reference ? e.reference : String(e);
}
var Pu = (e, ...t) => t.map(sw).join(` ${e} `).replace(/calc/g, ""), by = (...e) => `calc(${Pu("+", ...e)})`, vy = (...e) => `calc(${Pu("-", ...e)})`, Op = (...e) => `calc(${Pu("*", ...e)})`, yy = (...e) => `calc(${Pu("/", ...e)})`, Sy = (e) => {
  const t = sw(e);
  return t != null && !Number.isNaN(parseFloat(t)) ? String(t).startsWith("-") ? String(t).slice(1) : `-${t}` : Op(t, -1);
}, Cs = Object.assign(
  (e) => ({
    add: (...t) => Cs(by(e, ...t)),
    subtract: (...t) => Cs(vy(e, ...t)),
    multiply: (...t) => Cs(Op(e, ...t)),
    divide: (...t) => Cs(yy(e, ...t)),
    negate: () => Cs(Sy(e)),
    toString: () => e.toString()
  }),
  {
    add: by,
    subtract: vy,
    multiply: Op,
    divide: yy,
    negate: Sy
  }
);
function fX(e) {
  const t = parseFloat(e.toString()), n = e.toString().replace(String(t), "");
  return { unitless: !n, value: t, unit: n };
}
function xy(e) {
  if (e == null)
    return e;
  const { unitless: t } = fX(e);
  return t || typeof e == "number" ? `${e}px` : e;
}
function pX(e, t) {
  const n = ["@media screen"];
  return e && n.push("and", `(min-width: ${xy(e)})`), t && n.push("and", `(max-width: ${xy(t)})`), n.join(" ");
}
var Zt = {
  hover: (e, t) => `${e}:hover ${t}, ${e}[data-hover] ${t}`,
  focus: (e, t) => `${e}:focus ${t}, ${e}[data-focus] ${t}`,
  focusVisible: (e, t) => `${e}:focus-visible ${t}`,
  focusWithin: (e, t) => `${e}:focus-within ${t}`,
  active: (e, t) => `${e}:active ${t}, ${e}[data-active] ${t}`,
  disabled: (e, t) => `${e}:disabled ${t}, ${e}[data-disabled] ${t}`,
  invalid: (e, t) => `${e}:invalid ${t}, ${e}[data-invalid] ${t}`,
  checked: (e, t) => `${e}:checked ${t}, ${e}[data-checked] ${t}`,
  placeholderShown: (e, t) => `${e}:placeholder-shown ${t}`
}, Yr = (e) => aw((t) => e(t, "&"), "[role=group]", "[data-group]", ".group"), Pr = (e) => aw((t) => e(t, "~ &"), "[data-peer]", ".peer"), aw = (e, ...t) => t.map(e).join(", "), Bm = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: Yr(Zt.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: Pr(Zt.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: Yr(Zt.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: Pr(Zt.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: Yr(Zt.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: Pr(Zt.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: Yr(Zt.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: Pr(Zt.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: Yr(Zt.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: Pr(Zt.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: Yr(Zt.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: Pr(Zt.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: Yr(Zt.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: Pr(Zt.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: Yr(Zt.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: Pr(Zt.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: Pr(Zt.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]"
}, hX = Object.keys(
  Bm
);
function mX(e, t = []) {
  const n = Object.assign({}, e);
  for (const r of t)
    r in n && delete n[r];
  return n;
}
var Fm = Ot(
  {},
  Zc,
  Qe,
  Jj,
  xl,
  Fn,
  Kj,
  sX,
  qj,
  iw,
  iX,
  Js,
  _p,
  gt,
  dX,
  uX,
  aX,
  cX,
  Qj,
  lX
);
Object.assign({}, gt, Fn, xl, iw, Js);
var gX = [...Object.keys(Fm), ...hX], bX = { ...Fm, ...Bm }, vX = (e) => e in bX, yX = (e) => (t) => {
  if (!t.__breakpoints)
    return e;
  const { isResponsive: n, toArrayValue: r, media: o } = t.__breakpoints, i = {};
  for (const s in e) {
    let a = Eo(e[s], t);
    if (a == null)
      continue;
    if (a = Fo(a) && n(a) ? r(a) : a, !Array.isArray(a)) {
      i[s] = a;
      continue;
    }
    const c = a.slice(0, o.length).length;
    for (let l = 0; l < c; l += 1) {
      const u = o?.[l];
      if (!u) {
        i[s] = a[l];
        continue;
      }
      i[u] = i[u] || {}, a[l] != null && (i[u][s] = a[l]);
    }
  }
  return i;
};
function SX(e) {
  const t = [];
  let n = "", r = !1;
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    i === "(" ? (r = !0, n += i) : i === ")" ? (r = !1, n += i) : i === "," && !r ? (t.push(n), n = "") : n += i;
  }
  return n = n.trim(), n && t.push(n), t;
}
function xX(e) {
  return /^var\(--.+\)$/.test(e);
}
var CX = (e, t) => e.startsWith("--") && typeof t == "string" && !xX(t), IX = (e, t) => {
  var n, r;
  if (t == null)
    return t;
  const o = (c) => {
    var l, u;
    return (u = (l = e.__cssMap) == null ? void 0 : l[c]) == null ? void 0 : u.varRef;
  }, i = (c) => {
    var l;
    return (l = o(c)) != null ? l : c;
  }, [s, a] = SX(t);
  return t = (r = (n = o(s)) != null ? n : i(a)) != null ? r : i(t), t;
};
function wX(e) {
  const { configs: t = {}, pseudos: n = {}, theme: r } = e, o = (i, s = !1) => {
    var a, c, l;
    const u = Eo(i, r), d = yX(u)(r);
    let f = {};
    for (let p in d) {
      const m = d[p];
      let h = Eo(m, r);
      p in n && (p = n[p]), CX(p, h) && (h = IX(r, h));
      let g = t[p];
      if (g === !0 && (g = { property: p }), Fo(h)) {
        f[p] = (a = f[p]) != null ? a : {}, f[p] = Ot(
          {},
          f[p],
          o(h, !0)
        );
        continue;
      }
      let v = (l = (c = g?.transform) == null ? void 0 : c.call(g, h, r, u)) != null ? l : h;
      v = g?.processResult ? o(v, !0) : v;
      const y = Eo(g?.property, r);
      if (!s && g?.static) {
        const x = Eo(g.static, r);
        f = Ot({}, f, x);
      }
      if (y && Array.isArray(y)) {
        for (const x of y)
          f[x] = v;
        continue;
      }
      if (y) {
        y === "&" && Fo(v) ? f = Ot({}, f, v) : f[y] = v;
        continue;
      }
      if (Fo(v)) {
        f = Ot({}, f, v);
        continue;
      }
      f[p] = v;
    }
    return f;
  };
  return o;
}
var PX = (e) => (t) => wX({
  theme: t,
  pseudos: Bm,
  configs: Fm
})(e);
function kX(e, t) {
  if (Array.isArray(e))
    return e;
  if (Fo(e))
    return t(e);
  if (e != null)
    return [e];
}
function AX(e, t) {
  for (let n = t + 1; n < e.length; n++)
    if (e[n] != null)
      return n;
  return -1;
}
function TX(e) {
  const t = e.__breakpoints;
  return function(r, o, i, s) {
    var a, c;
    if (!t)
      return;
    const l = {}, u = kX(i, t.toArrayValue);
    if (!u)
      return l;
    const d = u.length, f = d === 1, p = !!r.parts;
    for (let m = 0; m < d; m++) {
      const h = t.details[m], g = t.details[AX(u, m)], v = pX(h.minW, g?._minW), y = Eo((a = r[o]) == null ? void 0 : a[u[m]], s);
      if (y) {
        if (p) {
          (c = r.parts) == null || c.forEach((x) => {
            Ot(l, {
              [x]: f ? y[x] : { [v]: y[x] }
            });
          });
          continue;
        }
        if (!p) {
          f ? Ot(l, y) : l[v] = y;
          continue;
        }
        l[v] = y;
      }
    }
    return l;
  };
}
function EX(e) {
  return (t) => {
    var n;
    const { variant: r, size: o, theme: i } = t, s = TX(i);
    return Ot(
      {},
      Eo((n = e.baseStyle) != null ? n : {}, t),
      s(e, "sizes", o, t),
      s(e, "variants", r, t)
    );
  };
}
function RX(e) {
  return mX(e, ["styleConfig", "size", "variant", "colorScheme"]);
}
function _X(e, t) {
  const n = {};
  return Object.keys(e).forEach((r) => {
    t.includes(r) || (n[r] = e[r]);
  }), n;
}
function OX(e, t, n, r) {
  const o = typeof t == "string" ? t.split(".") : [t];
  for (r = 0; r < o.length && e; r += 1)
    e = e[o[r]];
  return e === void 0 ? n : e;
}
var NX = (e) => {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, o, i, s) => {
    if (typeof r > "u")
      return e(r, o, i);
    t.has(r) || t.set(r, /* @__PURE__ */ new Map());
    const a = t.get(r);
    if (a.has(o))
      return a.get(o);
    const c = e(r, o, i, s);
    return a.set(o, c), c;
  };
}, MX = NX(OX);
function cw(e, t) {
  const n = {};
  return Object.keys(e).forEach((r) => {
    const o = e[r];
    t(o, r, e) && (n[r] = o);
  }), n;
}
var lw = (e) => cw(e, (t) => t != null);
function BX(e) {
  return typeof e == "function";
}
process.env.NODE_ENV;
process.env.NODE_ENV;
function FX(e, ...t) {
  return BX(e) ? e(...t) : e;
}
function DX(e, t = {}) {
  var n;
  const { styleConfig: r, ...o } = t, { theme: i, colorMode: s } = _j(), a = MX(i, `components.${e}`), c = r || a, l = Ot(
    { theme: i, colorMode: s },
    (n = c?.defaultProps) != null ? n : {},
    lw(_X(o, ["children"]))
  ), u = se({});
  if (c) {
    const f = EX(c)(l);
    dx(u.current, f) || (u.current = f);
  }
  return u.current;
}
function $X(e, t = {}) {
  return DX(e, t);
}
var VX = /* @__PURE__ */ new Set([
  ...gX,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]), LX = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function zX(e) {
  return LX.has(e) || !VX.has(e);
}
function GX(e, ...t) {
  if (e == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const n = { ...e };
  for (const r of t)
    if (r != null)
      for (const o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (o in n && delete n[o], n[o] = r[o]);
  return n;
}
var Cy, WX = (Cy = aa.default) != null ? Cy : aa, HX = ({ baseStyle: e }) => (t) => {
  const { theme: n, css: r, __css: o, sx: i, ...s } = t, a = cw(s, (d, f) => vX(f)), c = FX(e, t), l = GX(
    {},
    o,
    c,
    lw(a),
    i
  ), u = PX(l)(t.theme);
  return r ? [u, r] : u;
};
function lf(e, t) {
  const { baseStyle: n, ...r } = t ?? {};
  r.shouldForwardProp || (r.shouldForwardProp = zX);
  const o = HX({ baseStyle: n }), i = WX(
    e,
    r
  )(o);
  return At.forwardRef(function(c, l) {
    const { colorMode: u, forced: d } = rw();
    return At.createElement(i, {
      ref: l,
      "data-theme": d ? u : void 0,
      ...c
    });
  });
}
function jX() {
  const e = /* @__PURE__ */ new Map();
  return new Proxy(lf, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(t, n, r) {
      return lf(...r);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(t, n) {
      return e.has(n) || e.set(n, lf(n)), e.get(n);
    }
  });
}
var Dm = jX();
function uw(e) {
  return _t(e);
}
var $m = Dm("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
$m.displayName = "Spacer";
var dw = uw(function(t, n) {
  const {
    borderLeftWidth: r,
    borderBottomWidth: o,
    borderTopWidth: i,
    borderRightWidth: s,
    borderWidth: a,
    borderStyle: c,
    borderColor: l,
    ...u
  } = $X("Divider", t), {
    className: d,
    orientation: f = "horizontal",
    __css: p,
    ...m
  } = RX(t), h = {
    vertical: {
      borderLeftWidth: r || s || a || "1px",
      height: "100%"
    },
    horizontal: {
      borderBottomWidth: o || i || a || "1px",
      width: "100%"
    }
  };
  return /* @__PURE__ */ b(
    Dm.hr,
    {
      ref: n,
      "aria-orientation": f,
      ...m,
      __css: {
        ...u,
        border: "0",
        borderColor: l,
        borderStyle: c,
        ...h[f],
        ...p
      },
      className: Oj("chakra-divider", d)
    }
  );
});
dw.displayName = "Divider";
var Uc = uw(function(t, n) {
  const { direction: r, align: o, justify: i, wrap: s, basis: a, grow: c, shrink: l, ...u } = t, d = {
    display: "flex",
    flexDirection: r,
    alignItems: o,
    justifyContent: i,
    flexWrap: s,
    flexBasis: a,
    flexGrow: c,
    flexShrink: l
  };
  return /* @__PURE__ */ b(Dm.div, { ref: n, __css: d, ...u });
});
Uc.displayName = "Flex";
function XX(e) {
  return e === "__proto__";
}
function YX(e) {
  return e !== null && (typeof e == "object" || typeof e == "function");
}
function Vm(e) {
  return e == null || typeof e != "object" && typeof e != "function";
}
function fw(e) {
  return Object.getOwnPropertySymbols(e).filter((t) => Object.prototype.propertyIsEnumerable.call(e, t));
}
function pw(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
const ZX = "[object RegExp]", hw = "[object String]", mw = "[object Number]", gw = "[object Boolean]", bw = "[object Arguments]", UX = "[object Symbol]", JX = "[object Date]", KX = "[object Map]", qX = "[object Set]", QX = "[object Array]", e6 = "[object ArrayBuffer]", t6 = "[object Object]", n6 = "[object DataView]", r6 = "[object Uint8Array]", o6 = "[object Uint8ClampedArray]", i6 = "[object Uint16Array]", s6 = "[object Uint32Array]", a6 = "[object Int8Array]", c6 = "[object Int16Array]", l6 = "[object Int32Array]", u6 = "[object Float32Array]", d6 = "[object Float64Array]";
function Lm(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function f6(e, t) {
  return ki(e, void 0, e, /* @__PURE__ */ new Map(), t);
}
function ki(e, t, n, r = /* @__PURE__ */ new Map(), o = void 0) {
  const i = o?.(e, t, n, r);
  if (i !== void 0)
    return i;
  if (Vm(e))
    return e;
  if (r.has(e))
    return r.get(e);
  if (Array.isArray(e)) {
    const s = new Array(e.length);
    r.set(e, s);
    for (let a = 0; a < e.length; a++)
      s[a] = ki(e[a], a, n, r, o);
    return Object.hasOwn(e, "index") && (s.index = e.index), Object.hasOwn(e, "input") && (s.input = e.input), s;
  }
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof RegExp) {
    const s = new RegExp(e.source, e.flags);
    return s.lastIndex = e.lastIndex, s;
  }
  if (e instanceof Map) {
    const s = /* @__PURE__ */ new Map();
    r.set(e, s);
    for (const [a, c] of e)
      s.set(a, ki(c, a, n, r, o));
    return s;
  }
  if (e instanceof Set) {
    const s = /* @__PURE__ */ new Set();
    r.set(e, s);
    for (const a of e)
      s.add(ki(a, void 0, n, r, o));
    return s;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(e))
    return e.subarray();
  if (Lm(e)) {
    const s = new (Object.getPrototypeOf(e)).constructor(e.length);
    r.set(e, s);
    for (let a = 0; a < e.length; a++)
      s[a] = ki(e[a], a, n, r, o);
    return s;
  }
  if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return e.slice(0);
  if (e instanceof DataView) {
    const s = new DataView(e.buffer.slice(0), e.byteOffset, e.byteLength);
    return r.set(e, s), Io(s, e, n, r, o), s;
  }
  if (typeof File < "u" && e instanceof File) {
    const s = new File([e], e.name, {
      type: e.type
    });
    return r.set(e, s), Io(s, e, n, r, o), s;
  }
  if (e instanceof Blob) {
    const s = new Blob([e], { type: e.type });
    return r.set(e, s), Io(s, e, n, r, o), s;
  }
  if (e instanceof Error) {
    const s = new e.constructor();
    return r.set(e, s), s.message = e.message, s.name = e.name, s.stack = e.stack, s.cause = e.cause, Io(s, e, n, r, o), s;
  }
  if (typeof e == "object" && p6(e)) {
    const s = Object.create(Object.getPrototypeOf(e));
    return r.set(e, s), Io(s, e, n, r, o), s;
  }
  return e;
}
function Io(e, t, n = e, r, o) {
  const i = [...Object.keys(t), ...fw(t)];
  for (let s = 0; s < i.length; s++) {
    const a = i[s], c = Object.getOwnPropertyDescriptor(e, a);
    (c == null || c.writable) && (e[a] = ki(t[a], a, n, r, o));
  }
}
function p6(e) {
  switch (pw(e)) {
    case bw:
    case QX:
    case e6:
    case n6:
    case gw:
    case JX:
    case u6:
    case d6:
    case a6:
    case c6:
    case l6:
    case KX:
    case mw:
    case t6:
    case ZX:
    case qX:
    case hw:
    case UX:
    case r6:
    case o6:
    case i6:
    case s6:
      return !0;
    default:
      return !1;
  }
}
function h6(e, t) {
  return f6(e, (n, r, o, i) => {
    if (typeof e == "object")
      switch (Object.prototype.toString.call(e)) {
        case mw:
        case hw:
        case gw: {
          const s = new e.constructor(e?.valueOf());
          return Io(s, e), s;
        }
        case bw: {
          const s = {};
          return Io(s, e), s.length = e.length, s[Symbol.iterator] = e[Symbol.iterator], s;
        }
        default:
          return;
      }
  });
}
function Np(e) {
  return h6(e);
}
function Iy(e) {
  return e !== null && typeof e == "object" && pw(e) === "[object Arguments]";
}
function wy(e) {
  return typeof e == "object" && e !== null;
}
function m6(e, t, n) {
  return n == null ? Math.min(e, t) : Math.min(Math.max(e, t), n);
}
function g6(e, t, n) {
  return Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), m6(e, t, n);
}
function b6(e) {
  return e == null;
}
function v6(e) {
  return typeof e == "number" || e instanceof Number;
}
function y6() {
}
function S6(e) {
  return Lm(e);
}
function x6(e) {
  if (typeof e != "object" || e == null)
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  if (Object.prototype.toString.call(e) !== "[object Object]") {
    const n = e[Symbol.toStringTag];
    return n == null || !Object.getOwnPropertyDescriptor(e, Symbol.toStringTag)?.writable ? !1 : e.toString() === `[object ${n}]`;
  }
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function C6(e) {
  if (Vm(e))
    return e;
  if (Array.isArray(e) || Lm(e) || e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return e.slice(0);
  const t = Object.getPrototypeOf(e), n = t.constructor;
  if (e instanceof Date || e instanceof Map || e instanceof Set)
    return new n(e);
  if (e instanceof RegExp) {
    const r = new n(e);
    return r.lastIndex = e.lastIndex, r;
  }
  if (e instanceof DataView)
    return new n(e.buffer.slice(0));
  if (e instanceof Error) {
    const r = new n(e.message);
    return r.stack = e.stack, r.name = e.name, r.cause = e.cause, r;
  }
  if (typeof File < "u" && e instanceof File)
    return new n([e], e.name, { type: e.type, lastModified: e.lastModified });
  if (typeof e == "object") {
    const r = Object.create(t);
    return Object.assign(r, e);
  }
  return e;
}
function I6(e, ...t) {
  const n = t.slice(0, -1), r = t[t.length - 1];
  let o = e;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    o = Jc(o, s, r, /* @__PURE__ */ new Map());
  }
  return o;
}
function Jc(e, t, n, r) {
  if (Vm(e) && (e = Object(e)), t == null || typeof t != "object")
    return e;
  if (r.has(t))
    return C6(r.get(t));
  if (r.set(t, e), Array.isArray(t)) {
    t = t.slice();
    for (let i = 0; i < t.length; i++)
      t[i] = t[i] ?? void 0;
  }
  const o = [...Object.keys(t), ...fw(t)];
  for (let i = 0; i < o.length; i++) {
    const s = o[i];
    if (XX(s))
      continue;
    let a = t[s], c = e[s];
    if (Iy(a) && (a = { ...a }), Iy(c) && (c = { ...c }), typeof Buffer < "u" && Buffer.isBuffer(a) && (a = Np(a)), Array.isArray(a))
      if (typeof c == "object" && c != null) {
        const u = [], d = Reflect.ownKeys(c);
        for (let f = 0; f < d.length; f++) {
          const p = d[f];
          u[p] = c[p];
        }
        c = u;
      } else
        c = [];
    const l = n(c, a, s, e, t, r);
    l !== void 0 ? e[s] = l : Array.isArray(a) || wy(c) && wy(a) ? e[s] = Jc(c, a, n, r) : c == null && x6(a) ? e[s] = Jc({}, a, n, r) : c == null && S6(a) ? e[s] = Np(a) : (c === void 0 || a !== void 0) && (e[s] = a);
  }
  return e;
}
function w6(e, ...t) {
  return I6(e, ...t, y6);
}
const P6 = /[\u200d\ud800-\udfff\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff\ufe0e\ufe0f]/;
function k6(e, t) {
  e = e != null ? `${e}` : "";
  let n = 30, r = "...";
  YX(t) && (n = A6(t.length), r = "omission" in t ? `${t.omission}` : "...");
  let o = e.length;
  const i = Array.from(r).length, s = Math.max(n - i, 0);
  let a;
  if (P6.test(e) && (a = Array.from(e), o = a.length), n >= o)
    return e;
  if (o <= i)
    return r;
  let l = a === void 0 ? e.slice(0, s) : a?.slice(0, s).join("");
  const u = t?.separator;
  if (!u)
    return l += r, l;
  const d = u instanceof RegExp ? u.source : u, f = "u" + (u instanceof RegExp ? u.flags.replace("u", "") : ""), p = new RegExp(`(?<result>.*(?:(?!${d}).))(?:${d})`, f).exec(l);
  return (p?.groups ? p.groups.result : l) + r;
}
function A6(e) {
  return e == null ? 30 : e <= 0 ? 0 : e;
}
const T6 = (e) => {
  e.preventDefault();
}, zm = (e) => {
  e.stopPropagation();
}, ut = T0, vw = ut(
  X((e, t) => {
    const { children: n, badges: r, ...o } = e, i = be(
      () => r?.map((s) => k6(String(s), { length: 24, omission: "..." })),
      [r]
    );
    return /* @__PURE__ */ Ae(wx, { ref: t, ...o, children: [
      n,
      /* @__PURE__ */ b($m, {}),
      i?.map((s, a) => /* @__PURE__ */ b(Kh, { colorScheme: "invokeBlue", children: s }, `${s}.${a}`)),
      /* @__PURE__ */ b(Px, {})
    ] });
  })
);
vw.displayName = "AccordionButton";
const E6 = ut((e) => {
  const t = R(
    (n) => {
      n.preventDefault(), e.onToggle();
    },
    [e]
  );
  return /* @__PURE__ */ b(Ix, { index: e.isOpen ? 0 : void 0, allowToggle: !0, children: /* @__PURE__ */ Ae(kx, { children: [
    /* @__PURE__ */ b(vw, { badges: e.badges, onClick: t, children: e.label }),
    /* @__PURE__ */ b(Ax, { children: e.children })
  ] }) });
});
E6.displayName = "StandaloneAccordion";
const R6 = (e, t, n, r) => {
  const o = [n, {
    code: t,
    ...r || {}
  }];
  if (e?.services?.logger?.forward)
    return e.services.logger.forward(o, "warn", "react-i18next::", !0);
  Do(o[0]) && (o[0] = `react-i18next:: ${o[0]}`), e?.services?.logger?.warn ? e.services.logger.warn(...o) : console?.warn && console.warn(...o);
}, Py = {}, Mp = (e, t, n, r) => {
  Do(n) && Py[n] || (Do(n) && (Py[n] = /* @__PURE__ */ new Date()), R6(e, t, n, r));
}, yw = (e, t) => () => {
  if (e.isInitialized)
    t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), t();
    };
    e.on("initialized", n);
  }
}, Bp = (e, t, n) => {
  e.loadNamespaces(t, yw(e, n));
}, ky = (e, t, n, r) => {
  if (Do(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return Bp(e, n, r);
  n.forEach((o) => {
    e.options.ns.indexOf(o) < 0 && e.options.ns.push(o);
  }), e.loadLanguages(t, yw(e, r));
}, _6 = (e, t, n = {}) => !t.languages || !t.languages.length ? (Mp(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
  languages: t.languages
}), !0) : t.hasLoadedNamespace(e, {
  lng: n.lng,
  precheck: (r, o) => {
    if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !o(r.isLanguageChangingTo, e)) return !1;
  }
}), Do = (e) => typeof e == "string", O6 = (e) => typeof e == "object" && e !== null, N6 = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, M6 = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
}, B6 = (e) => M6[e], F6 = (e) => e.replace(N6, B6);
let D6 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: F6
};
const $6 = () => D6;
let V6;
const L6 = () => V6, z6 = an();
class G6 {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const W6 = (e, t) => {
  const n = se();
  return ge(() => {
    n.current = e;
  }, [e, t]), n.current;
}, Sw = (e, t, n, r) => e.getFixedT(t, n, r), H6 = (e, t, n, r) => R(Sw(e, t, n, r), [e, t, n, r]), xw = (e, t = {}) => {
  const {
    i18n: n
  } = t, {
    i18n: r,
    defaultNS: o
  } = at(z6) || {}, i = n || r || L6();
  if (i && !i.reportNamespaces && (i.reportNamespaces = new G6()), !i) {
    Mp(i, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const S = (w, I) => Do(I) ? I : O6(I) && Do(I.defaultValue) ? I.defaultValue : Array.isArray(w) ? w[w.length - 1] : w, C = [S, {}, !1];
    return C.t = S, C.i18n = {}, C.ready = !1, C;
  }
  i.options.react?.wait && Mp(i, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const s = {
    ...$6(),
    ...i.options.react,
    ...t
  }, {
    useSuspense: a,
    keyPrefix: c
  } = s;
  let l = o || i.options?.defaultNS;
  l = Do(l) ? [l] : l || ["translation"], i.reportNamespaces.addUsedNamespaces?.(l);
  const u = (i.isInitialized || i.initializedStoreOnce) && l.every((S) => _6(S, i, s)), d = H6(i, t.lng || null, s.nsMode === "fallback" ? l : l[0], c), f = () => d, p = () => Sw(i, t.lng || null, s.nsMode === "fallback" ? l : l[0], c), [m, h] = ue(f);
  let g = l.join();
  t.lng && (g = `${t.lng}${g}`);
  const v = W6(g), y = se(!0);
  ge(() => {
    const {
      bindI18n: S,
      bindI18nStore: C
    } = s;
    y.current = !0, !u && !a && (t.lng ? ky(i, t.lng, l, () => {
      y.current && h(p);
    }) : Bp(i, l, () => {
      y.current && h(p);
    })), u && v && v !== g && y.current && h(p);
    const w = () => {
      y.current && h(p);
    };
    return S && i?.on(S, w), C && i?.store.on(C, w), () => {
      y.current = !1, i && S && S?.split(" ").forEach((I) => i.off(I, w)), C && i && C.split(" ").forEach((I) => i.store.off(I, w));
    };
  }, [i, g]), ge(() => {
    y.current && u && h(f);
  }, [i, c, u]);
  const x = [m, i, u];
  if (x.t = m, x.i18n = i, x.ready = u, u || !u && !a) return x;
  throw new Promise((S) => {
    t.lng ? ky(i, t.lng, l, () => S()) : Bp(i, l, () => S());
  });
}, j6 = [
  {
    name: "preventOverflow",
    options: {
      padding: 12
    }
  }
], so = ut(
  X((e, t) => {
    const { children: n, hasArrow: r = !0, placement: o = "top", openDelay: i = 500, ...s } = e;
    return /* @__PURE__ */ b(
      qI,
      {
        ref: t,
        hasArrow: r,
        placement: o,
        arrowSize: 8,
        modifiers: j6,
        openDelay: i,
        ...s,
        children: n
      }
    );
  })
);
so.displayName = "Tooltip";
const Fp = ut(
  X(({ isChecked: e, tooltip: t, children: n, ...r }, o) => t ? /* @__PURE__ */ b(so, { label: t, children: /* @__PURE__ */ b(bl, { ref: o, colorScheme: e ? "invokeBlue" : "base", ...r, children: n }) }) : /* @__PURE__ */ b(bl, { ref: o, colorScheme: e ? "invokeBlue" : "base", ...r, children: n }))
);
Fp.displayName = "Button";
const X6 = ut(
  X(({ isAttached: e = !0, ...t }, n) => /* @__PURE__ */ b(Fx, { ref: n, isAttached: e, ...t }))
);
X6.displayName = "ButtonGroup";
const Y6 = ut(
  X(({ isChecked: e, tooltip: t, ...n }, r) => t ? /* @__PURE__ */ b(so, { label: t, children: /* @__PURE__ */ b(cp, { ref: r, colorScheme: e ? "invokeBlue" : "base", ...n }) }) : /* @__PURE__ */ b(cp, { ref: r, colorScheme: e ? "invokeBlue" : "base", ...n }))
);
Y6.displayName = "IconButton";
const oee = ut((e) => {
  const { t } = xw(), {
    acceptCallback: n,
    cancelCallback: r,
    acceptButtonText: o = t("common.accept", "Accept"),
    cancelButtonText: i = t("common.cancel", "Cancel"),
    children: s,
    title: a,
    isOpen: c,
    onClose: l,
    ...u
  } = e, d = se(null), f = R(() => {
    n(), l();
  }, [n, l]), p = R(() => {
    r?.(), l();
  }, [r, l]);
  return /* @__PURE__ */ b(tW, { isOpen: c, leastDestructiveRef: d, onClose: l, isCentered: !0, ...u, children: /* @__PURE__ */ b(vI, { children: /* @__PURE__ */ Ae(nW, { children: [
    /* @__PURE__ */ b(gI, { fontSize: "lg", fontWeight: "bold", children: a }),
    /* @__PURE__ */ b(hI, { children: s }),
    /* @__PURE__ */ Ae(mI, { children: [
      /* @__PURE__ */ b(Fp, { ref: d, onClick: p, children: i }),
      /* @__PURE__ */ b(Fp, { colorScheme: "error", onClick: f, ml: 3, children: o })
    ] })
  ] }) }) });
});
function Ay(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function we(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ay(Object(n), !0).forEach(function(r) {
      Ao(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ay(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Z6(e) {
  if (Array.isArray(e)) return e;
}
function U6(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, i, s, a = [], c = !0, l = !1;
    try {
      if (i = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = i.call(n)).done) && (a.push(r.value), a.length !== t); c = !0) ;
    } catch (u) {
      l = !0, o = u;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (l) throw o;
      }
    }
    return a;
  }
}
function Dp(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function Cw(e, t) {
  if (e) {
    if (typeof e == "string") return Dp(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Dp(e, t) : void 0;
  }
}
function J6() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ht(e, t) {
  return Z6(e) || U6(e, t) || Cw(e, t) || J6();
}
function Qn(e, t) {
  if (e == null) return {};
  var n, r, o = Wx(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var K6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function ku(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, i = e.defaultValue, s = i === void 0 ? null : i, a = e.inputValue, c = e.menuIsOpen, l = e.onChange, u = e.onInputChange, d = e.onMenuClose, f = e.onMenuOpen, p = e.value, m = Qn(e, K6), h = ue(a !== void 0 ? a : n), g = Ht(h, 2), v = g[0], y = g[1], x = ue(c !== void 0 ? c : o), S = Ht(x, 2), C = S[0], w = S[1], I = ue(p !== void 0 ? p : s), P = Ht(I, 2), k = P[0], A = P[1], N = R(function(J, ee) {
    typeof l == "function" && l(J, ee), A(J);
  }, [l]), B = R(function(J, ee) {
    var H;
    typeof u == "function" && (H = u(J, ee)), y(H !== void 0 ? H : J);
  }, [u]), L = R(function() {
    typeof f == "function" && f(), w(!0);
  }, [f]), Z = R(function() {
    typeof d == "function" && d(), w(!1);
  }, [d]), ne = a !== void 0 ? a : v, W = c !== void 0 ? c : C, O = p !== void 0 ? p : k;
  return we(we({}, m), {}, {
    inputValue: ne,
    menuIsOpen: W,
    onChange: N,
    onInputChange: B,
    onMenuClose: Z,
    onMenuOpen: L,
    value: O
  });
}
function q6(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function Ty(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, tC(r.key), r);
  }
}
function Q6(e, t, n) {
  return t && Ty(e.prototype, t), n && Ty(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function eY(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && vl(e, t);
}
function Cl(e) {
  return Cl = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Cl(e);
}
function Iw() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Iw = function() {
    return !!e;
  })();
}
function tY(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function nY(e, t) {
  if (t && (Go(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return tY(e);
}
function rY(e) {
  var t = Iw();
  return function() {
    var n, r = Cl(e);
    if (t) {
      var o = Cl(this).constructor;
      n = Reflect.construct(r, arguments, o);
    } else n = r.apply(this, arguments);
    return nY(this, n);
  };
}
function oY(e) {
  if (Array.isArray(e)) return Dp(e);
}
function iY(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function sY() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function zi(e) {
  return oY(e) || iY(e) || Cw(e) || sY();
}
function aY(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
const cY = Math.min, lY = Math.max, Il = Math.round, mc = Math.floor, wl = (e) => ({
  x: e,
  y: e
});
function uY(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Au() {
  return typeof window < "u";
}
function ww(e) {
  return kw(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Wr(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Pw(e) {
  var t;
  return (t = (kw(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function kw(e) {
  return Au() ? e instanceof Node || e instanceof Wr(e).Node : !1;
}
function dY(e) {
  return Au() ? e instanceof Element || e instanceof Wr(e).Element : !1;
}
function Gm(e) {
  return Au() ? e instanceof HTMLElement || e instanceof Wr(e).HTMLElement : !1;
}
function Ey(e) {
  return !Au() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Wr(e).ShadowRoot;
}
const fY = /* @__PURE__ */ new Set(["inline", "contents"]);
function Aw(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = Wm(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !fY.has(o);
}
function pY() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const hY = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function mY(e) {
  return hY.has(ww(e));
}
function Wm(e) {
  return Wr(e).getComputedStyle(e);
}
function gY(e) {
  if (ww(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Ey(e) && e.host || // Fallback.
    Pw(e)
  );
  return Ey(t) ? t.host : t;
}
function Tw(e) {
  const t = gY(e);
  return mY(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Gm(t) && Aw(t) ? t : Tw(t);
}
function Pl(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Tw(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Wr(o);
  if (i) {
    const a = $p(s);
    return t.concat(s, s.visualViewport || [], Aw(o) ? o : [], a && n ? Pl(a) : []);
  }
  return t.concat(o, Pl(o, [], n));
}
function $p(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function bY(e) {
  const t = Wm(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Gm(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, a = Il(n) !== i || Il(r) !== s;
  return a && (n = i, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Hm(e) {
  return dY(e) ? e : e.contextElement;
}
function Ry(e) {
  const t = Hm(e);
  if (!Gm(t))
    return wl(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = bY(t);
  let s = (i ? Il(n.width) : n.width) / r, a = (i ? Il(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const vY = /* @__PURE__ */ wl(0);
function yY(e) {
  const t = Wr(e);
  return !pY() || !t.visualViewport ? vY : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function SY(e, t, n) {
  return !1;
}
function _y(e, t, n, r) {
  t === void 0 && (t = !1);
  const o = e.getBoundingClientRect(), i = Hm(e);
  let s = wl(1);
  t && (s = Ry(e));
  const a = SY() ? yY(i) : wl(0);
  let c = (o.left + a.x) / s.x, l = (o.top + a.y) / s.y, u = o.width / s.x, d = o.height / s.y;
  if (i) {
    const f = Wr(i), p = r;
    let m = f, h = $p(m);
    for (; h && r && p !== m; ) {
      const g = Ry(h), v = h.getBoundingClientRect(), y = Wm(h), x = v.left + (h.clientLeft + parseFloat(y.paddingLeft)) * g.x, S = v.top + (h.clientTop + parseFloat(y.paddingTop)) * g.y;
      c *= g.x, l *= g.y, u *= g.x, d *= g.y, c += x, l += S, m = Wr(h), h = $p(m);
    }
  }
  return uY({
    width: u,
    height: d,
    x: c,
    y: l
  });
}
function Ew(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function xY(e, t) {
  let n = null, r;
  const o = Pw(e);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), i();
    const l = e.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: p
    } = l;
    if (a || t(), !f || !p)
      return;
    const m = mc(d), h = mc(o.clientWidth - (u + f)), g = mc(o.clientHeight - (d + p)), v = mc(u), x = {
      rootMargin: -m + "px " + -h + "px " + -g + "px " + -v + "px",
      threshold: lY(0, cY(1, c)) || 1
    };
    let S = !0;
    function C(w) {
      const I = w[0].intersectionRatio;
      if (I !== c) {
        if (!S)
          return s();
        I ? s(!1, I) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !Ew(l, e.getBoundingClientRect()) && s(), S = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...x,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, x);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function CY(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = Hm(e), u = o || i ? [...l ? Pl(l) : [], ...Pl(t)] : [];
  u.forEach((v) => {
    o && v.addEventListener("scroll", n, {
      passive: !0
    }), i && v.addEventListener("resize", n);
  });
  const d = l && a ? xY(l, n) : null;
  let f = -1, p = null;
  s && (p = new ResizeObserver((v) => {
    let [y] = v;
    y && y.target === l && p && (p.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var x;
      (x = p) == null || x.observe(t);
    })), n();
  }), l && !c && p.observe(l), p.observe(t));
  let m, h = c ? _y(e) : null;
  c && g();
  function g() {
    const v = _y(e);
    h && !Ew(h, v) && n(), h = v, m = requestAnimationFrame(g);
  }
  return n(), () => {
    var v;
    u.forEach((y) => {
      o && y.removeEventListener("scroll", n), i && y.removeEventListener("resize", n);
    }), d?.(), (v = p) == null || v.disconnect(), p = null, c && cancelAnimationFrame(m);
  };
}
var Vp = os, IY = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], kl = function() {
};
function wY(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function PY(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var i = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && i.push("".concat(wY(e, s)));
  return i.filter(function(a) {
    return a;
  }).map(function(a) {
    return String(a).trim();
  }).join(" ");
}
var Al = function(t) {
  return BY(t) ? t.filter(Boolean) : Go(t) === "object" && t !== null ? [t] : [];
}, Rw = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = Qn(t, IY);
  return we({}, n);
}, Et = function(t, n, r) {
  var o = t.cx, i = t.getStyles, s = t.getClassNames, a = t.className;
  return {
    css: i(n, t),
    className: o(r ?? {}, s(n, t), a)
  };
};
function kY(e, t, n) {
  if (n) {
    var r = n(e, t);
    if (typeof r == "string") return r;
  }
  return e;
}
function Tu(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function AY(e) {
  return Tu(e) ? window.innerHeight : e.clientHeight;
}
function _w(e) {
  return Tu(e) ? window.pageYOffset : e.scrollTop;
}
function Tl(e, t) {
  if (Tu(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function TY(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var o = e; o = o.parentElement; )
    if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return o;
  return document.documentElement;
}
function EY(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function gc(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : kl, o = _w(e), i = t - o, s = 10, a = 0;
  function c() {
    a += s;
    var l = EY(a, o, i, n);
    Tl(e, l), a < n ? window.requestAnimationFrame(c) : r(e);
  }
  c();
}
function Oy(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
  r.bottom + o > n.bottom ? Tl(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && Tl(e, Math.max(t.offsetTop - o, 0));
}
function RY(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function Ny() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function _Y() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var Ow = !1, OY = {
  get passive() {
    return Ow = !0;
  }
}, bc = typeof window < "u" ? window : {};
bc.addEventListener && bc.removeEventListener && (bc.addEventListener("p", kl, OY), bc.removeEventListener("p", kl, !1));
var NY = Ow;
function MY(e) {
  return e != null;
}
function BY(e) {
  return Array.isArray(e);
}
function Fs(e, t, n) {
  return e ? t : n;
}
var FY = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
    r[o - 1] = arguments[o];
  var i = Object.entries(t).filter(function(s) {
    var a = Ht(s, 1), c = a[0];
    return !r.includes(c);
  });
  return i.reduce(function(s, a) {
    var c = Ht(a, 2), l = c[0], u = c[1];
    return s[l] = u, s;
  }, {});
}, DY = ["children", "innerProps"], $Y = ["children", "innerProps"];
function VY(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, i = e.shouldScroll, s = e.isFixedPosition, a = e.controlHeight, c = TY(n), l = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return l;
  var u = c.getBoundingClientRect(), d = u.height, f = n.getBoundingClientRect(), p = f.bottom, m = f.height, h = f.top, g = n.offsetParent.getBoundingClientRect(), v = g.top, y = s ? window.innerHeight : AY(c), x = _w(c), S = parseInt(getComputedStyle(n).marginBottom, 10), C = parseInt(getComputedStyle(n).marginTop, 10), w = v - C, I = y - h, P = w + x, k = d - x - h, A = p - y + x + S, N = x + h - C, B = 160;
  switch (o) {
    case "auto":
    case "bottom":
      if (I >= m)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (k >= m && !s)
        return i && gc(c, A, B), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && k >= r || s && I >= r) {
        i && gc(c, A, B);
        var L = s ? I - S : k - S;
        return {
          placement: "bottom",
          maxHeight: L
        };
      }
      if (o === "auto" || s) {
        var Z = t, ne = s ? w : P;
        return ne >= r && (Z = Math.min(ne - S - a, t)), {
          placement: "top",
          maxHeight: Z
        };
      }
      if (o === "bottom")
        return i && Tl(c, A), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (w >= m)
        return {
          placement: "top",
          maxHeight: t
        };
      if (P >= m && !s)
        return i && gc(c, N, B), {
          placement: "top",
          maxHeight: t
        };
      if (!s && P >= r || s && w >= r) {
        var W = t;
        return (!s && P >= r || s && w >= r) && (W = s ? w - C : P - C), i && gc(c, N, B), {
          placement: "top",
          maxHeight: W
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(o, '".'));
  }
  return l;
}
function LY(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var Nw = function(t) {
  return t === "auto" ? "bottom" : t;
}, zY = function(t, n) {
  var r, o = t.placement, i = t.theme, s = i.borderRadius, a = i.spacing, c = i.colors;
  return we((r = {
    label: "menu"
  }, Ao(r, LY(o), "100%"), Ao(r, "position", "absolute"), Ao(r, "width", "100%"), Ao(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: c.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: a.menuGutter,
    marginTop: a.menuGutter
  });
}, Mw = /* @__PURE__ */ an(null), GY = function(t) {
  var n = t.children, r = t.minMenuHeight, o = t.maxMenuHeight, i = t.menuPlacement, s = t.menuPosition, a = t.menuShouldScrollIntoView, c = t.theme, l = at(Mw) || {}, u = l.setPortalPlacement, d = se(null), f = ue(o), p = Ht(f, 2), m = p[0], h = p[1], g = ue(null), v = Ht(g, 2), y = v[0], x = v[1], S = c.spacing.controlHeight;
  return Vp(function() {
    var C = d.current;
    if (C) {
      var w = s === "fixed", I = a && !w, P = VY({
        maxHeight: o,
        menuEl: C,
        minHeight: r,
        placement: i,
        shouldScroll: I,
        isFixedPosition: w,
        controlHeight: S
      });
      h(P.maxHeight), x(P.placement), u?.(P.placement);
    }
  }, [o, i, s, a, r, u, S]), n({
    ref: d,
    placerProps: we(we({}, t), {}, {
      placement: y || Nw(i),
      maxHeight: m
    })
  });
}, WY = function(t) {
  var n = t.children, r = t.innerRef, o = t.innerProps;
  return Ee("div", Ie({}, Et(t, "menu", {
    menu: !0
  }), {
    ref: r
  }, o), n);
}, HY = WY, jY = function(t, n) {
  var r = t.maxHeight, o = t.theme.spacing.baseUnit;
  return we({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: o,
    paddingTop: o
  });
}, XY = function(t) {
  var n = t.children, r = t.innerProps, o = t.innerRef, i = t.isMulti;
  return Ee("div", Ie({}, Et(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": i
  }), {
    ref: o
  }, r), n);
}, Bw = function(t, n) {
  var r = t.theme, o = r.spacing.baseUnit, i = r.colors;
  return we({
    textAlign: "center"
  }, n ? {} : {
    color: i.neutral40,
    padding: "".concat(o * 2, "px ").concat(o * 3, "px")
  });
}, YY = Bw, ZY = Bw, UY = function(t) {
  var n = t.children, r = n === void 0 ? "No options" : n, o = t.innerProps, i = Qn(t, DY);
  return Ee("div", Ie({}, Et(we(we({}, i), {}, {
    children: r,
    innerProps: o
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), o), r);
}, JY = function(t) {
  var n = t.children, r = n === void 0 ? "Loading..." : n, o = t.innerProps, i = Qn(t, $Y);
  return Ee("div", Ie({}, Et(we(we({}, i), {}, {
    children: r,
    innerProps: o
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), o), r);
}, KY = function(t) {
  var n = t.rect, r = t.offset, o = t.position;
  return {
    left: n.left,
    position: o,
    top: r,
    width: n.width,
    zIndex: 1
  };
}, qY = function(t) {
  var n = t.appendTo, r = t.children, o = t.controlElement, i = t.innerProps, s = t.menuPlacement, a = t.menuPosition, c = se(null), l = se(null), u = ue(Nw(s)), d = Ht(u, 2), f = d[0], p = d[1], m = be(function() {
    return {
      setPortalPlacement: p
    };
  }, []), h = ue(null), g = Ht(h, 2), v = g[0], y = g[1], x = R(function() {
    if (o) {
      var I = RY(o), P = a === "fixed" ? 0 : window.pageYOffset, k = I[f] + P;
      (k !== v?.offset || I.left !== v?.rect.left || I.width !== v?.rect.width) && y({
        offset: k,
        rect: I
      });
    }
  }, [o, a, f, v?.offset, v?.rect.left, v?.rect.width]);
  Vp(function() {
    x();
  }, [x]);
  var S = R(function() {
    typeof l.current == "function" && (l.current(), l.current = null), o && c.current && (l.current = CY(o, c.current, x, {
      elementResize: "ResizeObserver" in window
    }));
  }, [o, x]);
  Vp(function() {
    S();
  }, [S]);
  var C = R(function(I) {
    c.current = I, S();
  }, [S]);
  if (!n && a !== "fixed" || !v) return null;
  var w = Ee("div", Ie({
    ref: C
  }, Et(we(we({}, t), {}, {
    offset: v.offset,
    position: a,
    rect: v.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), i), r);
  return Ee(Mw.Provider, {
    value: m
  }, n ? /* @__PURE__ */ va(w, n) : w);
}, QY = function(t) {
  var n = t.isDisabled, r = t.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, eZ = function(t) {
  var n = t.children, r = t.innerProps, o = t.isDisabled, i = t.isRtl;
  return Ee("div", Ie({}, Et(t, "container", {
    "--is-disabled": o,
    "--is-rtl": i
  }), r), n);
}, tZ = function(t, n) {
  var r = t.theme.spacing, o = t.isMulti, i = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return we({
    alignItems: "center",
    display: o && i && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
}, nZ = function(t) {
  var n = t.children, r = t.innerProps, o = t.isMulti, i = t.hasValue;
  return Ee("div", Ie({}, Et(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": o,
    "value-container--has-value": i
  }), r), n);
}, rZ = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, oZ = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", Ie({}, Et(t, "indicatorsContainer", {
    indicators: !0
  }), r), n);
}, My, iZ = ["size"], sZ = ["innerProps", "isRtl", "size"];
function aZ() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var cZ = process.env.NODE_ENV === "production" ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */",
  toString: aZ
}, Fw = function(t) {
  var n = t.size, r = Qn(t, iZ);
  return Ee("svg", Ie({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: cZ
  }, r));
}, jm = function(t) {
  return Ee(Fw, Ie({
    size: 20
  }, t), Ee("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, Dw = function(t) {
  return Ee(Fw, Ie({
    size: 20
  }, t), Ee("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, $w = function(t, n) {
  var r = t.isFocused, o = t.theme, i = o.spacing.baseUnit, s = o.colors;
  return we({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: i * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
}, lZ = $w, uZ = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", Ie({}, Et(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), r), n || Ee(Dw, null));
}, dZ = $w, fZ = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", Ie({}, Et(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), r), n || Ee(jm, null));
}, pZ = function(t, n) {
  var r = t.isDisabled, o = t.theme, i = o.spacing.baseUnit, s = o.colors;
  return we({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: i * 2,
    marginTop: i * 2
  });
}, hZ = function(t) {
  var n = t.innerProps;
  return Ee("span", Ie({}, n, Et(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, mZ = An(My || (My = aY([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), gZ = function(t, n) {
  var r = t.isFocused, o = t.size, i = t.theme, s = i.colors, a = i.spacing.baseUnit;
  return we({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: o,
    lineHeight: 1,
    marginRight: o,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2
  });
}, uf = function(t) {
  var n = t.delay, r = t.offset;
  return Ee("span", {
    css: /* @__PURE__ */ xh({
      animation: "".concat(mZ, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, process.env.NODE_ENV === "production" ? "" : ";label:LoadingDot;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */")
  });
}, bZ = function(t) {
  var n = t.innerProps, r = t.isRtl, o = t.size, i = o === void 0 ? 4 : o, s = Qn(t, sZ);
  return Ee("div", Ie({}, Et(we(we({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: i
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), Ee(uf, {
    delay: 0,
    offset: r
  }), Ee(uf, {
    delay: 160,
    offset: !0
  }), Ee(uf, {
    delay: 320,
    offset: !r
  }));
}, vZ = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, i = t.theme, s = i.colors, a = i.borderRadius, c = i.spacing;
  return we({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: c.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : o ? s.primary : s.neutral20,
    borderRadius: a,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: o ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: o ? s.primary : s.neutral30
    }
  });
}, yZ = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.innerRef, s = t.innerProps, a = t.menuIsOpen;
  return Ee("div", Ie({
    ref: i
  }, Et(t, "control", {
    control: !0,
    "control--is-disabled": r,
    "control--is-focused": o,
    "control--menu-is-open": a
  }), s, {
    "aria-disabled": r || void 0
  }), n);
}, SZ = yZ, xZ = ["data"], CZ = function(t, n) {
  var r = t.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
}, IZ = function(t) {
  var n = t.children, r = t.cx, o = t.getStyles, i = t.getClassNames, s = t.Heading, a = t.headingProps, c = t.innerProps, l = t.label, u = t.theme, d = t.selectProps;
  return Ee("div", Ie({}, Et(t, "group", {
    group: !0
  }), c), Ee(s, Ie({}, a, {
    selectProps: d,
    theme: u,
    getStyles: o,
    getClassNames: i,
    cx: r
  }), l), Ee("div", null, n));
}, wZ = function(t, n) {
  var r = t.theme, o = r.colors, i = r.spacing;
  return we({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: o.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: i.baseUnit * 3,
    paddingRight: i.baseUnit * 3,
    textTransform: "uppercase"
  });
}, PZ = function(t) {
  var n = Rw(t);
  n.data;
  var r = Qn(n, xZ);
  return Ee("div", Ie({}, Et(t, "groupHeading", {
    "group-heading": !0
  }), r));
}, kZ = IZ, AZ = ["innerRef", "isDisabled", "isHidden", "inputClassName"], TZ = function(t, n) {
  var r = t.isDisabled, o = t.value, i = t.theme, s = i.spacing, a = i.colors;
  return we(we({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: o ? "translateZ(0)" : ""
  }, EZ), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: a.neutral80
  });
}, Vw = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, EZ = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": we({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, Vw)
}, RZ = function(t) {
  return we({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, Vw);
}, _Z = function(t) {
  var n = t.cx, r = t.value, o = Rw(t), i = o.innerRef, s = o.isDisabled, a = o.isHidden, c = o.inputClassName, l = Qn(o, AZ);
  return Ee("div", Ie({}, Et(t, "input", {
    "input-container": !0
  }), {
    "data-value": r || ""
  }), Ee("input", Ie({
    className: n({
      input: !0
    }, c),
    ref: i,
    style: RZ(a),
    disabled: s
  }, l)));
}, OZ = _Z, NZ = function(t, n) {
  var r = t.theme, o = r.spacing, i = r.borderRadius, s = r.colors;
  return we({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: i / 2,
    margin: o.baseUnit / 2
  });
}, MZ = function(t, n) {
  var r = t.theme, o = r.borderRadius, i = r.colors, s = t.cropWithEllipsis;
  return we({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: o / 2,
    color: i.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, BZ = function(t, n) {
  var r = t.theme, o = r.spacing, i = r.borderRadius, s = r.colors, a = t.isFocused;
  return we({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: i / 2,
    backgroundColor: a ? s.dangerLight : void 0,
    paddingLeft: o.baseUnit,
    paddingRight: o.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, Lw = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", r, n);
}, FZ = Lw, DZ = Lw;
function $Z(e) {
  var t = e.children, n = e.innerProps;
  return Ee("div", Ie({
    role: "button"
  }, n), t || Ee(jm, {
    size: 14
  }));
}
var VZ = function(t) {
  var n = t.children, r = t.components, o = t.data, i = t.innerProps, s = t.isDisabled, a = t.removeProps, c = t.selectProps, l = r.Container, u = r.Label, d = r.Remove;
  return Ee(l, {
    data: o,
    innerProps: we(we({}, Et(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), i),
    selectProps: c
  }, Ee(u, {
    data: o,
    innerProps: we({}, Et(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: c
  }, n), Ee(d, {
    data: o,
    innerProps: we(we({}, Et(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, a),
    selectProps: c
  }));
}, LZ = VZ, zZ = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, i = t.isSelected, s = t.theme, a = s.spacing, c = s.colors;
  return we({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: i ? c.primary : o ? c.primary25 : "transparent",
    color: r ? c.neutral20 : i ? c.neutral0 : "inherit",
    padding: "".concat(a.baseUnit * 2, "px ").concat(a.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : i ? c.primary : c.primary50
    }
  });
}, GZ = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.isSelected, s = t.innerRef, a = t.innerProps;
  return Ee("div", Ie({}, Et(t, "option", {
    option: !0,
    "option--is-disabled": r,
    "option--is-focused": o,
    "option--is-selected": i
  }), {
    ref: s,
    "aria-disabled": r
  }, a), n);
}, WZ = GZ, HZ = function(t, n) {
  var r = t.theme, o = r.spacing, i = r.colors;
  return we({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: i.neutral50,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, jZ = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", Ie({}, Et(t, "placeholder", {
    placeholder: !0
  }), r), n);
}, XZ = jZ, YZ = function(t, n) {
  var r = t.isDisabled, o = t.theme, i = o.spacing, s = o.colors;
  return we({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: i.baseUnit / 2,
    marginRight: i.baseUnit / 2
  });
}, ZZ = function(t) {
  var n = t.children, r = t.isDisabled, o = t.innerProps;
  return Ee("div", Ie({}, Et(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": r
  }), o), n);
}, UZ = ZZ, JZ = {
  ClearIndicator: fZ,
  Control: SZ,
  DropdownIndicator: uZ,
  DownChevron: Dw,
  CrossIcon: jm,
  Group: kZ,
  GroupHeading: PZ,
  IndicatorsContainer: oZ,
  IndicatorSeparator: hZ,
  Input: OZ,
  LoadingIndicator: bZ,
  Menu: HY,
  MenuList: XY,
  MenuPortal: qY,
  LoadingMessage: JY,
  NoOptionsMessage: UY,
  MultiValue: LZ,
  MultiValueContainer: FZ,
  MultiValueLabel: DZ,
  MultiValueRemove: $Z,
  Option: WZ,
  Placeholder: XZ,
  SelectContainer: eZ,
  SingleValue: UZ,
  ValueContainer: nZ
}, KZ = function(t) {
  return we(we({}, JZ), t.components);
}, By = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function qZ(e, t) {
  return !!(e === t || By(e) && By(t));
}
function QZ(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!qZ(e[n], t[n]))
      return !1;
  return !0;
}
function e7(e, t) {
  t === void 0 && (t = QZ);
  var n = null;
  function r() {
    for (var o = [], i = 0; i < arguments.length; i++)
      o[i] = arguments[i];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, o);
    return n = {
      lastResult: s,
      lastArgs: o,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
function t7() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var n7 = process.env.NODE_ENV === "production" ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IEpTWCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: t7
}, r7 = function(t) {
  return Ee("span", Ie({
    css: n7
  }, t));
}, Fy = r7, o7 = {
  guidance: function(t) {
    var n = t.isSearchable, r = t.isMulti, o = t.tabSelectsValue, i = t.context, s = t.isInitialFocus;
    switch (i) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(o ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, r = t.label, o = r === void 0 ? "" : r, i = t.labels, s = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(o, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(i.length > 1 ? "s" : "", " ").concat(i.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(o, " is disabled. Select another option.") : "option ".concat(o, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, r = t.focused, o = t.options, i = t.label, s = i === void 0 ? "" : i, a = t.selectValue, c = t.isDisabled, l = t.isSelected, u = t.isAppleDevice, d = function(h, g) {
      return h && h.length ? "".concat(h.indexOf(g) + 1, " of ").concat(h.length) : "";
    };
    if (n === "value" && a)
      return "value ".concat(s, " focused, ").concat(d(a, r), ".");
    if (n === "menu" && u) {
      var f = c ? " disabled" : "", p = "".concat(l ? " selected" : "").concat(f);
      return "".concat(s).concat(p, ", ").concat(d(o, r), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, r = t.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
}, i7 = function(t) {
  var n = t.ariaSelection, r = t.focusedOption, o = t.focusedValue, i = t.focusableOptions, s = t.isFocused, a = t.selectValue, c = t.selectProps, l = t.id, u = t.isAppleDevice, d = c.ariaLiveMessages, f = c.getOptionLabel, p = c.inputValue, m = c.isMulti, h = c.isOptionDisabled, g = c.isSearchable, v = c.menuIsOpen, y = c.options, x = c.screenReaderStatus, S = c.tabSelectsValue, C = c.isLoading, w = c["aria-label"], I = c["aria-live"], P = be(function() {
    return we(we({}, o7), d || {});
  }, [d]), k = be(function() {
    var ne = "";
    if (n && P.onChange) {
      var W = n.option, O = n.options, J = n.removedValue, ee = n.removedValues, H = n.value, _ = function(te) {
        return Array.isArray(te) ? null : te;
      }, j = J || W || _(H), E = j ? f(j) : "", M = O || ee || void 0, F = M ? M.map(f) : [], G = we({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: j && h(j, a),
        label: E,
        labels: F
      }, n);
      ne = P.onChange(G);
    }
    return ne;
  }, [n, P, h, a, f]), A = be(function() {
    var ne = "", W = r || o, O = !!(r && a && a.includes(r));
    if (W && P.onFocus) {
      var J = {
        focused: W,
        label: f(W),
        isDisabled: h(W, a),
        isSelected: O,
        options: i,
        context: W === r ? "menu" : "value",
        selectValue: a,
        isAppleDevice: u
      };
      ne = P.onFocus(J);
    }
    return ne;
  }, [r, o, f, h, P, i, a, u]), N = be(function() {
    var ne = "";
    if (v && y.length && !C && P.onFilter) {
      var W = x({
        count: i.length
      });
      ne = P.onFilter({
        inputValue: p,
        resultsMessage: W
      });
    }
    return ne;
  }, [i, p, v, P, y, x, C]), B = n?.action === "initial-input-focus", L = be(function() {
    var ne = "";
    if (P.guidance) {
      var W = o ? "value" : v ? "menu" : "input";
      ne = P.guidance({
        "aria-label": w,
        context: W,
        isDisabled: r && h(r, a),
        isMulti: m,
        isSearchable: g,
        tabSelectsValue: S,
        isInitialFocus: B
      });
    }
    return ne;
  }, [w, r, o, m, h, g, v, P, a, S, B]), Z = Ee(Hi, null, Ee("span", {
    id: "aria-selection"
  }, k), Ee("span", {
    id: "aria-focused"
  }, A), Ee("span", {
    id: "aria-results"
  }, N), Ee("span", {
    id: "aria-guidance"
  }, L));
  return Ee(Hi, null, Ee(Fy, {
    id: l
  }, B && Z), Ee(Fy, {
    "aria-live": I,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !B && Z));
}, s7 = i7, Lp = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}], a7 = new RegExp("[" + Lp.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), zw = {};
for (var df = 0; df < Lp.length; df++)
  for (var ff = Lp[df], pf = 0; pf < ff.letters.length; pf++)
    zw[ff.letters[pf]] = ff.base;
var Gw = function(t) {
  return t.replace(a7, function(n) {
    return zw[n];
  });
}, c7 = e7(Gw), Dy = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, l7 = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, u7 = function(t) {
  return function(n, r) {
    if (n.data.__isNew__) return !0;
    var o = we({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: l7,
      trim: !0,
      matchFrom: "any"
    }, t), i = o.ignoreCase, s = o.ignoreAccents, a = o.stringify, c = o.trim, l = o.matchFrom, u = c ? Dy(r) : r, d = c ? Dy(a(n)) : a(n);
    return i && (u = u.toLowerCase(), d = d.toLowerCase()), s && (u = c7(u), d = Gw(d)), l === "start" ? d.substr(0, u.length) === u : d.indexOf(u) > -1;
  };
}, d7 = ["innerRef"];
function f7(e) {
  var t = e.innerRef, n = Qn(e, d7), r = FY(n, "onExited", "in", "enter", "exit", "appear");
  return Ee("input", Ie({
    ref: t
  }, r, {
    css: /* @__PURE__ */ xh({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, process.env.NODE_ENV === "production" ? "" : ";label:DummyInput;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyByZW1vdmVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGlubmVyUmVmLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbnB1dCddICYge1xuICByZWFkb25seSBpbm5lclJlZjogUmVmPEhUTUxJbnB1dEVsZW1lbnQ+O1xufSkge1xuICAvLyBSZW1vdmUgYW5pbWF0aW9uIHByb3BzIG5vdCBtZWFudCBmb3IgSFRNTCBlbGVtZW50c1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0gcmVtb3ZlUHJvcHMoXG4gICAgcHJvcHMsXG4gICAgJ29uRXhpdGVkJyxcbiAgICAnaW4nLFxuICAgICdlbnRlcicsXG4gICAgJ2V4aXQnLFxuICAgICdhcHBlYXInXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8aW5wdXRcbiAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICB7Li4uZmlsdGVyZWRQcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgdGhpcyBoaWRlcyB0aGUgZmxhc2hpbmcgY3Vyc29yXG4gICAgICAgIGNhcmV0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGdyaWRBcmVhOiAnMSAvIDEgLyAyIC8gMycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSguMDEpJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}
var p7 = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function h7(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, i = e.onTopLeave, s = se(!1), a = se(!1), c = se(0), l = se(null), u = R(function(g, v) {
    if (l.current !== null) {
      var y = l.current, x = y.scrollTop, S = y.scrollHeight, C = y.clientHeight, w = l.current, I = v > 0, P = S - C - x, k = !1;
      P > v && s.current && (r && r(g), s.current = !1), I && a.current && (i && i(g), a.current = !1), I && v > P ? (n && !s.current && n(g), w.scrollTop = S, k = !0, s.current = !0) : !I && -v > x && (o && !a.current && o(g), w.scrollTop = 0, k = !0, a.current = !0), k && p7(g);
    }
  }, [n, r, o, i]), d = R(function(g) {
    u(g, g.deltaY);
  }, [u]), f = R(function(g) {
    c.current = g.changedTouches[0].clientY;
  }, []), p = R(function(g) {
    var v = c.current - g.changedTouches[0].clientY;
    u(g, v);
  }, [u]), m = R(function(g) {
    if (g) {
      var v = NY ? {
        passive: !1
      } : !1;
      g.addEventListener("wheel", d, v), g.addEventListener("touchstart", f, v), g.addEventListener("touchmove", p, v);
    }
  }, [p, f, d]), h = R(function(g) {
    g && (g.removeEventListener("wheel", d, !1), g.removeEventListener("touchstart", f, !1), g.removeEventListener("touchmove", p, !1));
  }, [p, f, d]);
  return ge(function() {
    if (t) {
      var g = l.current;
      return m(g), function() {
        h(g);
      };
    }
  }, [t, m, h]), function(g) {
    l.current = g;
  };
}
var $y = ["boxSizing", "height", "overflow", "paddingRight", "position"], Vy = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function Ly(e) {
  e.cancelable && e.preventDefault();
}
function zy(e) {
  e.stopPropagation();
}
function Gy() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function Wy() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var Hy = !!(typeof window < "u" && window.document && window.document.createElement), Is = 0, hi = {
  capture: !1,
  passive: !1
};
function m7(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = se({}), i = se(null), s = R(function(c) {
    if (Hy) {
      var l = document.body, u = l && l.style;
      if (r && $y.forEach(function(m) {
        var h = u && u[m];
        o.current[m] = h;
      }), r && Is < 1) {
        var d = parseInt(o.current.paddingRight, 10) || 0, f = document.body ? document.body.clientWidth : 0, p = window.innerWidth - f + d || 0;
        Object.keys(Vy).forEach(function(m) {
          var h = Vy[m];
          u && (u[m] = h);
        }), u && (u.paddingRight = "".concat(p, "px"));
      }
      l && Wy() && (l.addEventListener("touchmove", Ly, hi), c && (c.addEventListener("touchstart", Gy, hi), c.addEventListener("touchmove", zy, hi))), Is += 1;
    }
  }, [r]), a = R(function(c) {
    if (Hy) {
      var l = document.body, u = l && l.style;
      Is = Math.max(Is - 1, 0), r && Is < 1 && $y.forEach(function(d) {
        var f = o.current[d];
        u && (u[d] = f);
      }), l && Wy() && (l.removeEventListener("touchmove", Ly, hi), c && (c.removeEventListener("touchstart", Gy, hi), c.removeEventListener("touchmove", zy, hi)));
    }
  }, [r]);
  return ge(function() {
    if (t) {
      var c = i.current;
      return s(c), function() {
        a(c);
      };
    }
  }, [t, s, a]), function(c) {
    i.current = c;
  };
}
function g7() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var b7 = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, v7 = process.env.NODE_ENV === "production" ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: g7
};
function y7(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, i = e.onBottomArrive, s = e.onBottomLeave, a = e.onTopArrive, c = e.onTopLeave, l = h7({
    isEnabled: o,
    onBottomArrive: i,
    onBottomLeave: s,
    onTopArrive: a,
    onTopLeave: c
  }), u = m7({
    isEnabled: n
  }), d = function(p) {
    l(p), u(p);
  };
  return Ee(Hi, null, n && Ee("div", {
    onClick: b7,
    css: v7
  }), t(d));
}
function S7() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var x7 = process.env.NODE_ENV === "production" ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: S7
}, C7 = function(t) {
  var n = t.name, r = t.onFocus;
  return Ee("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: x7,
    value: "",
    onChange: function() {
    }
  });
}, I7 = C7;
function Xm(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function w7() {
  return Xm(/^iPhone/i);
}
function Ww() {
  return Xm(/^Mac/i);
}
function P7() {
  return Xm(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  Ww() && navigator.maxTouchPoints > 1;
}
function k7() {
  return w7() || P7();
}
function A7() {
  return Ww() || k7();
}
var T7 = function(t) {
  return t.label;
}, Hw = function(t) {
  return t.label;
}, jw = function(t) {
  return t.value;
}, E7 = function(t) {
  return !!t.isDisabled;
}, R7 = {
  clearIndicator: dZ,
  container: QY,
  control: vZ,
  dropdownIndicator: lZ,
  group: CZ,
  groupHeading: wZ,
  indicatorsContainer: rZ,
  indicatorSeparator: pZ,
  input: TZ,
  loadingIndicator: gZ,
  loadingMessage: ZY,
  menu: zY,
  menuList: jY,
  menuPortal: KY,
  multiValue: NZ,
  multiValueLabel: MZ,
  multiValueRemove: BZ,
  noOptionsMessage: YY,
  option: zZ,
  placeholder: HZ,
  singleValue: YZ,
  valueContainer: tZ
}, _7 = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, O7 = 4, Xw = 4, N7 = 38, M7 = Xw * 2, B7 = {
  baseUnit: Xw,
  controlHeight: N7,
  menuGutter: M7
}, hf = {
  borderRadius: O7,
  colors: _7,
  spacing: B7
}, F7 = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: Ny(),
  captureMenuScroll: !Ny(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: u7(),
  formatGroupLabel: T7,
  getOptionLabel: Hw,
  getOptionValue: jw,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: E7,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !_Y(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function jy(e, t, n, r) {
  var o = Uw(e, t, n), i = Jw(e, t, n), s = Zw(e, t), a = El(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: o,
    isSelected: i,
    label: s,
    value: a,
    index: r
  };
}
function Kc(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var o = n.options.map(function(s, a) {
        return jy(e, s, t, a);
      }).filter(function(s) {
        return Yy(e, s);
      });
      return o.length > 0 ? {
        type: "group",
        data: n,
        options: o,
        index: r
      } : void 0;
    }
    var i = jy(e, n, t, r);
    return Yy(e, i) ? i : void 0;
  }).filter(MY);
}
function Yw(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, zi(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function Xy(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, zi(r.options.map(function(o) {
      return {
        data: o.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function D7(e, t) {
  return Yw(Kc(e, t));
}
function Yy(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, i = t.isSelected, s = t.label, a = t.value;
  return (!qw(e) || !i) && Kw(e, {
    label: s,
    value: a,
    data: o
  }, r);
}
function $7(e, t) {
  var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
  if (o > -1) {
    var i = t.indexOf(n);
    if (i > -1)
      return n;
    if (o < t.length)
      return t[o];
  }
  return null;
}
function V7(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var mf = function(t, n) {
  var r, o = (r = t.find(function(i) {
    return i.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return o || null;
}, Zw = function(t, n) {
  return t.getOptionLabel(n);
}, El = function(t, n) {
  return t.getOptionValue(n);
};
function Uw(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function Jw(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = El(e, t);
  return n.some(function(o) {
    return El(e, o) === r;
  });
}
function Kw(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var qw = function(t) {
  var n = t.hideSelectedOptions, r = t.isMulti;
  return n === void 0 ? r : n;
}, L7 = 1, $a = /* @__PURE__ */ (function(e) {
  eY(n, e);
  var t = rY(n);
  function n(r) {
    var o;
    if (q6(this, n), o = t.call(this, r), o.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.isAppleDevice = A7(), o.controlRef = null, o.getControlRef = function(c) {
      o.controlRef = c;
    }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(c) {
      o.focusedOptionRef = c;
    }, o.menuListRef = null, o.getMenuListRef = function(c) {
      o.menuListRef = c;
    }, o.inputRef = null, o.getInputRef = function(c) {
      o.inputRef = c;
    }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(c, l) {
      var u = o.props, d = u.onChange, f = u.name;
      l.name = f, o.ariaOnChange(c, l), d(c, l);
    }, o.setValue = function(c, l, u) {
      var d = o.props, f = d.closeMenuOnSelect, p = d.isMulti, m = d.inputValue;
      o.onInputChange("", {
        action: "set-value",
        prevInputValue: m
      }), f && (o.setState({
        inputIsHiddenAfterUpdate: !p
      }), o.onMenuClose()), o.setState({
        clearFocusValueOnUpdate: !0
      }), o.onChange(c, {
        action: l,
        option: u
      });
    }, o.selectOption = function(c) {
      var l = o.props, u = l.blurInputOnSelect, d = l.isMulti, f = l.name, p = o.state.selectValue, m = d && o.isOptionSelected(c, p), h = o.isOptionDisabled(c, p);
      if (m) {
        var g = o.getOptionValue(c);
        o.setValue(p.filter(function(v) {
          return o.getOptionValue(v) !== g;
        }), "deselect-option", c);
      } else if (!h)
        d ? o.setValue([].concat(zi(p), [c]), "select-option", c) : o.setValue(c, "select-option");
      else {
        o.ariaOnChange(c, {
          action: "select-option",
          option: c,
          name: f
        });
        return;
      }
      u && o.blurInput();
    }, o.removeValue = function(c) {
      var l = o.props.isMulti, u = o.state.selectValue, d = o.getOptionValue(c), f = u.filter(function(m) {
        return o.getOptionValue(m) !== d;
      }), p = Fs(l, f, f[0] || null);
      o.onChange(p, {
        action: "remove-value",
        removedValue: c
      }), o.focusInput();
    }, o.clearValue = function() {
      var c = o.state.selectValue;
      o.onChange(Fs(o.props.isMulti, [], null), {
        action: "clear",
        removedValues: c
      });
    }, o.popValue = function() {
      var c = o.props.isMulti, l = o.state.selectValue, u = l[l.length - 1], d = l.slice(0, l.length - 1), f = Fs(c, d, d[0] || null);
      u && o.onChange(f, {
        action: "pop-value",
        removedValue: u
      });
    }, o.getFocusedOptionId = function(c) {
      return mf(o.state.focusableOptionsWithIds, c);
    }, o.getFocusableOptionsWithIds = function() {
      return Xy(Kc(o.props, o.state.selectValue), o.getElementId("option"));
    }, o.getValue = function() {
      return o.state.selectValue;
    }, o.cx = function() {
      for (var c = arguments.length, l = new Array(c), u = 0; u < c; u++)
        l[u] = arguments[u];
      return PY.apply(void 0, [o.props.classNamePrefix].concat(l));
    }, o.getOptionLabel = function(c) {
      return Zw(o.props, c);
    }, o.getOptionValue = function(c) {
      return El(o.props, c);
    }, o.getStyles = function(c, l) {
      var u = o.props.unstyled, d = R7[c](l, u);
      d.boxSizing = "border-box";
      var f = o.props.styles[c];
      return f ? f(d, l) : d;
    }, o.getClassNames = function(c, l) {
      var u, d;
      return (u = (d = o.props.classNames)[c]) === null || u === void 0 ? void 0 : u.call(d, l);
    }, o.getElementId = function(c) {
      return "".concat(o.state.instancePrefix, "-").concat(c);
    }, o.getComponents = function() {
      return KZ(o.props);
    }, o.buildCategorizedOptions = function() {
      return Kc(o.props, o.state.selectValue);
    }, o.getCategorizedOptions = function() {
      return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
    }, o.buildFocusableOptions = function() {
      return Yw(o.buildCategorizedOptions());
    }, o.getFocusableOptions = function() {
      return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
    }, o.ariaOnChange = function(c, l) {
      o.setState({
        ariaSelection: we({
          value: c
        }, l)
      });
    }, o.onMenuMouseDown = function(c) {
      c.button === 0 && (c.stopPropagation(), c.preventDefault(), o.focusInput());
    }, o.onMenuMouseMove = function(c) {
      o.blockOptionHover = !1;
    }, o.onControlMouseDown = function(c) {
      if (!c.defaultPrevented) {
        var l = o.props.openMenuOnClick;
        o.state.isFocused ? o.props.menuIsOpen ? c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && o.onMenuClose() : l && o.openMenu("first") : (l && (o.openAfterFocus = !0), o.focusInput()), c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && c.preventDefault();
      }
    }, o.onDropdownIndicatorMouseDown = function(c) {
      if (!(c && c.type === "mousedown" && c.button !== 0) && !o.props.isDisabled) {
        var l = o.props, u = l.isMulti, d = l.menuIsOpen;
        o.focusInput(), d ? (o.setState({
          inputIsHiddenAfterUpdate: !u
        }), o.onMenuClose()) : o.openMenu("first"), c.preventDefault();
      }
    }, o.onClearIndicatorMouseDown = function(c) {
      c && c.type === "mousedown" && c.button !== 0 || (o.clearValue(), c.preventDefault(), o.openAfterFocus = !1, c.type === "touchend" ? o.focusInput() : setTimeout(function() {
        return o.focusInput();
      }));
    }, o.onScroll = function(c) {
      typeof o.props.closeMenuOnScroll == "boolean" ? c.target instanceof HTMLElement && Tu(c.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(c) && o.props.onMenuClose();
    }, o.onCompositionStart = function() {
      o.isComposing = !0;
    }, o.onCompositionEnd = function() {
      o.isComposing = !1;
    }, o.onTouchStart = function(c) {
      var l = c.touches, u = l && l.item(0);
      u && (o.initialTouchX = u.clientX, o.initialTouchY = u.clientY, o.userIsDragging = !1);
    }, o.onTouchMove = function(c) {
      var l = c.touches, u = l && l.item(0);
      if (u) {
        var d = Math.abs(u.clientX - o.initialTouchX), f = Math.abs(u.clientY - o.initialTouchY), p = 5;
        o.userIsDragging = d > p || f > p;
      }
    }, o.onTouchEnd = function(c) {
      o.userIsDragging || (o.controlRef && !o.controlRef.contains(c.target) && o.menuListRef && !o.menuListRef.contains(c.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
    }, o.onControlTouchEnd = function(c) {
      o.userIsDragging || o.onControlMouseDown(c);
    }, o.onClearIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onClearIndicatorMouseDown(c);
    }, o.onDropdownIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onDropdownIndicatorMouseDown(c);
    }, o.handleInputChange = function(c) {
      var l = o.props.inputValue, u = c.currentTarget.value;
      o.setState({
        inputIsHiddenAfterUpdate: !1
      }), o.onInputChange(u, {
        action: "input-change",
        prevInputValue: l
      }), o.props.menuIsOpen || o.onMenuOpen();
    }, o.onInputFocus = function(c) {
      o.props.onFocus && o.props.onFocus(c), o.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
    }, o.onInputBlur = function(c) {
      var l = o.props.inputValue;
      if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
        o.inputRef.focus();
        return;
      }
      o.props.onBlur && o.props.onBlur(c), o.onInputChange("", {
        action: "input-blur",
        prevInputValue: l
      }), o.onMenuClose(), o.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, o.onOptionHover = function(c) {
      if (!(o.blockOptionHover || o.state.focusedOption === c)) {
        var l = o.getFocusableOptions(), u = l.indexOf(c);
        o.setState({
          focusedOption: c,
          focusedOptionId: u > -1 ? o.getFocusedOptionId(c) : null
        });
      }
    }, o.shouldHideSelectedOptions = function() {
      return qw(o.props);
    }, o.onValueInputFocus = function(c) {
      c.preventDefault(), c.stopPropagation(), o.focus();
    }, o.onKeyDown = function(c) {
      var l = o.props, u = l.isMulti, d = l.backspaceRemovesValue, f = l.escapeClearsValue, p = l.inputValue, m = l.isClearable, h = l.isDisabled, g = l.menuIsOpen, v = l.onKeyDown, y = l.tabSelectsValue, x = l.openMenuOnFocus, S = o.state, C = S.focusedOption, w = S.focusedValue, I = S.selectValue;
      if (!h && !(typeof v == "function" && (v(c), c.defaultPrevented))) {
        switch (o.blockOptionHover = !0, c.key) {
          case "ArrowLeft":
            if (!u || p) return;
            o.focusValue("previous");
            break;
          case "ArrowRight":
            if (!u || p) return;
            o.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (p) return;
            if (w)
              o.removeValue(w);
            else {
              if (!d) return;
              u ? o.popValue() : m && o.clearValue();
            }
            break;
          case "Tab":
            if (o.isComposing || c.shiftKey || !g || !y || !C || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            x && o.isOptionSelected(C, I))
              return;
            o.selectOption(C);
            break;
          case "Enter":
            if (c.keyCode === 229)
              break;
            if (g) {
              if (!C || o.isComposing) return;
              o.selectOption(C);
              break;
            }
            return;
          case "Escape":
            g ? (o.setState({
              inputIsHiddenAfterUpdate: !1
            }), o.onInputChange("", {
              action: "menu-close",
              prevInputValue: p
            }), o.onMenuClose()) : m && f && o.clearValue();
            break;
          case " ":
            if (p)
              return;
            if (!g) {
              o.openMenu("first");
              break;
            }
            if (!C) return;
            o.selectOption(C);
            break;
          case "ArrowUp":
            g ? o.focusOption("up") : o.openMenu("last");
            break;
          case "ArrowDown":
            g ? o.focusOption("down") : o.openMenu("first");
            break;
          case "PageUp":
            if (!g) return;
            o.focusOption("pageup");
            break;
          case "PageDown":
            if (!g) return;
            o.focusOption("pagedown");
            break;
          case "Home":
            if (!g) return;
            o.focusOption("first");
            break;
          case "End":
            if (!g) return;
            o.focusOption("last");
            break;
          default:
            return;
        }
        c.preventDefault();
      }
    }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++L7), o.state.selectValue = Al(r.value), r.menuIsOpen && o.state.selectValue.length) {
      var i = o.getFocusableOptionsWithIds(), s = o.buildFocusableOptions(), a = s.indexOf(o.state.selectValue[0]);
      o.state.focusableOptionsWithIds = i, o.state.focusedOption = s[a], o.state.focusedOptionId = mf(i, s[a]);
    }
    return o;
  }
  return Q6(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Oy(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      var i = this.props, s = i.isDisabled, a = i.menuIsOpen, c = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (c && !s && o.isDisabled || // ensure focus is on the Input when the menu opens
      c && a && !o.menuIsOpen) && this.focusInput(), c && s && !o.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !c && !s && o.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Oy(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(o, i) {
      this.props.onInputChange(o, i);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(o) {
      var i = this, s = this.state, a = s.selectValue, c = s.isFocused, l = this.buildFocusableOptions(), u = o === "first" ? 0 : l.length - 1;
      if (!this.props.isMulti) {
        var d = l.indexOf(a[0]);
        d > -1 && (u = d);
      }
      this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: l[u],
        focusedOptionId: this.getFocusedOptionId(l[u])
      }, function() {
        return i.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(o) {
      var i = this.state, s = i.selectValue, a = i.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var c = s.indexOf(a);
        a || (c = -1);
        var l = s.length - 1, u = -1;
        if (s.length) {
          switch (o) {
            case "previous":
              c === 0 ? u = 0 : c === -1 ? u = l : u = c - 1;
              break;
            case "next":
              c > -1 && c < l && (u = c + 1);
              break;
          }
          this.setState({
            inputIsHidden: u !== -1,
            focusedValue: s[u]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", i = this.props.pageSize, s = this.state.focusedOption, a = this.getFocusableOptions();
      if (a.length) {
        var c = 0, l = a.indexOf(s);
        s || (l = -1), o === "up" ? c = l > 0 ? l - 1 : a.length - 1 : o === "down" ? c = (l + 1) % a.length : o === "pageup" ? (c = l - i, c < 0 && (c = 0)) : o === "pagedown" ? (c = l + i, c > a.length - 1 && (c = a.length - 1)) : o === "last" && (c = a.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: a[c],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(a[c])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(hf) : we(we({}, hf), this.props.theme) : hf;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var o = this.clearValue, i = this.cx, s = this.getStyles, a = this.getClassNames, c = this.getValue, l = this.selectOption, u = this.setValue, d = this.props, f = d.isMulti, p = d.isRtl, m = d.options, h = this.hasValue();
      return {
        clearValue: o,
        cx: i,
        getStyles: s,
        getClassNames: a,
        getValue: c,
        hasValue: h,
        isMulti: f,
        isRtl: p,
        options: m,
        selectOption: l,
        selectProps: d,
        setValue: u,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var o = this.state.selectValue;
      return o.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var o = this.props, i = o.isClearable, s = o.isMulti;
      return i === void 0 ? s : i;
    }
  }, {
    key: "isOptionDisabled",
    value: function(o, i) {
      return Uw(this.props, o, i);
    }
  }, {
    key: "isOptionSelected",
    value: function(o, i) {
      return Jw(this.props, o, i);
    }
  }, {
    key: "filterOption",
    value: function(o, i) {
      return Kw(this.props, o, i);
    }
  }, {
    key: "formatOptionLabel",
    value: function(o, i) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, a = this.state.selectValue;
        return this.props.formatOptionLabel(o, {
          context: i,
          inputValue: s,
          selectValue: a
        });
      } else
        return this.getOptionLabel(o);
    }
  }, {
    key: "formatGroupLabel",
    value: function(o) {
      return this.props.formatGroupLabel(o);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var o = this.props, i = o.isDisabled, s = o.isSearchable, a = o.inputId, c = o.inputValue, l = o.tabIndex, u = o.form, d = o.menuIsOpen, f = o.required, p = this.getComponents(), m = p.Input, h = this.state, g = h.inputIsHidden, v = h.ariaSelection, y = this.commonProps, x = a || this.getElementId("input"), S = we(we(we({
          "aria-autocomplete": "list",
          "aria-expanded": d,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": f,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, d && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? v?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ ie.createElement(m, Ie({}, y, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: x,
          innerRef: this.getInputRef,
          isDisabled: i,
          isHidden: g,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: l,
          form: u,
          type: "text",
          value: c
        }, S)) : /* @__PURE__ */ ie.createElement(f7, Ie({
          id: x,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: kl,
          onFocus: this.onInputFocus,
          disabled: i,
          tabIndex: l,
          inputMode: "none",
          form: u,
          value: ""
        }, S));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var o = this, i = this.getComponents(), s = i.MultiValue, a = i.MultiValueContainer, c = i.MultiValueLabel, l = i.MultiValueRemove, u = i.SingleValue, d = i.Placeholder, f = this.commonProps, p = this.props, m = p.controlShouldRenderValue, h = p.isDisabled, g = p.isMulti, v = p.inputValue, y = p.placeholder, x = this.state, S = x.selectValue, C = x.focusedValue, w = x.isFocused;
      if (!this.hasValue() || !m)
        return v ? null : /* @__PURE__ */ ie.createElement(d, Ie({}, f, {
          key: "placeholder",
          isDisabled: h,
          isFocused: w,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), y);
      if (g)
        return S.map(function(P, k) {
          var A = P === C, N = "".concat(o.getOptionLabel(P), "-").concat(o.getOptionValue(P));
          return /* @__PURE__ */ ie.createElement(s, Ie({}, f, {
            components: {
              Container: a,
              Label: c,
              Remove: l
            },
            isFocused: A,
            isDisabled: h,
            key: N,
            index: k,
            removeProps: {
              onClick: function() {
                return o.removeValue(P);
              },
              onTouchEnd: function() {
                return o.removeValue(P);
              },
              onMouseDown: function(L) {
                L.preventDefault();
              }
            },
            data: P
          }), o.formatOptionLabel(P, "value"));
        });
      if (v)
        return null;
      var I = S[0];
      return /* @__PURE__ */ ie.createElement(u, Ie({}, f, {
        data: I,
        isDisabled: h
      }), this.formatOptionLabel(I, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var o = this.getComponents(), i = o.ClearIndicator, s = this.commonProps, a = this.props, c = a.isDisabled, l = a.isLoading, u = this.state.isFocused;
      if (!this.isClearable() || !i || c || !this.hasValue() || l)
        return null;
      var d = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ ie.createElement(i, Ie({}, s, {
        innerProps: d,
        isFocused: u
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var o = this.getComponents(), i = o.LoadingIndicator, s = this.commonProps, a = this.props, c = a.isDisabled, l = a.isLoading, u = this.state.isFocused;
      if (!i || !l) return null;
      var d = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ ie.createElement(i, Ie({}, s, {
        innerProps: d,
        isDisabled: c,
        isFocused: u
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var o = this.getComponents(), i = o.DropdownIndicator, s = o.IndicatorSeparator;
      if (!i || !s) return null;
      var a = this.commonProps, c = this.props.isDisabled, l = this.state.isFocused;
      return /* @__PURE__ */ ie.createElement(s, Ie({}, a, {
        isDisabled: c,
        isFocused: l
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var o = this.getComponents(), i = o.DropdownIndicator;
      if (!i) return null;
      var s = this.commonProps, a = this.props.isDisabled, c = this.state.isFocused, l = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ ie.createElement(i, Ie({}, s, {
        innerProps: l,
        isDisabled: a,
        isFocused: c
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var o = this, i = this.getComponents(), s = i.Group, a = i.GroupHeading, c = i.Menu, l = i.MenuList, u = i.MenuPortal, d = i.LoadingMessage, f = i.NoOptionsMessage, p = i.Option, m = this.commonProps, h = this.state.focusedOption, g = this.props, v = g.captureMenuScroll, y = g.inputValue, x = g.isLoading, S = g.loadingMessage, C = g.minMenuHeight, w = g.maxMenuHeight, I = g.menuIsOpen, P = g.menuPlacement, k = g.menuPosition, A = g.menuPortalTarget, N = g.menuShouldBlockScroll, B = g.menuShouldScrollIntoView, L = g.noOptionsMessage, Z = g.onMenuScrollToTop, ne = g.onMenuScrollToBottom;
      if (!I) return null;
      var W = function(E, M) {
        var F = E.type, G = E.data, q = E.isDisabled, te = E.isSelected, U = E.label, K = E.value, ae = h === G, Y = q ? void 0 : function() {
          return o.onOptionHover(G);
        }, ce = q ? void 0 : function() {
          return o.selectOption(G);
        }, re = "".concat(o.getElementId("option"), "-").concat(M), Ce = {
          id: re,
          onClick: ce,
          onMouseMove: Y,
          onMouseOver: Y,
          tabIndex: -1,
          role: "option",
          "aria-selected": o.isAppleDevice ? void 0 : te
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ ie.createElement(p, Ie({}, m, {
          innerProps: Ce,
          data: G,
          isDisabled: q,
          isSelected: te,
          key: re,
          label: U,
          type: F,
          value: K,
          isFocused: ae,
          innerRef: ae ? o.getFocusedOptionRef : void 0
        }), o.formatOptionLabel(E.data, "menu"));
      }, O;
      if (this.hasOptions())
        O = this.getCategorizedOptions().map(function(j) {
          if (j.type === "group") {
            var E = j.data, M = j.options, F = j.index, G = "".concat(o.getElementId("group"), "-").concat(F), q = "".concat(G, "-heading");
            return /* @__PURE__ */ ie.createElement(s, Ie({}, m, {
              key: G,
              data: E,
              options: M,
              Heading: a,
              headingProps: {
                id: q,
                data: j.data
              },
              label: o.formatGroupLabel(j.data)
            }), j.options.map(function(te) {
              return W(te, "".concat(F, "-").concat(te.index));
            }));
          } else if (j.type === "option")
            return W(j, "".concat(j.index));
        });
      else if (x) {
        var J = S({
          inputValue: y
        });
        if (J === null) return null;
        O = /* @__PURE__ */ ie.createElement(d, m, J);
      } else {
        var ee = L({
          inputValue: y
        });
        if (ee === null) return null;
        O = /* @__PURE__ */ ie.createElement(f, m, ee);
      }
      var H = {
        minMenuHeight: C,
        maxMenuHeight: w,
        menuPlacement: P,
        menuPosition: k,
        menuShouldScrollIntoView: B
      }, _ = /* @__PURE__ */ ie.createElement(GY, Ie({}, m, H), function(j) {
        var E = j.ref, M = j.placerProps, F = M.placement, G = M.maxHeight;
        return /* @__PURE__ */ ie.createElement(c, Ie({}, m, H, {
          innerRef: E,
          innerProps: {
            onMouseDown: o.onMenuMouseDown,
            onMouseMove: o.onMenuMouseMove
          },
          isLoading: x,
          placement: F
        }), /* @__PURE__ */ ie.createElement(y7, {
          captureEnabled: v,
          onTopArrive: Z,
          onBottomArrive: ne,
          lockEnabled: N
        }, function(q) {
          return /* @__PURE__ */ ie.createElement(l, Ie({}, m, {
            innerRef: function(U) {
              o.getMenuListRef(U), q(U);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": m.isMulti,
              id: o.getElementId("listbox")
            },
            isLoading: x,
            maxHeight: G,
            focusedOption: h
          }), O);
        }));
      });
      return A || k === "fixed" ? /* @__PURE__ */ ie.createElement(u, Ie({}, m, {
        appendTo: A,
        controlElement: this.controlRef,
        menuPlacement: P,
        menuPosition: k
      }), _) : _;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var o = this, i = this.props, s = i.delimiter, a = i.isDisabled, c = i.isMulti, l = i.name, u = i.required, d = this.state.selectValue;
      if (u && !this.hasValue() && !a)
        return /* @__PURE__ */ ie.createElement(I7, {
          name: l,
          onFocus: this.onValueInputFocus
        });
      if (!(!l || a))
        if (c)
          if (s) {
            var f = d.map(function(h) {
              return o.getOptionValue(h);
            }).join(s);
            return /* @__PURE__ */ ie.createElement("input", {
              name: l,
              type: "hidden",
              value: f
            });
          } else {
            var p = d.length > 0 ? d.map(function(h, g) {
              return /* @__PURE__ */ ie.createElement("input", {
                key: "i-".concat(g),
                name: l,
                type: "hidden",
                value: o.getOptionValue(h)
              });
            }) : /* @__PURE__ */ ie.createElement("input", {
              name: l,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ ie.createElement("div", null, p);
          }
        else {
          var m = d[0] ? this.getOptionValue(d[0]) : "";
          return /* @__PURE__ */ ie.createElement("input", {
            name: l,
            type: "hidden",
            value: m
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var o = this.commonProps, i = this.state, s = i.ariaSelection, a = i.focusedOption, c = i.focusedValue, l = i.isFocused, u = i.selectValue, d = this.getFocusableOptions();
      return /* @__PURE__ */ ie.createElement(s7, Ie({}, o, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: a,
        focusedValue: c,
        isFocused: l,
        selectValue: u,
        focusableOptions: d,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var o = this.getComponents(), i = o.Control, s = o.IndicatorsContainer, a = o.SelectContainer, c = o.ValueContainer, l = this.props, u = l.className, d = l.id, f = l.isDisabled, p = l.menuIsOpen, m = this.state.isFocused, h = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ ie.createElement(a, Ie({}, h, {
        className: u,
        innerProps: {
          id: d,
          onKeyDown: this.onKeyDown
        },
        isDisabled: f,
        isFocused: m
      }), this.renderLiveRegion(), /* @__PURE__ */ ie.createElement(i, Ie({}, h, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: f,
        isFocused: m,
        menuIsOpen: p
      }), /* @__PURE__ */ ie.createElement(c, Ie({}, h, {
        isDisabled: f
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ ie.createElement(s, Ie({}, h, {
        isDisabled: f
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, i) {
      var s = i.prevProps, a = i.clearFocusValueOnUpdate, c = i.inputIsHiddenAfterUpdate, l = i.ariaSelection, u = i.isFocused, d = i.prevWasFocused, f = i.instancePrefix, p = o.options, m = o.value, h = o.menuIsOpen, g = o.inputValue, v = o.isMulti, y = Al(m), x = {};
      if (s && (m !== s.value || p !== s.options || h !== s.menuIsOpen || g !== s.inputValue)) {
        var S = h ? D7(o, y) : [], C = h ? Xy(Kc(o, y), "".concat(f, "-option")) : [], w = a ? $7(i, y) : null, I = V7(i, S), P = mf(C, I);
        x = {
          selectValue: y,
          focusedOption: I,
          focusedOptionId: P,
          focusableOptionsWithIds: C,
          focusedValue: w,
          clearFocusValueOnUpdate: !1
        };
      }
      var k = c != null && o !== s ? {
        inputIsHidden: c,
        inputIsHiddenAfterUpdate: void 0
      } : {}, A = l, N = u && d;
      return u && !N && (A = {
        value: Fs(v, y, y[0] || null),
        options: y,
        action: "initial-input-focus"
      }, N = !d), l?.action === "initial-input-focus" && (A = null), we(we(we({}, x), k), {}, {
        prevProps: o,
        ariaSelection: A,
        prevWasFocused: N
      });
    }
  }]), n;
})(tA);
$a.defaultProps = F7;
var z7 = /* @__PURE__ */ _t(function(e, t) {
  var n = ku(e);
  return /* @__PURE__ */ ie.createElement($a, Ie({
    ref: t
  }, n));
}), G7 = z7, W7 = ["allowCreateWhileLoading", "createOptionPosition", "formatCreateLabel", "isValidNewOption", "getNewOptionData", "onCreateOption", "options", "onChange"], Zy = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, o = String(t).toLowerCase(), i = String(r.getOptionValue(n)).toLowerCase(), s = String(r.getOptionLabel(n)).toLowerCase();
  return i === o || s === o;
}, gf = {
  formatCreateLabel: function(t) {
    return 'Create "'.concat(t, '"');
  },
  isValidNewOption: function(t, n, r, o) {
    return !(!t || n.some(function(i) {
      return Zy(t, i, o);
    }) || r.some(function(i) {
      return Zy(t, i, o);
    }));
  },
  getNewOptionData: function(t, n) {
    return {
      label: n,
      value: t,
      __isNew__: !0
    };
  }
};
function Qw(e) {
  var t = e.allowCreateWhileLoading, n = t === void 0 ? !1 : t, r = e.createOptionPosition, o = r === void 0 ? "last" : r, i = e.formatCreateLabel, s = i === void 0 ? gf.formatCreateLabel : i, a = e.isValidNewOption, c = a === void 0 ? gf.isValidNewOption : a, l = e.getNewOptionData, u = l === void 0 ? gf.getNewOptionData : l, d = e.onCreateOption, f = e.options, p = f === void 0 ? [] : f, m = e.onChange, h = Qn(e, W7), g = h.getOptionValue, v = g === void 0 ? jw : g, y = h.getOptionLabel, x = y === void 0 ? Hw : y, S = h.inputValue, C = h.isLoading, w = h.isMulti, I = h.value, P = h.name, k = be(function() {
    return c(S, Al(I), p, {
      getOptionValue: v,
      getOptionLabel: x
    }) ? u(S, s(S)) : void 0;
  }, [s, u, x, v, S, c, p, I]), A = be(function() {
    return (n || !C) && k ? o === "first" ? [k].concat(zi(p)) : [].concat(zi(p), [k]) : p;
  }, [n, o, C, k, p]), N = R(function(B, L) {
    if (L.action !== "select-option")
      return m(B, L);
    var Z = Array.isArray(B) ? B : [B];
    if (Z[Z.length - 1] === k) {
      if (d) d(S);
      else {
        var ne = u(S, S), W = {
          action: "create-option",
          name: P,
          option: ne
        };
        m(Fs(w, [].concat(zi(Al(I)), [ne]), ne), W);
      }
      return;
    }
    m(B, L);
  }, [u, S, w, P, k, d, m, I]);
  return we(we({}, h), {}, {
    options: A,
    onChange: N
  });
}
var H7 = /* @__PURE__ */ _t(function(e, t) {
  var n = ku(e), r = Qw(n);
  return /* @__PURE__ */ ie.createElement($a, Ie({
    ref: t
  }, r));
}), j7 = H7, X7 = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
function eP(e) {
  var t = e.defaultOptions, n = t === void 0 ? !1 : t, r = e.cacheOptions, o = r === void 0 ? !1 : r, i = e.loadOptions;
  e.options;
  var s = e.isLoading, a = s === void 0 ? !1 : s, c = e.onInputChange, l = e.filterOption, u = l === void 0 ? null : l, d = Qn(e, X7), f = d.inputValue, p = se(void 0), m = se(!1), h = ue(Array.isArray(n) ? n : void 0), g = Ht(h, 2), v = g[0], y = g[1], x = ue(typeof f < "u" ? f : ""), S = Ht(x, 2), C = S[0], w = S[1], I = ue(n === !0), P = Ht(I, 2), k = P[0], A = P[1], N = ue(void 0), B = Ht(N, 2), L = B[0], Z = B[1], ne = ue([]), W = Ht(ne, 2), O = W[0], J = W[1], ee = ue(!1), H = Ht(ee, 2), _ = H[0], j = H[1], E = ue({}), M = Ht(E, 2), F = M[0], G = M[1], q = ue(void 0), te = Ht(q, 2), U = te[0], K = te[1], ae = ue(void 0), Y = Ht(ae, 2), ce = Y[0], re = Y[1];
  o !== ce && (G({}), re(o)), n !== U && (y(Array.isArray(n) ? n : void 0), K(n)), ge(function() {
    return m.current = !0, function() {
      m.current = !1;
    };
  }, []);
  var Ce = R(function(Pe, ve) {
    if (!i) return ve();
    var he = i(Pe, ve);
    he && typeof he.then == "function" && he.then(ve, function() {
      return ve();
    });
  }, [i]);
  ge(function() {
    n === !0 && Ce(C, function(Pe) {
      m.current && (y(Pe || []), A(!!p.current));
    });
  }, []);
  var Ve = R(function(Pe, ve) {
    var he = kY(Pe, ve, c);
    if (!he) {
      p.current = void 0, w(""), Z(""), J([]), A(!1), j(!1);
      return;
    }
    if (o && F[he])
      w(he), Z(he), J(F[he]), A(!1), j(!1);
    else {
      var _e = p.current = {};
      w(he), A(!0), j(!L), Ce(he, function(Oe) {
        m && _e === p.current && (p.current = void 0, A(!1), Z(he), J(Oe || []), j(!1), G(Oe ? we(we({}, F), {}, Ao({}, he, Oe)) : F));
      });
    }
  }, [o, Ce, L, F, c]), le = _ ? [] : C && L ? O : v || [];
  return we(we({}, d), {}, {
    options: le,
    isLoading: k || a,
    onInputChange: Ve,
    filterOption: u
  });
}
var Y7 = /* @__PURE__ */ _t(function(e, t) {
  var n = eP(e), r = ku(n);
  return /* @__PURE__ */ ie.createElement($a, Ie({
    ref: t
  }, r));
}), Z7 = Y7, U7 = /* @__PURE__ */ _t(function(e, t) {
  var n = eP(e), r = ku(n), o = Qw(r);
  return /* @__PURE__ */ ie.createElement($a, Ie({
    ref: t
  }, o));
}), J7 = U7, tP = (e) => {
  let { className: t, clearValue: n, cx: r, getStyles: o, getClassNames: i, getValue: s, hasValue: a, isMulti: c, isRtl: l, options: u, selectOption: d, selectProps: f, setValue: p, theme: m, ...h } = e;
  return { ...h };
}, K7 = (e) => typeof e == "string" && ["sm", "md", "lg"].includes(e), q7 = (e) => K7(e) ? e : e === "xs" ? "sm" : e === "xl" ? "lg" : "md", er = (e) => {
  let t = bn(), n = q7(t.components.Input.defaultProps.size), r = e ?? n;
  return f3(typeof r == "string" ? [r] : r, { fallback: "md" }) || n;
}, Q7 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, isDisabled: i, isRtl: s, hasValue: a, selectProps: { chakraStyles: c } } = e, l = { position: "relative", direction: s ? "rtl" : void 0, ...i ? { cursor: "not-allowed" } : {} }, u = c != null && c.container ? c.container(l, e) : l;
  return b(Rt, { ...o, className: r({ "--is-disabled": i, "--is-rtl": s, "--has-value": a }, n), sx: u, children: t });
}, e8 = (e) => {
  let { children: t, className: n, cx: r, isMulti: o, hasValue: i, innerProps: s, selectProps: { chakraStyles: a, size: c, variant: l, focusBorderColor: u, errorBorderColor: d, controlShouldRenderValue: f } } = e, p = er(c), m = We("Input", { size: p, variant: l, focusBorderColor: u, errorBorderColor: d }), h = { display: o && i && f ? "flex" : "grid", alignItems: "center", flex: 1, paddingY: "2px", paddingX: m.field.px, flexWrap: "wrap", WebkitOverflowScrolling: "touch", position: "relative", overflow: "hidden" }, g = a != null && a.valueContainer ? a.valueContainer(h, e) : h;
  return b(Rt, { ...s, className: r({ "value-container": !0, "value-container--is-multi": o, "value-container--has-value": i }, n), sx: g, children: t });
}, t8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i } } = e, s = { display: "flex", alignItems: "center", alignSelf: "stretch", flexShrink: 0 }, a = i != null && i.indicatorsContainer ? i.indicatorsContainer(s, e) : s;
  return b(Rt, { ...o, className: r({ indicators: !0 }, n), sx: a, children: t });
}, n8 = (e) => {
  let { className: t, cx: n, children: r, innerRef: o, innerProps: i, isDisabled: s, isFocused: a, menuIsOpen: c, selectProps: { chakraStyles: l, size: u, variant: d, focusBorderColor: f, errorBorderColor: p, isInvalid: m, isReadOnly: h } } = e, g = er(u), { field: { height: v, h: y, ...x } } = We("Input", { size: g, variant: d, focusBorderColor: f, errorBorderColor: p }), S = { ...x, position: "relative", display: "flex", alignItems: "center", justifyContent: "space-between", flexWrap: "wrap", padding: 0, overflow: "hidden", height: "auto", minH: v || y, ...s ? { pointerEvents: "none" } : {} }, C = l != null && l.control ? l.control(S, e) : S;
  return b(Rt, { ref: o, className: n({ control: !0, "control--is-disabled": s, "control--is-focused": a, "control--menu-is-open": c }, t), sx: C, ...i, "data-focus": a ? !0 : void 0, "data-focus-visible": a ? !0 : void 0, "data-invalid": m ? !0 : void 0, "data-disabled": s ? !0 : void 0, "data-readonly": h ? !0 : void 0, children: r });
}, r8 = (e) => {
  let { className: t, cx: n, selectProps: { chakraStyles: r, useBasicStyles: o, variant: i } } = e, s = { opacity: 1, ...o || i !== "outline" ? { display: "none" } : {} }, a = r != null && r.indicatorSeparator ? r.indicatorSeparator(s, e) : s;
  return b(zx, { className: n({ "indicator-separator": !0 }, t), sx: a, orientation: "vertical" });
}, o8 = (e) => b(It, { role: "presentation", focusable: "false", "aria-hidden": "true", ...e, children: b("path", { fill: "currentColor", d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z" }) }), i8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i, useBasicStyles: s, size: a, focusBorderColor: c, errorBorderColor: l, variant: u } } = e, d = er(a), f = We("Input", { size: d, variant: u, focusBorderColor: c, errorBorderColor: l }), p = { sm: "16px", md: "20px", lg: "24px" }[d], m = { ...f.addon, display: "flex", alignItems: "center", justifyContent: "center", height: "100%", borderRadius: 0, borderWidth: 0, fontSize: p, ...s && { background: "transparent", padding: 0, width: 6, marginRight: 2, marginLeft: 1, cursor: "inherit" } }, h = i != null && i.dropdownIndicator ? i.dropdownIndicator(m, e) : m, g = { height: "1em", width: "1em" }, v = i != null && i.downChevron ? i.downChevron(g, e) : g;
  return b(Rt, { ...o, className: r({ indicator: !0, "dropdown-indicator": !0 }, n), sx: h, children: t || b(o8, { sx: v }) });
}, s8 = (e) => b(It, { focusable: "false", "aria-hidden": !0, ...e, children: b("path", { fill: "currentColor", d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z" }) }), a8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i, size: s } } = e, a = er(s), c = { ...Gt("CloseButton", { size: a }), marginX: 1, display: "flex", alignItems: "center", justifyContent: "center", flexShrink: 0, cursor: "pointer" }, l = i != null && i.clearIndicator ? i.clearIndicator(c, e) : c, u = { width: "1em", height: "1em" }, d = i != null && i.crossIcon ? i.crossIcon(u, e) : u;
  return b(Rt, { role: "button", className: r({ indicator: !0, "clear-indicator": !0 }, n), sx: l, "aria-label": "Clear selected options", ...o, children: t || b(s8, { sx: d }) });
}, c8 = (e) => {
  let { className: t, cx: n, innerProps: r, selectProps: { chakraStyles: o, size: i }, color: s, emptyColor: a, speed: c, thickness: l, spinnerSize: u } = e, d = er(i), f = { sm: "xs", md: "sm", lg: "md" }[d], p = { marginRight: 3 }, m = o != null && o.loadingIndicator ? o.loadingIndicator(p, e) : p;
  return b(lu, { className: n({ indicator: !0, "loading-indicator": !0 }, t), sx: m, ...r, size: u || f, color: s, emptyColor: a, speed: c, thickness: l });
}, l8 = n8, u8 = (e) => {
  let { className: t, cx: n, value: r, selectProps: { chakraStyles: o, isReadOnly: i } } = e, { innerRef: s, isDisabled: a, isHidden: c, inputClassName: l, ...u } = tP(e), d = { gridArea: "1 / 2", minW: "2px", border: 0, margin: 0, outline: 0, padding: 0 }, f = { flex: "1 1 auto", display: "inline-grid", gridArea: "1 / 1 / 2 / 3", gridTemplateColumns: "0 min-content", color: "inherit", marginX: "0.125rem", paddingY: "0.125rem", visibility: a ? "hidden" : "visible", transform: r ? "translateZ(0)" : "", _after: { content: 'attr(data-value) " "', visibility: "hidden", whiteSpace: "pre", padding: 0, ...d } }, p = o != null && o.inputContainer ? o.inputContainer(f, e) : f, m = { background: 0, opacity: c ? 0 : 1, width: "100%", ...d }, h = o != null && o.input ? o.input(m, e) : m;
  return b(Rt, { className: n({ "input-container": !0 }, t), "data-value": r || "", sx: p, children: b(z.input, { className: n({ input: !0 }, l), ref: s, sx: h, disabled: a, readOnly: i ? !0 : void 0, ...u }) });
}, d8 = u8, f8 = (e) => e ? { bottom: "top", top: "bottom" }[e] : "top", p8 = (e) => {
  let { className: t, cx: n, children: r, innerProps: o, innerRef: i, placement: s, selectProps: { chakraStyles: a } } = e, c = { position: "absolute", [f8(s)]: "100%", marginY: "8px", width: "100%", zIndex: 1 }, l = a != null && a.menu ? a.menu(c, e) : c;
  return b(Tm, { children: b(Rt, { ...o, ref: i, className: n({ menu: !0 }, t), sx: l, children: r }) });
}, h8 = p8, m8 = (e) => {
  var t;
  let { className: n, cx: r, innerRef: o, children: i, maxHeight: s, isMulti: a, innerProps: c, selectProps: { chakraStyles: l, size: u, variant: d, focusBorderColor: f, errorBorderColor: p } } = e, m = We("Menu"), h = er(u), g = We("Input", { size: h, variant: d, focusBorderColor: f, errorBorderColor: p }).field, v = { ...m.list, minW: "100%", maxHeight: `${s}px`, overflowY: "auto", "--input-border-radius": g?.["--input-border-radius"], borderRadius: g?.borderRadius || ((t = m.list) == null ? void 0 : t.borderRadius), position: "relative", WebkitOverflowScrolling: "touch" }, y = l != null && l.menuList ? l.menuList(v, e) : v;
  return b(Rt, { ...c, className: r({ "menu-list": !0, "menu-list--is-multi": a }, n), sx: y, ref: o, children: i });
}, g8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i, size: s } } = e, a = er(s), c = { color: "chakra-subtle-text", textAlign: "center", paddingY: { sm: "6px", md: "8px", lg: "10px" }[a], fontSize: a }, l = i != null && i.loadingMessage ? i.loadingMessage(c, e) : c;
  return b(Rt, { ...o, className: r({ "menu-notice": !0, "menu-notice--loading": !0 }, n), sx: l, children: t });
}, b8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i, size: s } } = e, a = er(s), c = { color: "chakra-subtle-text", textAlign: "center", paddingY: { sm: "6px", md: "8px", lg: "10px" }[a], fontSize: a }, l = i != null && i.noOptionsMessage ? i.noOptionsMessage(c, e) : c;
  return b(Rt, { ...o, className: r({ "menu-notice": !0, "menu-notice--no-options": !0 }, n), sx: l, children: t });
}, v8 = (e) => {
  let { children: t, className: n, cx: r, theme: o, getStyles: i, Heading: s, headingProps: a, label: c, selectProps: l, innerProps: u, getClassNames: d } = e, { chakraStyles: f } = l, p = {}, m = f != null && f.group ? f.group(p, e) : p;
  return Ae(Rt, { ...u, className: r({ group: !0 }, n), sx: m, children: [b(s, { ...a, selectProps: l, cx: r, theme: o, getStyles: i, getClassNames: d, children: c }), b(Rt, { children: t })] });
}, y8 = (e) => {
  let { cx: t, className: n, selectProps: { chakraStyles: r, size: o, hasStickyGroupHeaders: i } } = e, { data: s, ...a } = tP(e), c = We("Menu"), l = er(o), u = { sm: "xs", md: "sm", lg: "md" }, d = { sm: "0.4rem 0.8rem", md: "0.5rem 1rem", lg: "0.6rem 1.2rem" }, f = { ...c.groupTitle, fontSize: u[l], padding: d[l], margin: 0, borderBottomWidth: i ? "1px" : 0, position: i ? "sticky" : "static", top: -2, bg: c.list.bg, zIndex: 1 }, p = r != null && r.groupHeading ? r.groupHeading(f, e) : f;
  return b(Rt, { ...a, className: t({ "group-heading": !0 }, n), sx: p });
}, S8 = (e) => b("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", ...e, children: b("polygon", { fill: "currentColor", points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039" }) }), x8 = (e) => {
  let { className: t, cx: n, innerRef: r, innerProps: o, children: i, isFocused: s, isDisabled: a, isSelected: c, selectProps: { chakraStyles: l, size: u, isMulti: d, hideSelectedOptions: f, selectedOptionStyle: p, selectedOptionColorScheme: m } } = e, h = We("Menu").item, g = er(u), v = { sm: "0.6rem", md: "0.8rem", lg: "1rem" }, y = { sm: "0.3rem", md: "0.4rem", lg: "0.5rem" }, x = ib(`${m}.500`, `${m}.300`), S = ib("white", "black"), C = p === "check" && (!d || f === !1), w = p === "color" && c, I = { ...h, cursor: "pointer", display: "flex", alignItems: "center", width: "100%", textAlign: "start", fontSize: g, paddingX: v[g], paddingY: y[g], ...w ? { bg: x, color: S, _active: { bg: x } } : {} }, P = l != null && l.option ? l.option(I, e) : I;
  return Ae(Rt, { ...o, className: n({ option: !0, "option--is-disabled": a, "option--is-focused": s, "option--is-selected": c }, t), sx: P, ref: r, "data-focus": s ? !0 : void 0, "aria-disabled": a ? !0 : void 0, "aria-selected": c, children: [C && b(pa, { fontSize: "0.8em", marginEnd: "0.75rem", opacity: c ? 1 : 0, children: b(S8, {}) }), i] });
}, C8 = (e) => typeof e == "object" && e !== null && "colorScheme" in e && typeof e.colorScheme == "string", I8 = (e) => typeof e == "object" && e !== null && "variant" in e && typeof e.variant == "string", nP = (e) => typeof e == "object" && e !== null && "isFixed" in e && typeof e.isFixed == "boolean", w8 = (e) => {
  let { children: t, className: n, components: r, cx: o, data: i, innerProps: s, isDisabled: a, isFocused: c, removeProps: l, selectProps: u, cropWithEllipsis: d } = e, { Container: f, Label: p, Remove: m } = r, { chakraStyles: h, colorScheme: g, tagVariant: v, size: y } = u, x = er(y), S = "", C = "", w = !1;
  C8(i) && (S = i.colorScheme), I8(i) && (C = i.variant), nP(i) && (w = i.isFixed);
  let I = We("Tag", { size: x, colorScheme: S || g, variant: C || v || (w ? "solid" : "subtle") }), P = { ...I.container, display: "flex", alignItems: "center", minWidth: 0, margin: "0.125rem" }, k = h != null && h.multiValue ? h.multiValue(P, e) : P, A = { ...I.label, overflow: "hidden", textOverflow: d || d === void 0 ? "ellipsis" : void 0, whiteSpace: "nowrap" }, N = h != null && h.multiValueLabel ? h.multiValueLabel(A, e) : A, B = { ...I.closeButton, display: "flex", alignItems: "center", justifyContent: "center" }, L = h != null && h.multiValueRemove ? h.multiValueRemove(B, e) : B;
  return Ae(f, { data: i, innerProps: { className: o({ "multi-value": !0, "multi-value--is-disabled": a }, n), ...s }, sx: k, selectProps: u, children: [b(p, { data: i, innerProps: { className: o({ "multi-value__label": !0 }, n) }, sx: N, selectProps: u, children: t }), b(m, { data: i, innerProps: { className: o({ "multi-value__remove": !0 }, n), "aria-label": `Remove ${t || "option"}`, ...l }, sx: L, selectProps: u, isFocused: c })] });
}, P8 = (e) => {
  let { children: t, innerProps: n, sx: r } = e;
  return b(z.span, { ...n, sx: r, children: t });
}, k8 = (e) => {
  let { children: t, innerProps: n, sx: r } = e;
  return b(z.span, { ...n, sx: r, children: t });
}, A8 = (e) => b(It, { verticalAlign: "inherit", viewBox: "0 0 512 512", ...e, children: b("path", { fill: "currentColor", d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" }) }), T8 = (e) => {
  let { children: t, innerProps: n, isFocused: r, data: o, sx: i } = e;
  return nP(o) && o.isFixed ? null : b(Rt, { ...n, role: "button", sx: i, "data-focus": r ? !0 : void 0, "data-focus-visible": r ? !0 : void 0, children: t || b(A8, {}) });
}, E8 = w8, R8 = (e) => {
  let { children: t, className: n, cx: r, innerProps: o, selectProps: { chakraStyles: i } } = e, s = { gridArea: "1 / 1 / 2 / 3", color: "chakra-placeholder-color", mx: "0.125rem", userSelect: "none" }, a = i != null && i.placeholder ? i.placeholder(s, e) : s;
  return b(Rt, { ...o, className: r({ placeholder: !0 }, n), sx: a, children: t });
}, _8 = R8, O8 = (e) => {
  let { children: t, className: n, cx: r, isDisabled: o, innerProps: i, selectProps: { chakraStyles: s } } = e, a = { gridArea: "1 / 1 / 2 / 3", mx: "0.125rem", maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, c = s != null && s.singleValue ? s.singleValue(a, e) : a;
  return b(Rt, { className: r({ "single-value": !0, "single-value--is-disabled": o }, n), sx: c, ...i, children: t });
}, N8 = O8, M8 = { ClearIndicator: a8, Control: l8, DropdownIndicator: i8, Group: v8, GroupHeading: y8, IndicatorSeparator: r8, IndicatorsContainer: t8, Input: d8, LoadingIndicator: c8, LoadingMessage: g8, Menu: h8, MenuList: m8, MultiValue: E8, MultiValueContainer: P8, MultiValueLabel: k8, MultiValueRemove: T8, NoOptionsMessage: b8, Option: x8, Placeholder: _8, SelectContainer: Q7, SingleValue: N8, ValueContainer: e8 }, Rl = M8, B8 = ({ components: e = {}, theme: t, size: n, colorScheme: r = "gray", isDisabled: o, isInvalid: i, isReadOnly: s, required: a, isRequired: c, inputId: l, tagVariant: u, selectedOptionStyle: d = "color", selectedOptionColorScheme: f, selectedOptionColor: p, variant: m, focusBorderColor: h, errorBorderColor: g, chakraStyles: v = {}, onFocus: y, onBlur: x, menuIsOpen: S, ...C }) => {
  var w;
  let I = bn(), { variant: P } = I.components.Input.defaultProps, k = as({ id: l, isDisabled: o, isInvalid: i, isRequired: c, isReadOnly: s, onFocus: y, onBlur: x }), A = S ?? (k.readOnly ? !1 : void 0), N = d;
  ["color", "check"].includes(d) || (N = "color");
  let B = f || p || "blue";
  return typeof B != "string" && (B = "blue"), { components: { ...Rl, ...e }, colorScheme: r, size: n, tagVariant: u, selectedOptionStyle: N, selectedOptionColorScheme: B, variant: m ?? P, chakraStyles: v, focusBorderColor: h, errorBorderColor: g, onFocus: k.onFocus, onBlur: k.onBlur, isDisabled: k.disabled, isInvalid: !!k["aria-invalid"], inputId: k.id, isReadOnly: k.readOnly, required: a ?? k.required, menuIsOpen: A, ...C, "aria-invalid": (w = C["aria-invalid"]) != null ? w : k["aria-invalid"] };
}, Eu = B8, F8 = _t((e, t) => {
  let n = Eu(e);
  return b(G7, { ref: t, ...n });
}), D8 = F8;
_t((e, t) => {
  let n = Eu(e);
  return b(j7, { ref: t, ...n });
});
_t((e, t) => {
  let n = Eu(e);
  return b(Z7, { ref: t, ...n });
});
_t((e, t) => {
  let n = Eu(e);
  return b(J7, { ref: t, ...n });
});
/*!
 * OverlayScrollbars
 * Version: 2.12.0
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
const Sn = (e, t) => {
  const { o: n, i: r, u: o } = e;
  let i = n, s;
  const a = (u, d) => {
    const f = i, p = u, m = d || (r ? !r(f, p) : f !== p);
    return (m || o) && (i = p, s = f), [i, m, s];
  };
  return [t ? (u) => a(t(i, s), u) : a, (u) => [i, !!u, s]];
}, $8 = typeof window < "u" && typeof HTMLElement < "u" && !!window.document, fn = $8 ? window : {}, rP = Math.max, V8 = Math.min, zp = Math.round, _l = Math.abs, Uy = Math.sign, oP = fn.cancelAnimationFrame, Ym = fn.requestAnimationFrame, Zm = fn.setTimeout, iP = fn.clearTimeout, Ru = (e) => typeof fn[e] < "u" ? fn[e] : void 0, L8 = Ru("MutationObserver"), Jy = Ru("IntersectionObserver"), Ai = Ru("ResizeObserver"), Ds = Ru("ScrollTimeline"), Um = (e) => e === void 0, _u = (e) => e === null, $r = (e) => typeof e == "number", Va = (e) => typeof e == "string", Ou = (e) => typeof e == "boolean", tr = (e) => typeof e == "function", Kn = (e) => Array.isArray(e), Ol = (e) => typeof e == "object" && !Kn(e) && !_u(e), Jm = (e) => {
  const t = !!e && e.length, n = $r(t) && t > -1 && t % 1 == 0;
  return Kn(e) || !tr(e) && n ? t > 0 && Ol(e) ? t - 1 in e : !0 : !1;
}, Nl = (e) => !!e && e.constructor === Object, Ml = (e) => e instanceof HTMLElement, Nu = (e) => e instanceof Element;
function lt(e, t) {
  if (Jm(e))
    for (let n = 0; n < e.length && t(e[n], n, e) !== !1; n++)
      ;
  else e && lt(Object.keys(e), ((n) => t(e[n], n, e)));
  return e;
}
const sP = (e, t) => e.indexOf(t) >= 0, ha = (e, t) => e.concat(t), Ct = (e, t, n) => (!Va(t) && Jm(t) ? Array.prototype.push.apply(e, t) : e.push(t), e), ho = (e) => Array.from(e || []), Km = (e) => Kn(e) ? e : !Va(e) && Jm(e) ? ho(e) : [e], Bl = (e) => !!e && !e.length, Gp = (e) => ho(new Set(e)), wn = (e, t, n) => {
  lt(e, (o) => o ? o.apply(void 0, t || []) : !0), n || (e.length = 0);
}, aP = "paddingTop", cP = "paddingRight", lP = "paddingLeft", uP = "paddingBottom", dP = "marginLeft", fP = "marginRight", pP = "marginBottom", qm = "overflowX", Qm = "overflowY", Mu = "width", Bu = "height", Or = "visible", Yn = "hidden", ts = "scroll", z8 = (e) => {
  const t = String(e || "");
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}, Fu = (e, t, n, r) => {
  if (e && t) {
    let o = !0;
    return lt(n, ((i) => {
      const s = e[i], a = t[i];
      s !== a && (o = !1);
    })), o;
  }
  return !1;
}, hP = (e, t) => Fu(e, t, ["w", "h"]), qc = (e, t) => Fu(e, t, ["x", "y"]), G8 = (e, t) => Fu(e, t, ["t", "r", "b", "l"]), Be = (e, ...t) => e.bind(0, ...t), Ti = (e) => {
  let t;
  const n = e ? Zm : Ym, r = e ? iP : oP;
  return [(o) => {
    r(t), t = n((() => o()), tr(e) ? e() : e);
  }, () => r(t)];
}, Ky = (e) => {
  const t = tr(e) ? e() : e;
  if ($r(t)) {
    const n = t ? Zm : Ym, r = t ? iP : oP;
    return (o) => {
      const i = n((() => o()), t);
      return () => {
        r(i);
      };
    };
  }
  return t && t._;
}, Fl = (e, t) => {
  const { p: n, v: r, S: o, m: i } = t || {};
  let s, a, c, l;
  const u = function(h) {
    a && a(), s && s(), l = a = s = c = void 0, e.apply(this, h);
  }, d = (m) => i && c ? i(c, m) : m, f = () => {
    a && c && u(d(c) || c);
  }, p = function() {
    const h = ho(arguments), g = Ky(n);
    if (g) {
      const v = Ky(r), x = d(h) || h, S = u.bind(0, x);
      a && a(), o && !l ? (S(), l = !0, a = g((() => l = void 0))) : (a = g(S), v && !s && (s = v(f))), c = x;
    } else
      u(h);
  };
  return p.O = f, p;
}, mP = (e, t) => Object.prototype.hasOwnProperty.call(e, t), qn = (e) => e ? Object.keys(e) : [], Ze = (e, t, n, r, o, i, s) => {
  const a = [t, n, r, o, i, s];
  return (typeof e != "object" || _u(e)) && !tr(e) && (e = {}), lt(a, ((c) => {
    lt(c, ((l, u) => {
      const d = c[u];
      if (e === d)
        return !0;
      const f = Kn(d);
      if (d && Nl(d)) {
        const p = e[u];
        let m = p;
        f && !Kn(p) ? m = [] : !f && !Nl(p) && (m = {}), e[u] = Ze(m, d);
      } else
        e[u] = f ? d.slice() : d;
    }));
  })), e;
}, gP = (e, t) => lt(Ze({}, e), ((n, r, o) => {
  n === void 0 ? delete o[r] : n && Nl(n) && (o[r] = gP(n));
})), eg = (e) => !qn(e).length, ma = () => {
}, bP = (e, t, n) => rP(e, V8(t, n)), $o = (e) => Gp((Kn(e) ? e : (e || "").split(" ")).filter(((t) => t))), tg = (e, t) => e && e.getAttribute(t), qy = (e, t) => e && e.hasAttribute(t), Ar = (e, t, n) => {
  lt($o(t), ((r) => {
    e && e.setAttribute(r, String(n || ""));
  }));
}, sr = (e, t) => {
  lt($o(t), ((n) => e && e.removeAttribute(n)));
}, Du = (e, t) => {
  const n = $o(tg(e, t)), r = Be(Ar, e, t), o = (i, s) => {
    const a = new Set(n);
    return lt($o(i), ((c) => {
      a[s](c);
    })), ho(a).join(" ");
  };
  return {
    C: (i) => r(o(i, "delete")),
    $: (i) => r(o(i, "add")),
    H: (i) => {
      const s = $o(i);
      return s.reduce(((a, c) => a && n.includes(c)), s.length > 0);
    }
  };
}, vP = (e, t, n) => (Du(e, t).C(n), Be(ng, e, t, n)), ng = (e, t, n) => (Du(e, t).$(n), Be(vP, e, t, n)), Dl = (e, t, n, r) => (r ? ng : vP)(e, t, n), rg = (e, t, n) => Du(e, t).H(n), yP = (e) => Du(e, "class"), SP = (e, t) => {
  yP(e).C(t);
}, og = (e, t) => (yP(e).$(t), Be(SP, e, t)), xP = (e, t) => {
  const n = t ? Nu(t) && t : document;
  return n ? ho(n.querySelectorAll(e)) : [];
}, W8 = (e, t) => {
  const n = t ? Nu(t) && t : document;
  return n && n.querySelector(e);
}, Wp = (e, t) => Nu(e) && e.matches(t), CP = (e) => Wp(e, "body"), Hp = (e) => e ? ho(e.childNodes) : [], ga = (e) => e && e.parentElement, Ei = (e, t) => Nu(e) && e.closest(t), jp = (e) => document.activeElement, H8 = (e, t, n) => {
  const r = Ei(e, t), o = e && W8(n, r), i = Ei(o, t) === r;
  return r && o ? r === e || o === e || i && Ei(Ei(e, n), t) !== r : !1;
}, ns = (e) => {
  lt(Km(e), ((t) => {
    const n = ga(t);
    t && n && n.removeChild(t);
  }));
}, dn = (e, t) => Be(ns, e && t && lt(Km(t), ((n) => {
  n && e.appendChild(n);
})));
let IP;
const j8 = () => IP, X8 = (e) => {
  IP = e;
}, Gi = (e) => {
  const t = document.createElement("div");
  return Ar(t, "class", e), t;
}, wP = (e) => {
  const t = Gi(), n = j8(), r = e.trim();
  return t.innerHTML = n ? n.createHTML(r) : r, lt(Hp(t), ((o) => ns(o)));
}, Qy = (e, t) => e.getPropertyValue(t) || e[t] || "", PP = (e) => {
  const t = e || 0;
  return isFinite(t) ? t : 0;
}, vc = (e) => PP(parseFloat(e || "")), Xp = (e) => Math.round(e * 1e4) / 1e4, kP = (e) => `${Xp(PP(e))}px`;
function ba(e, t) {
  e && t && lt(t, ((n, r) => {
    try {
      const o = e.style, i = _u(n) || Ou(n) ? "" : $r(n) ? kP(n) : n;
      r.indexOf("--") === 0 ? o.setProperty(r, i) : o[r] = i;
    } catch {
    }
  }));
}
function vr(e, t, n) {
  const r = Va(t);
  let o = r ? "" : {};
  if (e) {
    const i = fn.getComputedStyle(e, n) || e.style;
    o = r ? Qy(i, t) : ho(t).reduce(((s, a) => (s[a] = Qy(i, a), s)), o);
  }
  return o;
}
const e0 = (e, t, n) => {
  const r = t ? `${t}-` : "", o = n ? `-${n}` : "", i = `${r}top${o}`, s = `${r}right${o}`, a = `${r}bottom${o}`, c = `${r}left${o}`, l = vr(e, [i, s, a, c]);
  return {
    t: vc(l[i]),
    r: vc(l[s]),
    b: vc(l[a]),
    l: vc(l[c])
  };
}, bf = (e, t) => `translate${Ol(e) ? `(${e.x},${e.y})` : `${t ? "X" : "Y"}(${e})`}`, Y8 = (e) => !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length), Z8 = {
  w: 0,
  h: 0
}, $u = (e, t) => t ? {
  w: t[`${e}Width`],
  h: t[`${e}Height`]
} : Z8, U8 = (e) => $u("inner", e || fn), Wi = Be($u, "offset"), AP = Be($u, "client"), $l = Be($u, "scroll"), ig = (e) => {
  const t = parseFloat(vr(e, Mu)) || 0, n = parseFloat(vr(e, Bu)) || 0;
  return {
    w: t - zp(t),
    h: n - zp(n)
  };
}, vf = (e) => e.getBoundingClientRect(), J8 = (e) => !!e && Y8(e), Yp = (e) => !!(e && (e[Bu] || e[Mu])), TP = (e, t) => {
  const n = Yp(e);
  return !Yp(t) && n;
}, t0 = (e, t, n, r) => {
  lt($o(t), ((o) => {
    e && e.removeEventListener(o, n, r);
  }));
}, bt = (e, t, n, r) => {
  var o;
  const i = (o = r && r.T) != null ? o : !0, s = r && r.I || !1, a = r && r.A || !1, c = {
    passive: i,
    capture: s
  };
  return Be(wn, $o(t).map(((l) => {
    const u = a ? (d) => {
      t0(e, l, u, s), n && n(d);
    } : n;
    return e && e.addEventListener(l, u, c), Be(t0, e, l, u, s);
  })));
}, EP = (e) => e.stopPropagation(), Zp = (e) => e.preventDefault(), RP = (e) => EP(e) || Zp(e), fr = (e, t) => {
  const { x: n, y: r } = $r(t) ? {
    x: t,
    y: t
  } : t || {};
  $r(n) && (e.scrollLeft = n), $r(r) && (e.scrollTop = r);
}, xn = (e) => ({
  x: e.scrollLeft,
  y: e.scrollTop
}), _P = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
}), K8 = (e, t) => {
  const { D: n, M: r } = e, { w: o, h: i } = t, s = (d, f, p) => {
    let m = Uy(d) * p, h = Uy(f) * p;
    if (m === h) {
      const g = _l(d), v = _l(f);
      h = g > v ? 0 : h, m = g < v ? 0 : m;
    }
    return m = m === h ? 0 : m, [m + 0, h + 0];
  }, [a, c] = s(n.x, r.x, o), [l, u] = s(n.y, r.y, i);
  return {
    D: {
      x: a,
      y: l
    },
    M: {
      x: c,
      y: u
    }
  };
}, yf = ({ D: e, M: t }) => {
  const n = (r, o) => r === 0 && r <= o;
  return {
    x: n(e.x, t.x),
    y: n(e.y, t.y)
  };
}, n0 = ({ D: e, M: t }, n) => {
  const r = (o, i, s) => bP(0, 1, (o - s) / (o - i) || 0);
  return {
    x: r(e.x, t.x, n.x),
    y: r(e.y, t.y, n.y)
  };
}, Up = (e) => {
  e && e.focus && e.focus({
    preventScroll: !0
  });
}, r0 = (e, t) => {
  lt(Km(t), e);
}, Jp = (e) => {
  const t = /* @__PURE__ */ new Map(), n = (i, s) => {
    if (i) {
      const a = t.get(i);
      r0(((c) => {
        a && a[c ? "delete" : "clear"](c);
      }), s);
    } else
      t.forEach(((a) => {
        a.clear();
      })), t.clear();
  }, r = (i, s) => {
    if (Va(i)) {
      const l = t.get(i) || /* @__PURE__ */ new Set();
      return t.set(i, l), r0(((u) => {
        tr(u) && l.add(u);
      }), s), Be(n, i, s);
    }
    Ou(s) && s && n();
    const a = qn(i), c = [];
    return lt(a, ((l) => {
      const u = i[l];
      u && Ct(c, r(l, u));
    })), Be(wn, c);
  }, o = (i, s) => {
    lt(ho(t.get(i)), ((a) => {
      s && !Bl(s) ? a.apply(0, s) : a();
    }));
  };
  return r(e || {}), [r, n, o];
}, OP = {}, NP = {}, q8 = (e) => {
  lt(e, ((t) => lt(t, ((n, r) => {
    OP[r] = t[r];
  }))));
}, MP = (e, t, n) => qn(e).map(((r) => {
  const { static: o, instance: i } = e[r], [s, a, c] = n || [], l = n ? i : o;
  if (l) {
    const u = n ? l(s, a, t) : l(t);
    return (c || NP)[r] = u;
  }
})), ls = (e) => NP[e], Q8 = "__osOptionsValidationPlugin", us = "data-overlayscrollbars", Qc = "os-environment", yc = `${Qc}-scrollbar-hidden`, Sf = `${us}-initialize`, el = "noClipping", o0 = `${us}-body`, no = us, eU = "host", Tr = `${us}-viewport`, tU = qm, nU = Qm, rU = "arrange", BP = "measuring", oU = "scrolling", FP = "scrollbarHidden", iU = "noContent", Kp = `${us}-padding`, i0 = `${us}-content`, sg = "os-size-observer", sU = `${sg}-appear`, aU = `${sg}-listener`, cU = "os-trinsic-observer", lU = "os-theme-none", Tn = "os-scrollbar", uU = `${Tn}-rtl`, dU = `${Tn}-horizontal`, fU = `${Tn}-vertical`, DP = `${Tn}-track`, ag = `${Tn}-handle`, pU = `${Tn}-visible`, hU = `${Tn}-cornerless`, s0 = `${Tn}-interaction`, a0 = `${Tn}-unusable`, qp = `${Tn}-auto-hide`, c0 = `${qp}-hidden`, l0 = `${Tn}-wheel`, mU = `${DP}-interactive`, gU = `${ag}-interactive`, bU = "__osSizeObserverPlugin", vU = (e, t) => {
  const { k: n } = t, [r, o] = e("showNativeOverlaidScrollbars");
  return [r && n.x && n.y, o];
}, Ri = (e) => e.indexOf(Or) === 0, yU = (e) => e.replace(`${Or}-`, ""), Qp = (e, t) => {
  if (e === "auto")
    return t ? ts : Yn;
  const n = e || Yn;
  return [Yn, ts, Or].includes(n) ? n : Yn;
}, SU = (e, t) => {
  const { overflowX: n, overflowY: r } = vr(e, [qm, Qm]);
  return {
    x: Qp(n, t.x),
    y: Qp(r, t.y)
  };
}, cg = "__osScrollbarsHidingPlugin", xU = "__osClickScrollPlugin", u0 = (e) => JSON.stringify(e, ((t, n) => {
  if (tr(n))
    throw 0;
  return n;
})), d0 = (e, t) => e ? `${t}`.split(".").reduce(((n, r) => n && mP(n, r) ? n[r] : void 0), e) : void 0, CU = {
  paddingAbsolute: !1,
  showNativeOverlaidScrollbars: !1,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: !1,
    dragScroll: !0,
    clickScroll: !1,
    pointers: ["mouse", "touch", "pen"]
  }
}, $P = (e, t) => {
  const n = {}, r = ha(qn(t), qn(e));
  return lt(r, ((o) => {
    const i = e[o], s = t[o];
    if (Ol(i) && Ol(s))
      Ze(n[o] = {}, $P(i, s)), eg(n[o]) && delete n[o];
    else if (mP(t, o) && s !== i) {
      let a = !0;
      if (Kn(i) || Kn(s))
        try {
          u0(i) === u0(s) && (a = !1);
        } catch {
        }
      a && (n[o] = s);
    }
  })), n;
}, f0 = (e, t, n) => (r) => [d0(e, r), n || d0(t, r) !== void 0];
let VP;
const IU = () => VP, wU = (e) => {
  VP = e;
};
let xf;
const PU = () => {
  const e = (S, C, w) => {
    dn(document.body, S), dn(document.body, S);
    const I = AP(S), P = Wi(S), k = ig(C);
    return w && ns(S), {
      x: P.h - I.h + k.h,
      y: P.w - I.w + k.w
    };
  }, t = (S) => {
    let C = !1;
    const w = og(S, yc);
    try {
      C = vr(S, "scrollbar-width") === "none" || vr(S, "display", "::-webkit-scrollbar") === "none";
    } catch {
    }
    return w(), C;
  }, n = `.${Qc}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${Qc} div{width:200%;height:200%;margin:10px 0}.${yc}{scrollbar-width:none!important}.${yc}::-webkit-scrollbar,.${yc}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, o = wP(`<div class="${Qc}"><div></div><style>${n}</style></div>`)[0], i = o.firstChild, s = o.lastChild, a = IU();
  a && (s.nonce = a);
  const [c, , l] = Jp(), [u, d] = Sn({
    o: e(o, i),
    i: qc
  }, Be(e, o, i, !0)), [f] = d(), p = t(o), m = {
    x: f.x === 0,
    y: f.y === 0
  }, h = {
    elements: {
      host: null,
      padding: !p,
      viewport: (S) => p && CP(S) && S,
      content: !1
    },
    scrollbars: {
      slot: !0
    },
    cancel: {
      nativeScrollbarsOverlaid: !1,
      body: null
    }
  }, g = Ze({}, CU), v = Be(Ze, {}, g), y = Be(Ze, {}, h), x = {
    P: f,
    k: m,
    U: p,
    J: !!Ds,
    G: Be(c, "r"),
    K: y,
    Z: (S) => Ze(h, S) && y(),
    tt: v,
    nt: (S) => Ze(g, S) && v(),
    ot: Ze({}, h),
    st: Ze({}, g)
  };
  if (sr(o, "style"), ns(o), bt(fn, "resize", (() => {
    l("r", []);
  })), tr(fn.matchMedia) && !p && (!m.x || !m.y)) {
    const S = (C) => {
      const w = fn.matchMedia(`(resolution: ${fn.devicePixelRatio}dppx)`);
      bt(w, "change", (() => {
        C(), S(C);
      }), {
        A: !0
      });
    };
    S((() => {
      const [C, w] = u();
      Ze(x.P, C), l("r", [w]);
    }));
  }
  return x;
}, Cr = () => (xf || (xf = PU()), xf), kU = (e, t, n) => {
  let r = !1;
  const o = n ? /* @__PURE__ */ new WeakMap() : !1, i = () => {
    r = !0;
  }, s = (a) => {
    if (o && n) {
      const c = n.map(((l) => {
        const [u, d] = l || [];
        return [d && u ? (a || xP)(u, e) : [], d];
      }));
      lt(c, ((l) => lt(l[0], ((u) => {
        const d = l[1], f = o.get(u) || [];
        if (e.contains(u) && d) {
          const m = bt(u, d, ((h) => {
            r ? (m(), o.delete(u)) : t(h);
          }));
          o.set(u, Ct(f, m));
        } else
          wn(f), o.delete(u);
      }))));
    }
  };
  return s(), [i, s];
}, p0 = (e, t, n, r) => {
  let o = !1;
  const { et: i, ct: s, rt: a, it: c, lt: l, ut: u } = r || {}, d = Fl((() => o && n(!0)), {
    p: 33,
    v: 99
  }), [f, p] = kU(e, d, a), m = i || [], h = s || [], g = ha(m, h), v = (x, S) => {
    if (!Bl(S)) {
      const C = l || ma, w = u || ma, I = [], P = [];
      let k = !1, A = !1;
      if (lt(S, ((N) => {
        const { attributeName: B, target: L, type: Z, oldValue: ne, addedNodes: W, removedNodes: O } = N, J = Z === "attributes", ee = Z === "childList", H = e === L, _ = J && B, j = _ && tg(L, B || ""), E = Va(j) ? j : null, M = _ && ne !== E, F = sP(h, B) && M;
        if (t && (ee || !H)) {
          const G = J && M, q = G && c && Wp(L, c), U = (q ? !C(L, B, ne, E) : !J || G) && !w(N, !!q, e, r);
          lt(W, ((K) => Ct(I, K))), lt(O, ((K) => Ct(I, K))), A = A || U;
        }
        !t && H && M && !C(L, B, ne, E) && (Ct(P, B), k = k || F);
      })), p(((N) => Gp(I).reduce(((B, L) => (Ct(B, xP(N, L)), Wp(L, N) ? Ct(B, L) : B)), []))), t)
        return !x && A && n(!1), [!1];
      if (!Bl(P) || k) {
        const N = [Gp(P), k];
        return x || n.apply(0, N), N;
      }
    }
  }, y = new L8(Be(v, !1));
  return [() => (y.observe(e, {
    attributes: !0,
    attributeOldValue: !0,
    attributeFilter: g,
    subtree: t,
    childList: t,
    characterData: t
  }), o = !0, () => {
    o && (f(), y.disconnect(), o = !1);
  }), () => {
    if (o)
      return d.O(), v(!0, y.takeRecords());
  }];
};
let vo = null;
const LP = (e, t, n) => {
  const { ft: r } = n || {}, o = ls(bU), [i] = Sn({
    o: !1,
    u: !0
  });
  return () => {
    const s = [], c = wP(`<div class="${sg}"><div class="${aU}"></div></div>`)[0], l = c.firstChild, u = (d) => {
      const f = Kn(d) && !Bl(d);
      let p = !1, m = !1;
      if (f) {
        const h = d[0], [g, , v] = i(h.contentRect), y = Yp(g);
        m = TP(g, v), p = !m && !y;
      } else
        m = d === !0;
      p || t({
        _t: !0,
        ft: m
      });
    };
    if (Ai) {
      if (!Ou(vo)) {
        const m = new Ai(ma);
        m.observe(e, {
          get box() {
            vo = !0;
          }
        }), vo = vo || !1, m.disconnect();
      }
      const d = Fl(u, {
        p: 0,
        v: 0
      }), f = (m) => d(m), p = new Ai(f);
      if (p.observe(vo ? e : l), Ct(s, [() => {
        p.disconnect();
      }, !vo && dn(e, c)]), vo) {
        const m = new Ai(f);
        m.observe(e, {
          box: "border-box"
        }), Ct(s, (() => m.disconnect()));
      }
    } else if (o) {
      const [d, f] = o(l, u, r);
      Ct(s, ha([og(c, sU), bt(c, "animationstart", d), dn(e, c)], f));
    } else
      return ma;
    return Be(wn, s);
  };
}, AU = (e, t) => {
  let n;
  const r = (c) => c.h === 0 || c.isIntersecting || c.intersectionRatio > 0, o = Gi(cU), [i] = Sn({
    o: !1
  }), s = (c, l) => {
    if (c) {
      const u = i(r(c)), [, d] = u;
      return d && !l && t(u) && [u];
    }
  }, a = (c, l) => s(l.pop(), c);
  return [() => {
    const c = [];
    if (Jy)
      n = new Jy(Be(a, !1), {
        root: e
      }), n.observe(o), Ct(c, (() => {
        n.disconnect();
      }));
    else {
      const l = () => {
        const u = Wi(o);
        s(u);
      };
      Ct(c, LP(o, l)()), l();
    }
    return Be(wn, Ct(c, dn(e, o)));
  }, () => n && a(!0, n.takeRecords())];
}, TU = (e, t, n, r) => {
  let o, i, s, a, c, l;
  const u = `[${no}]`, d = `[${Tr}]`, f = ["id", "class", "style", "open", "wrap", "cols", "rows"], { dt: p, vt: m, L: h, gt: g, ht: v, V: y, bt: x, wt: S, yt: C, St: w } = e, I = (F) => vr(F, "direction") === "rtl", P = {
    Ot: !1,
    B: I(p)
  }, k = Cr(), A = ls(cg), [N] = Sn({
    i: hP,
    o: {
      w: 0,
      h: 0
    }
  }, (() => {
    const F = A && A.R(e, t, P, k, n).Y, q = !(x && y) && rg(m, no, el), te = !y && S(rU), U = te && xn(g), K = U && w(), ae = C(BP, q), Y = te && F && F(), ce = $l(h), re = ig(h);
    return Y && Y(), fr(g, U), K && K(), q && ae(), {
      w: ce.w + re.w,
      h: ce.h + re.h
    };
  })), B = Fl(r, {
    p: () => o,
    v: () => i,
    m(F, G) {
      const [q] = F, [te] = G;
      return [ha(qn(q), qn(te)).reduce(((U, K) => (U[K] = q[K] || te[K], U)), {})];
    }
  }), L = (F) => {
    const G = I(p);
    Ze(F, {
      Ct: l !== G
    }), Ze(P, {
      B: G
    }), l = G;
  }, Z = (F, G) => {
    const [q, te] = F, U = {
      $t: te
    };
    return Ze(P, {
      Ot: q
    }), G || r(U), U;
  }, ne = ({ _t: F, ft: G }) => {
    const te = !(F && !G) && k.U ? B : r, U = {
      _t: F || G,
      ft: G
    };
    L(U), te(U);
  }, W = (F, G) => {
    const [, q] = N(), te = {
      xt: q
    };
    return L(te), q && !G && (F ? r : B)(te), te;
  }, O = (F, G, q) => {
    const te = {
      Ht: G
    };
    return L(te), G && !q && B(te), te;
  }, [J, ee] = v ? AU(m, Z) : [], H = !y && LP(m, ne, {
    ft: !0
  }), [_, j] = p0(m, !1, O, {
    ct: f,
    et: f
  }), E = y && Ai && new Ai(((F) => {
    const G = F[F.length - 1].contentRect;
    ne({
      _t: !0,
      ft: TP(G, c)
    }), c = G;
  })), M = Fl((() => {
    const [, F] = N();
    r({
      xt: F,
      _t: x
    });
  }), {
    p: 222,
    S: !0
  });
  return [() => {
    E && E.observe(m);
    const F = H && H(), G = J && J(), q = _(), te = k.G(((U) => {
      U ? B({
        Et: U
      }) : M();
    }));
    return () => {
      E && E.disconnect(), F && F(), G && G(), a && a(), q(), te();
    };
  }, ({ zt: F, Tt: G, It: q }) => {
    const te = {}, [U] = F("update.ignoreMutation"), [K, ae] = F("update.attributes"), [Y, ce] = F("update.elementEvents"), [re, Ce] = F("update.debounce"), Ve = ce || ae, le = G || q, Pe = (ve) => tr(U) && U(ve);
    if (Ve) {
      s && s(), a && a();
      const [ve, he] = p0(v || h, !0, W, {
        et: ha(f, K || []),
        rt: Y,
        it: u,
        ut: (_e, Oe) => {
          const { target: ze, attributeName: Ye } = _e;
          return (!Oe && Ye && !y ? H8(ze, u, d) : !1) || !!Ei(ze, `.${Tn}`) || !!Pe(_e);
        }
      });
      a = ve(), s = he;
    }
    if (Ce)
      if (B.O(), Kn(re)) {
        const ve = re[0], he = re[1];
        o = $r(ve) && ve, i = $r(he) && he;
      } else $r(re) ? (o = re, i = !1) : (o = !1, i = !1);
    if (le) {
      const ve = j(), he = ee && ee(), _e = s && s();
      ve && Ze(te, O(ve[0], ve[1], le)), he && Ze(te, Z(he[0], le)), _e && Ze(te, W(_e[0], le));
    }
    return L(te), te;
  }, P];
}, zP = (e, t) => tr(t) ? t.apply(0, e) : t, EU = (e, t, n, r) => {
  const o = Um(r) ? n : r;
  return zP(e, o) || t.apply(0, e);
}, GP = (e, t, n, r) => {
  const o = Um(r) ? n : r, i = zP(e, o);
  return !!i && (Ml(i) ? i : t.apply(0, e));
}, RU = (e, t) => {
  const { nativeScrollbarsOverlaid: n, body: r } = t || {}, { k: o, U: i, K: s } = Cr(), { nativeScrollbarsOverlaid: a, body: c } = s().cancel, l = n ?? a, u = Um(r) ? c : r, d = (o.x || o.y) && l, f = e && (_u(u) ? !i : u);
  return !!d || !!f;
}, _U = (e, t, n, r) => {
  const o = "--os-viewport-percent", i = "--os-scroll-percent", s = "--os-scroll-direction", { K: a } = Cr(), { scrollbars: c } = a(), { slot: l } = c, { dt: u, vt: d, L: f, At: p, gt: m, bt: h, V: g } = t, { scrollbars: v } = p ? {} : e, { slot: y } = v || {}, x = [], S = [], C = [], w = GP([u, d, f], (() => g && h ? u : d), l, y), I = (_) => {
    if (Ds) {
      let j = null, E = [];
      const M = new Ds({
        source: m,
        axis: _
      }), F = () => {
        j && j.cancel(), j = null;
      };
      return {
        kt: (q) => {
          const { Dt: te } = n, U = yf(te)[_], K = _ === "x", ae = [bf(0, K), bf(`calc(100cq${K ? "w" : "h"} + -100%)`, K)], Y = U ? ae : ae.reverse();
          return E[0] === Y[0] && E[1] === Y[1] || (F(), E = Y, j = q.Mt.animate({
            clear: ["left"],
            transform: Y
          }, {
            timeline: M
          })), F;
        }
      };
    }
  }, P = {
    x: I("x"),
    y: I("y")
  }, k = () => {
    const { Rt: _, Vt: j } = n, E = (M, F) => bP(0, 1, M / (M + F) || 0);
    return {
      x: E(j.x, _.x),
      y: E(j.y, _.y)
    };
  }, A = (_, j, E) => {
    const M = E ? og : SP;
    lt(_, ((F) => {
      M(F.Lt, j);
    }));
  }, N = (_, j) => {
    lt(_, ((E) => {
      const [M, F] = j(E);
      ba(M, F);
    }));
  }, B = (_, j, E) => {
    const M = Ou(E), F = M ? E : !0, G = M ? !E : !0;
    F && A(S, _, j), G && A(C, _, j);
  }, L = () => {
    const _ = k(), j = (E) => (M) => [M.Lt, {
      [o]: Xp(E) + ""
    }];
    N(S, j(_.x)), N(C, j(_.y));
  }, Z = () => {
    if (!Ds) {
      const { Dt: _ } = n, j = n0(_, xn(m)), E = (M) => (F) => [F.Lt, {
        [i]: Xp(M) + ""
      }];
      N(S, E(j.x)), N(C, E(j.y));
    }
  }, ne = () => {
    const { Dt: _ } = n, j = yf(_), E = (M) => (F) => [F.Lt, {
      [s]: M ? "0" : "1"
    }];
    N(S, E(j.x)), N(C, E(j.y)), Ds && (S.forEach(P.x.kt), C.forEach(P.y.kt));
  }, W = () => {
    if (g && !h) {
      const { Rt: _, Dt: j } = n, E = yf(j), M = n0(j, xn(m)), F = (G) => {
        const { Lt: q } = G, te = ga(q) === f && q, U = (K, ae, Y) => {
          const ce = ae * K;
          return kP(Y ? ce : -ce);
        };
        return [te, te && {
          transform: bf({
            x: U(M.x, _.x, E.x),
            y: U(M.y, _.y, E.y)
          })
        }];
      };
      N(S, F), N(C, F);
    }
  }, O = (_) => {
    const j = _ ? "x" : "y", M = Gi(`${Tn} ${_ ? dU : fU}`), F = Gi(DP), G = Gi(ag), q = {
      Lt: M,
      Ut: F,
      Mt: G
    }, te = P[j];
    return Ct(_ ? S : C, q), Ct(x, [dn(M, F), dn(F, G), Be(ns, M), te && te.kt(q), r(q, B, _)]), q;
  }, J = Be(O, !0), ee = Be(O, !1), H = () => (dn(w, S[0].Lt), dn(w, C[0].Lt), Be(wn, x));
  return J(), ee(), [{
    Pt: L,
    Nt: Z,
    qt: ne,
    Bt: W,
    Ft: B,
    jt: {
      Xt: S,
      Yt: J,
      Wt: Be(N, S)
    },
    Jt: {
      Xt: C,
      Yt: ee,
      Wt: Be(N, C)
    }
  }, H];
}, OU = (e, t, n, r) => (o, i, s) => {
  const { vt: a, L: c, V: l, gt: u, Gt: d, St: f } = t, { Lt: p, Ut: m, Mt: h } = o, [g, v] = Ti(333), [y, x] = Ti(444), S = (I) => {
    tr(u.scrollBy) && u.scrollBy({
      behavior: "smooth",
      left: I.x,
      top: I.y
    });
  }, C = () => {
    const I = "pointerup pointercancel lostpointercapture", P = `client${s ? "X" : "Y"}`, k = s ? Mu : Bu, A = s ? "left" : "top", N = s ? "w" : "h", B = s ? "x" : "y", L = (ne, W) => (O) => {
      const { Rt: J } = n, ee = Wi(m)[N] - Wi(h)[N], _ = W * O / ee * J[B];
      fr(u, {
        [B]: ne + _
      });
    }, Z = [];
    return bt(m, "pointerdown", ((ne) => {
      const W = Ei(ne.target, `.${ag}`) === h, O = W ? h : m, J = e.scrollbars, ee = J[W ? "dragScroll" : "clickScroll"], { button: H, isPrimary: _, pointerType: j } = ne, { pointers: E } = J;
      if (H === 0 && _ && ee && (E || []).includes(j)) {
        wn(Z), x();
        const F = !W && (ne.shiftKey || ee === "instant"), G = Be(vf, h), q = Be(vf, m), te = (Oe, ze) => (Oe || G())[A] - (ze || q())[A], U = zp(vf(u)[k]) / Wi(u)[N] || 1, K = L(xn(u)[B], 1 / U), ae = ne[P], Y = G(), ce = q(), re = Y[k], Ce = te(Y, ce) + re / 2, Ve = ae - ce[A], le = W ? 0 : Ve - Ce, Pe = (Oe) => {
          wn(_e), O.releasePointerCapture(Oe.pointerId);
        }, ve = W || F, he = f(), _e = [bt(d, I, Pe), bt(d, "selectstart", ((Oe) => Zp(Oe)), {
          T: !1
        }), bt(m, I, Pe), ve && bt(m, "pointermove", ((Oe) => K(le + (Oe[P] - ae)))), ve && (() => {
          const Oe = xn(u);
          he();
          const ze = xn(u), Ye = {
            x: ze.x - Oe.x,
            y: ze.y - Oe.y
          };
          (_l(Ye.x) > 3 || _l(Ye.y) > 3) && (f(), fr(u, Oe), S(Ye), y(he));
        })];
        if (O.setPointerCapture(ne.pointerId), F)
          K(le);
        else if (!W) {
          const Oe = ls(xU);
          if (Oe) {
            const ze = Oe(K, le, re, ((Ye) => {
              Ye ? he() : Ct(_e, he);
            }));
            Ct(_e, ze), Ct(Z, Be(ze, !0));
          }
        }
      }
    }));
  };
  let w = !0;
  return Be(wn, [bt(h, "pointermove pointerleave", r), bt(p, "pointerenter", (() => {
    i(s0, !0);
  })), bt(p, "pointerleave pointercancel", (() => {
    i(s0, !1);
  })), !l && bt(p, "mousedown", (() => {
    const I = jp();
    (qy(I, Tr) || qy(I, no) || I === document.body) && Zm(Be(Up, c), 25);
  })), bt(p, "wheel", ((I) => {
    const { deltaX: P, deltaY: k, deltaMode: A } = I;
    w && A === 0 && ga(p) === a && S({
      x: P,
      y: k
    }), w = !1, i(l0, !0), g((() => {
      w = !0, i(l0);
    })), Zp(I);
  }), {
    T: !1,
    I: !0
  }), bt(p, "pointerdown", (() => {
    const I = bt(d, "click", ((k) => {
      P(), RP(k);
    }), {
      A: !0,
      I: !0,
      T: !1
    }), P = bt(d, "pointerup pointercancel", (() => {
      P(), setTimeout(I, 150);
    }), {
      I: !0,
      T: !0
    });
  }), {
    I: !0,
    T: !0
  }), C(), v, x]);
}, NU = (e, t, n, r, o, i) => {
  let s, a, c, l, u, d = ma, f = 0;
  const p = ["mouse", "pen"], m = (E) => p.includes(E.pointerType), [h, g] = Ti(), [v, y] = Ti(100), [x, S] = Ti(100), [C, w] = Ti((() => f)), [I, P] = _U(e, o, r, OU(t, o, r, ((E) => m(E) && J()))), { vt: k, Kt: A, bt: N } = o, { Ft: B, Pt: L, Nt: Z, qt: ne, Bt: W } = I, O = (E, M) => {
    if (w(), E)
      B(c0);
    else {
      const F = Be(B, c0, !0);
      f > 0 && !M ? C(F) : F();
    }
  }, J = () => {
    (c ? !s : !l) && (O(!0), v((() => {
      O(!1);
    })));
  }, ee = (E) => {
    B(qp, E, !0), B(qp, E, !1);
  }, H = (E) => {
    m(E) && (s = c, c && O(!0));
  }, _ = [w, y, S, g, () => d(), bt(k, "pointerover", H, {
    A: !0
  }), bt(k, "pointerenter", H), bt(k, "pointerleave", ((E) => {
    m(E) && (s = !1, c && O(!1));
  })), bt(k, "pointermove", ((E) => {
    m(E) && a && J();
  })), bt(A, "scroll", ((E) => {
    h((() => {
      Z(), J();
    })), i(E), W();
  }))], j = ls(cg);
  return [() => Be(wn, Ct(_, P())), ({ zt: E, It: M, Qt: F, Zt: G }) => {
    const { tn: q, nn: te, sn: U, en: K } = G || {}, { Ct: ae, ft: Y } = F || {}, { B: ce } = n, { k: re, U: Ce } = Cr(), { cn: Ve, j: le } = r, [Pe, ve] = E("showNativeOverlaidScrollbars"), [he, _e] = E("scrollbars.theme"), [Oe, ze] = E("scrollbars.visibility"), [Ye, Yt] = E("scrollbars.autoHide"), [Kt, tn] = E("scrollbars.autoHideSuspend"), [de] = E("scrollbars.autoHideDelay"), [Ue, pe] = E("scrollbars.dragScroll"), [Se, vt] = E("scrollbars.clickScroll"), [cn, me] = E("overflow"), ke = Y && !M, Re = le.x || le.y, Le = q || te || K || ae || M, Je = U || ze || me, qt = Pe && re.x && re.y, Wt = !Ce && !j, nn = qt || Wt, Qo = (vn, mo, ei) => {
      const nr = vn.includes(ts) && (Oe === Or || Oe === "auto" && mo === ts);
      return B(pU, nr, ei), nr;
    };
    if (f = de, ke && (Kt && Re ? (ee(!1), d(), x((() => {
      d = bt(A, "scroll", Be(ee, !0), {
        A: !0
      });
    }))) : ee(!0)), (ve || Wt) && B(lU, nn), _e && (B(u), B(he, !0), u = he), tn && !Kt && ee(!0), Yt && (a = Ye === "move", c = Ye === "leave", l = Ye === "never", O(l, !0)), pe && B(gU, Ue), vt && B(mU, !!Se), Je) {
      const vn = Qo(cn.x, Ve.x, !0), mo = Qo(cn.y, Ve.y, !1);
      B(hU, !(vn && mo));
    }
    Le && (Z(), L(), W(), K && ne(), B(a0, !le.x, !0), B(a0, !le.y, !1), B(uU, ce && !N));
  }, {}, I];
}, MU = (e) => {
  const t = Cr(), { K: n, U: r } = t, { elements: o } = n(), { padding: i, viewport: s, content: a } = o, c = Ml(e), l = c ? {} : e, { elements: u } = l, { padding: d, viewport: f, content: p } = u || {}, m = c ? e : l.target, h = CP(m), g = m.ownerDocument, v = g.documentElement, y = () => g.defaultView || fn, x = Be(EU, [m]), S = Be(GP, [m]), C = Be(Gi, ""), w = Be(x, C, s), I = Be(S, C, a), P = (re) => {
    const Ce = Wi(re), Ve = $l(re), le = vr(re, qm), Pe = vr(re, Qm);
    return Ve.w - Ce.w > 0 && !Ri(le) || Ve.h - Ce.h > 0 && !Ri(Pe);
  }, k = w(f), A = k === m, N = A && h, B = !A && I(p), L = !A && k === B, Z = N ? v : k, ne = N ? Z : m, W = !A && S(C, i, d), O = !L && B, J = [O, Z, W, ne].map(((re) => Ml(re) && !ga(re) && re)), ee = (re) => re && sP(J, re), H = !ee(Z) && P(Z) ? Z : m, _ = N ? v : Z, E = {
    dt: m,
    vt: ne,
    L: Z,
    rn: W,
    ht: O,
    gt: _,
    Kt: N ? g : Z,
    ln: h ? v : H,
    Gt: g,
    bt: h,
    At: c,
    V: A,
    an: y,
    wt: (re) => rg(Z, Tr, re),
    yt: (re, Ce) => Dl(Z, Tr, re, Ce),
    St: () => Dl(_, Tr, oU, !0)
  }, { dt: M, vt: F, rn: G, L: q, ht: te } = E, U = [() => {
    sr(F, [no, Sf]), sr(M, Sf), h && sr(v, [Sf, no]);
  }];
  let K = Hp([te, q, G, F, M].find(((re) => re && !ee(re))));
  const ae = N ? M : te || q, Y = Be(wn, U);
  return [E, () => {
    const re = y(), Ce = jp(), Ve = (_e) => {
      dn(ga(_e), Hp(_e)), ns(_e);
    }, le = (_e) => bt(_e, "focusin focusout focus blur", RP, {
      I: !0,
      T: !1
    }), Pe = "tabindex", ve = tg(q, Pe), he = le(Ce);
    return Ar(F, no, A ? "" : eU), Ar(G, Kp, ""), Ar(q, Tr, ""), Ar(te, i0, ""), A || (Ar(q, Pe, ve || "-1"), h && Ar(v, o0, "")), dn(ae, K), dn(F, G), dn(G || F, !A && q), dn(q, te), Ct(U, [he, () => {
      const _e = jp(), Oe = ee(q), ze = Oe && _e === q ? M : _e, Ye = le(ze);
      sr(G, Kp), sr(te, i0), sr(q, Tr), h && sr(v, o0), ve ? Ar(q, Pe, ve) : sr(q, Pe), ee(te) && Ve(te), Oe && Ve(q), ee(G) && Ve(G), Up(ze), Ye();
    }]), r && !A && (ng(q, Tr, FP), Ct(U, Be(sr, q, Tr))), Up(!A && h && Ce === M && re.top === re ? q : Ce), he(), K = 0, Y;
  }, Y];
}, BU = ({ ht: e }) => ({ Qt: t, un: n, It: r }) => {
  const { $t: o } = t || {}, { Ot: i } = n;
  e && (o || r) && ba(e, {
    [Bu]: i && "100%"
  });
}, FU = ({ vt: e, rn: t, L: n, V: r }, o) => {
  const [i, s] = Sn({
    i: G8,
    o: e0()
  }, Be(e0, e, "padding", ""));
  return ({ zt: a, Qt: c, un: l, It: u }) => {
    let [d, f] = s(u);
    const { U: p } = Cr(), { _t: m, xt: h, Ct: g } = c || {}, { B: v } = l, [y, x] = a("paddingAbsolute");
    (m || f || (u || h)) && ([d, f] = i(u));
    const C = !r && (x || g || f);
    if (C) {
      const w = !y || !t && !p, I = d.r + d.l, P = d.t + d.b, k = {
        [fP]: w && !v ? -I : 0,
        [pP]: w ? -P : 0,
        [dP]: w && v ? -I : 0,
        top: w ? -d.t : 0,
        right: w ? v ? -d.r : "auto" : 0,
        left: w ? v ? "auto" : -d.l : 0,
        [Mu]: w && `calc(100% + ${I}px)`
      }, A = {
        [aP]: w ? d.t : 0,
        [cP]: w ? d.r : 0,
        [uP]: w ? d.b : 0,
        [lP]: w ? d.l : 0
      };
      ba(t || n, k), ba(n, A), Ze(o, {
        rn: d,
        fn: !w,
        F: t ? A : Ze({}, k, A)
      });
    }
    return {
      _n: C
    };
  };
}, DU = (e, t) => {
  const n = Cr(), { vt: r, rn: o, L: i, V: s, Kt: a, gt: c, bt: l, yt: u, an: d } = e, { U: f } = n, p = l && s, m = Be(rP, 0), h = {
    display: () => !1,
    direction: (E) => E !== "ltr",
    flexDirection: (E) => E.endsWith("-reverse"),
    writingMode: (E) => E !== "horizontal-tb"
  }, g = qn(h), v = {
    i: hP,
    o: {
      w: 0,
      h: 0
    }
  }, y = {
    i: qc,
    o: {}
  }, x = (E) => {
    u(BP, !p && E);
  }, S = (E) => {
    if (!g.some(((Y) => {
      const ce = E[Y];
      return ce && h[Y](ce);
    })))
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    x(!0);
    const F = xn(c), G = u(iU, !0), q = bt(a, ts, ((Y) => {
      const ce = xn(c);
      Y.isTrusted && ce.x === F.x && ce.y === F.y && EP(Y);
    }), {
      I: !0,
      A: !0
    });
    fr(c, {
      x: 0,
      y: 0
    }), G();
    const te = xn(c), U = $l(c);
    fr(c, {
      x: U.w,
      y: U.h
    });
    const K = xn(c);
    fr(c, {
      x: K.x - te.x < 1 && -U.w,
      y: K.y - te.y < 1 && -U.h
    });
    const ae = xn(c);
    return fr(c, F), Ym((() => q())), {
      D: te,
      M: ae
    };
  }, C = (E, M) => {
    const F = fn.devicePixelRatio % 1 !== 0 ? 1 : 0, G = {
      w: m(E.w - M.w),
      h: m(E.h - M.h)
    };
    return {
      w: G.w > F ? G.w : 0,
      h: G.h > F ? G.h : 0
    };
  }, w = (E, M) => {
    const F = (G, q, te, U) => {
      const K = G === Or ? Yn : yU(G), ae = Ri(G), Y = Ri(te);
      return !q && !U ? Yn : ae && Y ? Or : ae ? q && U ? K : q ? Or : Yn : q ? K : Y && U ? Or : Yn;
    };
    return {
      x: F(M.x, E.x, M.y, E.y),
      y: F(M.y, E.y, M.x, E.x)
    };
  }, I = (E) => {
    const M = (G) => [Or, Yn, ts].map(((q) => j(Qp(q), G))), F = M(!0).concat(M()).join(" ");
    u(F), u(qn(E).map(((G) => j(E[G], G === "x"))).join(" "), !0);
  }, [P, k] = Sn(v, Be(ig, i)), [A, N] = Sn(v, Be($l, i)), [B, L] = Sn(v), [Z] = Sn(y), [ne, W] = Sn(v), [O] = Sn(y), [J] = Sn({
    i: (E, M) => Fu(E, M, g),
    o: {}
  }, (() => J8(i) ? vr(i, g) : {})), [ee, H] = Sn({
    i: (E, M) => qc(E.D, M.D) && qc(E.M, M.M),
    o: _P()
  }), _ = ls(cg), j = (E, M) => `${M ? tU : nU}${z8(E)}`;
  return ({ zt: E, Qt: M, un: F, It: G }, { _n: q }) => {
    const { _t: te, Ht: U, xt: K, Ct: ae, ft: Y, Et: ce } = M || {}, re = _ && _.R(e, t, F, n, E), { X: Ce, Y: Ve, W: le } = re || {}, [Pe, ve] = vU(E, n), [he, _e] = E("overflow"), Oe = Ri(he.x), ze = Ri(he.y), Ye = te || q || K || ae || ce || ve;
    let Yt = k(G), Kt = N(G), tn = L(G), de = W(G);
    if (ve && f && u(FP, !Pe), Ye) {
      rg(r, no, el) && x(!0);
      const Rn = Ve && Ve(), [ti] = Yt = P(G), [ni] = Kt = A(G), ri = AP(i), oi = p && U8(d()), Zu = {
        w: m(ni.w + ti.w),
        h: m(ni.h + ti.h)
      }, Ir = {
        w: m((oi ? oi.w : ri.w + m(ri.w - ni.w)) + ti.w),
        h: m((oi ? oi.h : ri.h + m(ri.h - ni.h)) + ti.h)
      };
      Rn && Rn(), de = ne(Ir), tn = B(C(Zu, Ir), G);
    }
    const [Ue, pe] = de, [Se, vt] = tn, [cn, me] = Kt, [ke, Re] = Yt, [Le, Je] = Z({
      x: Se.w > 0,
      y: Se.h > 0
    }), qt = Oe && ze && (Le.x || Le.y) || Oe && Le.x && !Le.y || ze && Le.y && !Le.x, Wt = q || ae || ce || Re || me || pe || vt || _e || ve || Ye || U && p, [nn, Qo] = J(G), vn = ae || Y || Qo || Je || G, [mo, ei] = vn ? ee(S(nn), G) : H();
    let nr = w(Le, he);
    x(!1), Wt && (I(nr), nr = SU(i, Le), le && Ce && (Ce(nr, cn, ke), ba(i, le(nr))));
    const [Xu, Yu] = O(nr);
    return Dl(r, no, el, qt), Dl(o, Kp, el, qt), Ze(t, {
      cn: Xu,
      Vt: {
        x: Ue.w,
        y: Ue.h
      },
      Rt: {
        x: Se.w,
        y: Se.h
      },
      j: Le,
      Dt: K8(mo, Se)
    }), {
      sn: Yu,
      tn: pe,
      nn: vt,
      en: ei || vt
    };
  };
}, $U = (e) => {
  const [t, n, r] = MU(e), o = {
    rn: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    fn: !1,
    F: {
      [fP]: 0,
      [pP]: 0,
      [dP]: 0,
      [aP]: 0,
      [cP]: 0,
      [uP]: 0,
      [lP]: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    Rt: {
      x: 0,
      y: 0
    },
    cn: {
      x: Yn,
      y: Yn
    },
    j: {
      x: !1,
      y: !1
    },
    Dt: _P()
  }, { dt: i, gt: s, V: a, St: c } = t, { U: l, k: u } = Cr(), d = !l && (u.x || u.y), f = [BU(t), FU(t, o), DU(t, o)];
  return [n, (p) => {
    const m = {}, g = d && xn(s), v = g && c();
    return lt(f, ((y) => {
      Ze(m, y(p, m) || {});
    })), fr(s, g), v && v(), a || fr(i, 0), m;
  }, o, t, r];
}, VU = (e, t, n, r, o) => {
  let i = !1;
  const s = f0(t, {}), [a, c, l, u, d] = $U(e), [f, p, m] = TU(u, l, s, ((S) => {
    x({}, S);
  })), [h, g, , v] = NU(e, t, m, l, u, o), y = (S) => qn(S).some(((C) => !!S[C])), x = (S, C) => {
    if (n())
      return !1;
    const { dn: w, It: I, Tt: P, pn: k } = S, A = w || {}, N = !!I || !i, B = {
      zt: f0(t, A, N),
      dn: A,
      It: N
    };
    if (k)
      return g(B), !1;
    const L = C || p(Ze({}, B, {
      Tt: P
    })), Z = c(Ze({}, B, {
      un: m,
      Qt: L
    }));
    g(Ze({}, B, {
      Qt: L,
      Zt: Z
    }));
    const ne = y(L), W = y(Z), O = ne || W || !eg(A) || N;
    return i = !0, O && r(S, {
      Qt: L,
      Zt: Z
    }), O;
  };
  return [() => {
    const { ln: S, gt: C, St: w } = u, I = xn(S), P = [f(), a(), h()], k = w();
    return fr(C, I), k(), Be(wn, P);
  }, x, () => ({
    vn: m,
    gn: l
  }), {
    hn: u,
    bn: v
  }, d];
}, lg = /* @__PURE__ */ new WeakMap(), LU = (e, t) => {
  lg.set(e, t);
}, zU = (e) => {
  lg.delete(e);
}, WP = (e) => lg.get(e), Zn = (e, t, n) => {
  const { tt: r } = Cr(), o = Ml(e), i = o ? e : e.target, s = WP(i);
  if (t && !s) {
    let a = !1;
    const c = [], l = {}, u = (A) => {
      const N = gP(A), B = ls(Q8);
      return B ? B(N, !0) : N;
    }, d = Ze({}, r(), u(t)), [f, p, m] = Jp(), [h, g, v] = Jp(n), y = (A, N) => {
      v(A, N), m(A, N);
    }, [x, S, C, w, I] = VU(e, d, (() => a), (({ dn: A, It: N }, { Qt: B, Zt: L }) => {
      const { _t: Z, Ct: ne, $t: W, xt: O, Ht: J, ft: ee } = B, { tn: H, nn: _, sn: j, en: E } = L;
      y("updated", [k, {
        updateHints: {
          sizeChanged: !!Z,
          directionChanged: !!ne,
          heightIntrinsicChanged: !!W,
          overflowEdgeChanged: !!H,
          overflowAmountChanged: !!_,
          overflowStyleChanged: !!j,
          scrollCoordinatesChanged: !!E,
          contentMutation: !!O,
          hostMutation: !!J,
          appear: !!ee
        },
        changedOptions: A || {},
        force: !!N
      }]);
    }), ((A) => y("scroll", [k, A]))), P = (A) => {
      zU(i), wn(c), a = !0, y("destroyed", [k, A]), p(), g();
    }, k = {
      options(A, N) {
        if (A) {
          const B = N ? r() : {}, L = $P(d, Ze(B, u(A)));
          eg(L) || (Ze(d, L), S({
            dn: L
          }));
        }
        return Ze({}, d);
      },
      on: h,
      off: (A, N) => {
        A && N && g(A, N);
      },
      state() {
        const { vn: A, gn: N } = C(), { B } = A, { Vt: L, Rt: Z, cn: ne, j: W, rn: O, fn: J, Dt: ee } = N;
        return Ze({}, {
          overflowEdge: L,
          overflowAmount: Z,
          overflowStyle: ne,
          hasOverflow: W,
          scrollCoordinates: {
            start: ee.D,
            end: ee.M
          },
          padding: O,
          paddingAbsolute: J,
          directionRTL: B,
          destroyed: a
        });
      },
      elements() {
        const { dt: A, vt: N, rn: B, L, ht: Z, gt: ne, Kt: W } = w.hn, { jt: O, Jt: J } = w.bn, ee = (_) => {
          const { Mt: j, Ut: E, Lt: M } = _;
          return {
            scrollbar: M,
            track: E,
            handle: j
          };
        }, H = (_) => {
          const { Xt: j, Yt: E } = _, M = ee(j[0]);
          return Ze({}, M, {
            clone: () => {
              const F = ee(E());
              return S({
                pn: !0
              }), F;
            }
          });
        };
        return Ze({}, {
          target: A,
          host: N,
          padding: B || L,
          viewport: L,
          content: Z || L,
          scrollOffsetElement: ne,
          scrollEventElement: W,
          scrollbarHorizontal: H(O),
          scrollbarVertical: H(J)
        });
      },
      update: (A) => S({
        It: A,
        Tt: !0
      }),
      destroy: Be(P, !1),
      plugin: (A) => l[qn(A)[0]]
    };
    return Ct(c, [I]), LU(i, k), MP(OP, Zn, [k, f, l]), RU(w.hn.bt, !o && e.cancel) ? (P(!0), k) : (Ct(c, x()), y("initialized", [k]), k.update(), k);
  }
  return s;
};
Zn.plugin = (e) => {
  const t = Kn(e), n = t ? e : [e], r = n.map(((o) => MP(o, Zn)[0]));
  return q8(n), t ? r : r[0];
};
Zn.valid = (e) => {
  const t = e && e.elements, n = tr(t) && t();
  return Nl(n) && !!WP(n.target);
};
Zn.env = () => {
  const { P: e, k: t, U: n, J: r, ot: o, st: i, K: s, Z: a, tt: c, nt: l } = Cr();
  return Ze({}, {
    scrollbarsSize: e,
    scrollbarsOverlaid: t,
    scrollbarsHiding: n,
    scrollTimeline: r,
    staticDefaultInitialization: o,
    staticDefaultOptions: i,
    getDefaultInitialization: s,
    setDefaultInitialization: a,
    getDefaultOptions: c,
    setDefaultOptions: l
  });
};
Zn.nonce = wU;
Zn.trustedTypePolicy = X8;
const GU = () => {
  if (typeof window > "u") {
    const l = () => {
    };
    return [l, l];
  }
  let e, t;
  const n = window, r = typeof n.requestIdleCallback == "function", o = n.requestAnimationFrame, i = n.cancelAnimationFrame, s = r ? n.requestIdleCallback : o, a = r ? n.cancelIdleCallback : i, c = () => {
    a(e), i(t);
  };
  return [
    (l, u) => {
      c(), e = s(
        r ? () => {
          c(), t = o(l);
        } : l,
        typeof u == "object" ? u : { timeout: 2233 }
      );
    },
    c
  ];
}, HP = (e) => {
  const { options: t, events: n, defer: r } = e || {}, [o, i] = be(GU, []), s = se(null), a = se(r), c = se(t), l = se(n);
  return ge(() => {
    a.current = r;
  }, [r]), ge(() => {
    const { current: u } = s;
    c.current = t, Zn.valid(u) && u.options(t || {}, !0);
  }, [t]), ge(() => {
    const { current: u } = s;
    l.current = n, Zn.valid(u) && u.on(n || {}, !0);
  }, [n]), ge(
    () => () => {
      var u;
      i(), (u = s.current) == null || u.destroy();
    },
    []
  ), be(
    () => [
      (u) => {
        const d = s.current;
        if (Zn.valid(d))
          return;
        const f = a.current, p = c.current || {}, m = l.current || {}, h = () => s.current = Zn(u, p, m);
        f ? o(h, f) : h();
      },
      () => s.current
    ],
    []
  );
}, WU = (e, t) => {
  const { element: n = "div", options: r, events: o, defer: i, children: s, ...a } = e, c = n, l = se(null), u = se(null), [d, f] = HP({ options: r, events: o, defer: i });
  return ge(() => {
    const { current: p } = l, { current: m } = u;
    if (!p)
      return;
    const h = p;
    return d(
      n === "body" ? {
        target: h,
        cancel: {
          body: null
        }
      } : {
        target: h,
        elements: {
          viewport: m,
          content: m
        }
      }
    ), () => {
      var g;
      return (g = f()) == null ? void 0 : g.destroy();
    };
  }, [d, n]), nA(
    t,
    () => ({
      osInstance: f,
      getElement: () => l.current
    }),
    []
  ), // @ts-ignore
  /* @__PURE__ */ At.createElement(c, { "data-overlayscrollbars-initialize": "", ref: l, ...a }, n === "body" ? s : /* @__PURE__ */ At.createElement("div", { "data-overlayscrollbars-contents": "", ref: u }, s));
};
_t(WU);
const HU = {
  defer: !0,
  options: {
    scrollbars: {
      visibility: "auto",
      autoHide: "scroll",
      autoHideDelay: 1300,
      theme: "os-theme-dark",
      clickScroll: !0
    },
    overflow: { x: "hidden" }
  }
}, jU = {
  options: { scrollbars: { autoHide: "never" } }
}, XU = w6(Np(HU), jU), jP = ut((e) => {
  const { children: t, viewport: n } = e, r = se(null), [o, i] = HP(XU);
  return ge(() => (r.current && n && o({
    target: r.current,
    elements: {
      viewport: n
    }
  }), () => i()?.destroy()), [n, o, i]), /* @__PURE__ */ b(Rt, { ref: r, "data-overlayscrollbars": "", border: "none", shadow: "dark-lg", borderRadius: "md", p: 1, children: t });
});
jP.displayName = "Scrollable";
const XP = ut(({ children: e, innerRef: t, ...n }) => {
  const [r, o] = ue(null);
  return ge(() => {
    !t || !(t instanceof Function) || t(r);
  }, [t, r]), /* @__PURE__ */ b(jP, { viewport: r, children: /* @__PURE__ */ b(Rl.MenuList, { ...n, innerRef: o, children: e }) });
});
XP.displayName = "CustomMenuListComponent";
const YP = ut(({ children: e, ...t }) => (delete t.innerProps.onMouseMove, delete t.innerProps.onMouseOver, t.data.icon ? /* @__PURE__ */ b(Rl.Option, { ...t, children: /* @__PURE__ */ b(so, { label: t.data.tooltip, children: /* @__PURE__ */ Ae(Pi, { w: "full", h: "full", p: 1, ps: 2, pe: 2, children: [
  /* @__PURE__ */ b(Pi, { ps: 1, pe: 3, alignItems: "center", justifyContent: "center", children: t.data.icon }),
  /* @__PURE__ */ Ae(Pi, { flexDir: "column", children: [
    /* @__PURE__ */ b(To, { fontWeight: t.data.description ? "semibold" : void 0, children: e }),
    t.data.description && /* @__PURE__ */ b(To, { "data-option-desc": !0, fontSize: "sm", colorScheme: "base", variant: "subtext", noOfLines: 2, children: t.data.description })
  ] })
] }) }) }) : /* @__PURE__ */ b(Rl.Option, { ...t, children: /* @__PURE__ */ b(so, { label: t.data.tooltip, children: /* @__PURE__ */ Ae(Pi, { w: "full", h: "full", flexDir: "column", p: 1, px: 4, children: [
  /* @__PURE__ */ b(To, { fontWeight: t.data.description ? "semibold" : void 0, children: e }),
  t.data.description && /* @__PURE__ */ b(To, { "data-option-desc": !0, fontSize: "sm", colorScheme: "base", variant: "subtext", noOfLines: 2, children: t.data.description })
] }) }) })));
YP.displayName = "CustomOptionComponent";
const YU = {
  menuPortal: (e) => ({ ...e, zIndex: 9999 })
}, ZU = {
  Option: YP,
  MenuList: XP
}, UU = ut((e) => {
  const { sx: t, selectRef: n, inputRef: r, ...o } = e, i = be(
    () => ({
      container: (s, a) => ({ ...s, w: "full", ...t }),
      option: (s, a) => ({ ...s, p: 0 }),
      indicatorsContainer: (s, a) => ({
        ...s,
        w: 8,
        alignItems: "center",
        justifyContent: "center",
        "> div": { p: 0, w: "full", h: "full", bg: "unset" }
      }),
      dropdownIndicator: (s, a) => ({
        ...s,
        display: a.hasValue && a.selectProps.isClearable ? "none" : "flex"
      }),
      crossIcon: (s, a) => ({ ...s, boxSize: 2.5 }),
      inputContainer: (s, a) => ({
        ...s,
        cursor: "pointer"
      })
    }),
    [t]
  );
  return ge(() => {
    r && (r.current = n?.current?.inputRef ?? null);
  }, [r, n]), /* @__PURE__ */ b(
    D8,
    {
      ref: n,
      menuPortalTarget: document.body,
      colorScheme: "base",
      selectedOptionColorScheme: "base",
      components: ZU,
      chakraStyles: i,
      styles: YU,
      variant: "filled",
      menuPosition: "fixed",
      ...o
    }
  );
});
UU.displayName = "Combobox";
const JU = ut((e) => /* @__PURE__ */ b(Pi, { h: 8, alignItems: "center", justifyContent: "center", children: /* @__PURE__ */ b(To, { fontSize: "sm", color: "base.500", children: e.label }) }));
JU.displayName = "ComboboxFallback";
let KU = Symbol("clean"), jn = [], Zr = 0;
const Sc = 4;
let La = (e) => {
  let t = [], n = {
    get() {
      return n.lc || n.listen(() => {
      })(), n.value;
    },
    lc: 0,
    listen(r) {
      return n.lc = t.push(r), () => {
        for (let i = Zr + Sc; i < jn.length; )
          jn[i] === r ? jn.splice(i, Sc) : i += Sc;
        let o = t.indexOf(r);
        ~o && (t.splice(o, 1), --n.lc || n.off());
      };
    },
    notify(r, o) {
      let i = !jn.length;
      for (let s of t)
        jn.push(s, n.value, r, o);
      if (i) {
        for (Zr = 0; Zr < jn.length; Zr += Sc)
          jn[Zr](
            jn[Zr + 1],
            jn[Zr + 2],
            jn[Zr + 3]
          );
        jn.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let o = n.value;
      o !== r && (n.value = r, n.notify(o));
    },
    subscribe(r) {
      let o = n.listen(r);
      return r(n.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (n[KU] = () => {
    t = [], n.lc = 0, n.off();
  }), n;
};
function qU(e, t, n) {
  let r = new Set(t).add(void 0);
  return e.listen((o, i, s) => {
    r.has(s) && n(o, i, s);
  });
}
const ws = La([]), QU = (e) => (ge(() => {
  if (e)
    return ws.set([...ws.get(), e]), () => {
      ws.set(ws.get().filter((n) => n !== e));
    };
}, [e]), { onCloseGlobal: R(() => {
  ws.get().forEach((n) => n());
}, []) });
let Cf = (e, t) => (n) => {
  e.current !== n && (e.current = n, t());
};
function Vu(e, { keys: t, deps: n = [e, t] } = {}) {
  let r = se();
  r.current = e.get();
  let o = R((s) => (Cf(r, s)(e.value), t?.length > 0 ? qU(e, t, Cf(r, s)) : e.listen(Cf(r, s))), n), i = () => r.current;
  return E0(o, i, i);
}
const If = /* @__PURE__ */ new Set();
function eJ(e) {
  ge(() => {
    if (If.has(e))
      throw new Error(`There should be only one instance of ${String(e)}`);
    return If.add(e), () => {
      If.delete(e);
    };
  }, [e]);
}
const Lu = La(!1), zu = La(!1), Gu = La(!1), Wu = La(!1), xc = (e) => {
  Lu.set(e.shiftKey), zu.set(e.ctrlKey), Wu.set(e.altKey), Gu.set(e.metaKey);
}, h0 = () => {
  Lu.set(!1), zu.set(!1), Wu.set(!1), Gu.set(!1);
}, tJ = Symbol("useGlobalModifiersInit"), iee = () => {
  eJ(tJ), ge(() => (window.addEventListener("keydown", xc), window.addEventListener("keyup", xc), window.addEventListener("blur", h0), () => {
    window.removeEventListener("keydown", xc), window.removeEventListener("keyup", xc), window.removeEventListener("blur", h0);
  }), []);
}, nJ = (e) => {
  Lu.set(e);
}, rJ = (e) => {
  zu.set(e);
}, oJ = (e) => {
  Wu.set(e);
}, iJ = (e) => {
  Gu.set(e);
}, ug = () => ({ setShift: nJ, setCtrl: rJ, setAlt: oJ, setMeta: iJ }), dg = () => Vu(Lu), see = () => Vu(zu), aee = () => Vu(Wu), cee = () => Vu(Gu), sJ = EC({
  displayName: "ChevronDownIcon",
  d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), aJ = EC({
  d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z",
  displayName: "ChevronUpIcon"
}), cJ = X((e, t) => {
  const n = Xt();
  return /* @__PURE__ */ Ae(It, { ref: t, viewBox: "0 0 24 24", ...e, children: [
    /* @__PURE__ */ b("defs", { children: /* @__PURE__ */ Ae(
      "linearGradient",
      {
        x1: "28.154%",
        y1: "63.74%",
        x2: "74.629%",
        y2: "17.783%",
        id: n,
        children: [
          /* @__PURE__ */ b("stop", { stopColor: "currentColor", offset: "0%" }),
          /* @__PURE__ */ b("stop", { stopColor: "#fff", stopOpacity: "0", offset: "100%" })
        ]
      }
    ) }),
    /* @__PURE__ */ Ae("g", { transform: "translate(2)", fill: "none", children: [
      /* @__PURE__ */ b("circle", { stroke: `url(#${n})`, strokeWidth: "4", cx: "10", cy: "12", r: "10" }),
      /* @__PURE__ */ b(
        "path",
        {
          d: "M10 2C4.477 2 0 6.477 0 12",
          stroke: "currentColor",
          strokeWidth: "4"
        }
      ),
      /* @__PURE__ */ b("rect", { fill: "currentColor", x: "8", width: "4", height: "4", rx: "8" })
    ] })
  ] });
}), lJ = An`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, uJ = `${lJ} 1s linear infinite`, dJ = An`
  0% {
    transform: rotate(0deg);
  }
  20%, 50% {
    transform: rotate(180deg);
  }
  70%, 100% {
    transform: rotate(360deg);
  }
`, lee = `${dJ} 4s ease infinite`;
function Pt(e, t, n = !1) {
  e = String(e), t = String(t);
  const r = Array.from({ length: 21 }, (s, a) => a * 50), o = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 59, 64, 68, 73, 77, 82, 86, 95, 100];
  return r.reduce((s, a, c) => {
    const l = n ? o[c] / 100 : 1, u = n ? 50 : o[r.length - 1 - c];
    return s[a] = `hsl(${e} ${t}% ${u}% / ${l})`, s;
  }, {});
}
const Fe = {
  base: { H: 220, S: 12 },
  working: { H: 47, S: 42 },
  gold: { H: 40, S: 70 },
  warning: { H: 28, S: 42 },
  ok: { H: 113, S: 42 },
  error: { H: 0, S: 42 },
  invokeYellow: { H: 66, S: 92 },
  invokeBlue: { H: 200, S: 76 },
  invokeGreen: { H: 110, S: 69 },
  invokeRed: { H: 16, S: 92 },
  invokePurple: { H: 260, S: 58 }
}, uee = (e) => `hsl(${Fe.base.H} ${Fe.base.S}% ${e}%)`, fJ = {
  base: Pt(Fe.base.H, Fe.base.S),
  baseAlpha: Pt(Fe.base.H, Fe.base.S, !0),
  working: Pt(Fe.working.H, Fe.working.S),
  workingAlpha: Pt(Fe.working.H, Fe.working.S, !0),
  gold: Pt(Fe.gold.H, Fe.gold.S),
  goldAlpha: Pt(Fe.gold.H, Fe.gold.S, !0),
  warning: Pt(Fe.warning.H, Fe.warning.S),
  warningAlpha: Pt(Fe.warning.H, Fe.warning.S, !0),
  ok: Pt(Fe.ok.H, Fe.ok.S),
  okAlpha: Pt(Fe.ok.H, Fe.ok.S, !0),
  error: Pt(Fe.error.H, Fe.error.S),
  errorAlpha: Pt(Fe.error.H, Fe.error.S, !0),
  invokeYellow: Pt(Fe.invokeYellow.H, Fe.invokeYellow.S),
  invokeYellowAlpha: Pt(Fe.invokeYellow.H, Fe.invokeYellow.S, !0),
  invokeBlue: Pt(Fe.invokeBlue.H, Fe.invokeBlue.S),
  invokeBlueAlpha: Pt(Fe.invokeBlue.H, Fe.invokeBlue.S, !0),
  invokeGreen: Pt(Fe.invokeGreen.H, Fe.invokeGreen.S),
  invokeGreenAlpha: Pt(Fe.invokeGreen.H, Fe.invokeGreen.S, !0),
  invokeRed: Pt(Fe.invokeRed.H, Fe.invokeRed.S),
  invokeRedAlpha: Pt(Fe.invokeRed.H, Fe.invokeRed.S, !0),
  invokePurple: Pt(Fe.invokePurple.H, Fe.invokePurple.S),
  invokePurpleAlpha: Pt(Fe.invokePurple.H, Fe.invokePurple.S, !0)
};
function ot(e, t = {}) {
  let n = !1;
  function r() {
    if (!n) {
      n = !0;
      return;
    }
    throw new Error(
      "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
    );
  }
  function o(...u) {
    r();
    for (const d of u)
      t[d] = c(d);
    return ot(e, t);
  }
  function i(...u) {
    for (const d of u)
      d in t || (t[d] = c(d));
    return ot(e, t);
  }
  function s() {
    return Object.fromEntries(
      Object.entries(t).map(([d, f]) => [d, f.selector])
    );
  }
  function a() {
    return Object.fromEntries(
      Object.entries(t).map(([d, f]) => [d, f.className])
    );
  }
  function c(u) {
    const p = `chakra-${(["container", "root"].includes(u ?? "") ? [e] : [e, u]).filter(Boolean).join("__")}`;
    return {
      className: p,
      selector: `.${p}`,
      toString: () => u
    };
  }
  return {
    parts: o,
    toPart: c,
    extend: i,
    selectors: s,
    classnames: a,
    get keys() {
      return Object.keys(t);
    },
    __type: {}
  };
}
const pJ = ot("accordion").parts(
  "root",
  "container",
  "button",
  "panel",
  "icon"
);
ot("alert").parts(
  "title",
  "description",
  "container",
  "icon",
  "spinner"
);
ot("avatar").parts(
  "label",
  "badge",
  "container",
  "excessLabel",
  "group"
);
ot("breadcrumb").parts(
  "link",
  "item",
  "container",
  "separator"
);
ot("button").parts();
const hJ = ot("checkbox").parts(
  "control",
  "icon",
  "container",
  "label"
);
ot("progress").parts(
  "track",
  "filledTrack",
  "label"
);
ot("drawer").parts(
  "overlay",
  "dialogContainer",
  "dialog",
  "header",
  "closeButton",
  "body",
  "footer"
);
const mJ = ot("editable").parts(
  "preview",
  "input",
  "textarea"
), gJ = ot("form").parts(
  "container",
  "requiredIndicator",
  "helperText"
), bJ = ot("formError").parts("text", "icon"), vJ = ot("input").parts(
  "addon",
  "field",
  "element",
  "group"
);
ot("list").parts("container", "item", "icon");
const yJ = ot("menu").parts(
  "button",
  "list",
  "item",
  "groupTitle",
  "icon",
  "command",
  "divider"
), SJ = ot("modal").parts(
  "overlay",
  "dialogContainer",
  "dialog",
  "header",
  "closeButton",
  "body",
  "footer"
), xJ = ot("numberinput").parts(
  "root",
  "field",
  "stepperGroup",
  "stepper"
);
ot("pininput").parts("field");
const CJ = ot("popover").parts(
  "content",
  "header",
  "body",
  "footer",
  "popper",
  "arrow",
  "closeButton"
), IJ = ot("progress").parts(
  "label",
  "filledTrack",
  "track"
);
ot("radio").parts(
  "container",
  "control",
  "label"
);
ot("select").parts("field", "icon");
const wJ = ot("slider").parts(
  "container",
  "track",
  "thumb",
  "filledTrack",
  "mark"
);
ot("stat").parts(
  "container",
  "label",
  "helpText",
  "number",
  "icon"
);
const PJ = ot("switch").parts(
  "container",
  "track",
  "thumb",
  "label"
);
ot("table").parts(
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "tfoot",
  "caption"
);
const kJ = ot("tabs").parts(
  "root",
  "tab",
  "tablist",
  "tabpanel",
  "tabpanels",
  "indicator"
);
ot("tag").parts(
  "container",
  "label",
  "closeButton"
);
const AJ = ot("card").parts(
  "container",
  "header",
  "body",
  "footer"
);
ot("stepper").parts(
  "stepper",
  "step",
  "title",
  "description",
  "indicator",
  "separator",
  "icon",
  "number"
);
function En(e) {
  return {
    definePartsStyle(t) {
      return t;
    },
    defineMultiStyleConfig(t) {
      return { parts: e, ...t };
    }
  };
}
function TJ(e, t, n) {
  return e.__cssMap?.[`${t}.${n}`]?.varRef ?? n;
}
const { definePartsStyle: ZP, defineMultiStyleConfig: EJ } = En(pJ.keys), RJ = {
  border: "none",
  bg: "base.850",
  borderRadius: "base",
  ":has(&div &button:hover)": { bg: "base.800" },
  transitionProperty: "common",
  transitionDuration: "0.1s"
}, _J = (e) => ({
  gap: 2,
  fontWeight: "semibold",
  fontSize: "sm",
  border: "none",
  borderRadius: "base",
  color: "base.300",
  _hover: {},
  _expanded: {
    borderBottomRadius: "none"
  }
}), OJ = (e) => {
  const { colorScheme: t } = e;
  return {
    bg: `${t}.800`,
    borderRadius: "base",
    p: 0,
    transitionProperty: "common",
    transitionDuration: "0.1s"
  };
}, NJ = {
  ms: 2
}, MJ = ZP((e) => ({
  container: RJ,
  button: _J(e),
  panel: OJ(e),
  icon: NJ
})), BJ = ZP(() => ({
  root: {
    display: "flex",
    flexDirection: "column",
    gap: 4
  }
})), FJ = EJ({
  baseStyle: BJ,
  variants: { invokeAI: MJ },
  defaultProps: {
    variant: "invokeAI",
    colorScheme: "base"
  }
}), DJ = (e) => ({
  fontSize: 9,
  px: 2,
  py: 1,
  minW: 4,
  lineHeight: 1,
  borderRadius: "sm",
  bg: `${e.colorScheme}.200`,
  color: "base.900",
  fontWeight: "bold",
  letterSpacing: 0.6,
  wordBreak: "break-all",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis",
  overflow: "hidden"
}), $J = {
  baseStyle: DJ,
  defaultProps: {
    colorScheme: "base"
  }
}, VJ = (e, t) => t !== "outline" ? {
  borderWidth: "0px",
  borderStyle: "none"
} : e.size === "lg" ? {
  borderWidth: "1px",
  borderStyle: "solid"
} : e.size === "md" ? {
  borderWidth: "1px",
  borderStyle: "solid"
} : {
  borderWidth: "1px",
  borderStyle: "solid"
}, LJ = (e, t) => {
  const { colorScheme: n } = e, r = "base.400", o = n === "invokeYellow" ? `${n}.500` : `${n}.400`, i = "base.300", s = n === "invokeYellow" ? `${n}.300` : `${n}.300`, a = {
    fg: n === "base" ? "base.300" : o,
    fgHover: n === "base" ? "base.50" : s,
    fgDisabled: "base.600"
  }, c = { bg: "none", bgHover: "none", bgDisabled: "none" }, l = {
    borderColor: "none",
    borderColorDisabled: "none",
    borderColorHover: "none"
  };
  return t === "ghost" ? {
    ...a,
    ...c,
    ...l,
    bgHover: "baseAlpha.200"
  } : t === "link" ? {
    ...a,
    ...c,
    ...l
  } : t === "outline" ? {
    ...a,
    ...c,
    borderColor: n === "invokeYellow" ? `${n}Alpha.500` : `${n}Alpha.400`,
    borderColorDisabled: "base.600",
    borderColorHover: n === "invokeYellow" ? `${n}Alpha.700` : `${n}Alpha.600`
  } : {
    bg: n === "base" ? r : o,
    bgHover: n === "base" ? i : s,
    bgDisabled: "base.600",
    fg: "base.900",
    fgHover: "base.900",
    fgDisabled: "base.750",
    ...l
  };
}, Cc = (e, t) => {
  const { borderWidth: n, borderStyle: r } = VJ(e, t), { bg: o, bgDisabled: i, bgHover: s, fg: a, fgDisabled: c, fgHover: l, borderColor: u, borderColorDisabled: d, borderColorHover: f } = LJ(e, t), p = {
    bg: i,
    color: c,
    opacity: 1,
    borderColor: d,
    svg: {
      fill: c
    },
    _hover: {
      bg: i,
      color: c,
      borderColor: d,
      svg: {
        fill: c
      }
    }
  }, m = {
    bg: o,
    color: a,
    borderWidth: n,
    borderStyle: r,
    borderColor: u,
    svg: {
      fill: a
    }
  };
  return {
    ...m,
    _hover: {
      bg: s,
      color: l,
      borderColor: f,
      svg: {
        fill: l
      },
      _disabled: p
    },
    _active: { ...m },
    _disabled: p
  };
}, zJ = (e) => {
  const { colorScheme: t } = e, n = {
    bg: "none",
    color: `${t}.500`,
    svg: {
      fill: `${t}.500`
    },
    opacity: 0.7
  };
  return {
    fontSize: 14,
    h: "min-content",
    w: "min-content",
    minW: "unset",
    minH: "unset",
    bg: "none",
    color: `${t}.400`,
    svg: {
      fill: `${t}.400`
    },
    _disabled: n,
    _hover: {
      bg: "none",
      color: t === "base" ? "base.100" : `${t}.300`,
      svg: {
        fill: t === "base" ? "base.100" : `${t}.300`
      },
      _disabled: n
    },
    '&[data-checked="true"]': {
      color: "blue.300",
      svg: {
        fill: "blue.300"
      },
      _hover: {
        color: "blue.400",
        svg: {
          fill: "blue.400"
        }
      }
    }
  };
}, GJ = {
  baseStyle: {
    fontWeight: "semibold",
    svg: {
      transitionProperty: "all",
      transitionDuration: "faster"
    }
  },
  sizes: {
    sm: {
      fontSize: "sm",
      px: 3,
      py: 2
    },
    md: {
      fontSize: "md",
      px: 4,
      py: 2
    },
    lg: {
      fontSize: "lg",
      px: 4,
      py: 2,
      h: 12
    }
  },
  variants: {
    solid: (e) => Cc(e, "solid"),
    appTab: (e) => ({
      bg: "none",
      svg: {
        fill: "base.600"
      },
      _hover: {
        bg: "none",
        svg: {
          fill: "base.400"
        }
      },
      '&[data-selected="true"]': {
        bg: "none",
        svg: {
          fill: "base.100"
        }
      }
    }),
    outline: (e) => Cc(e, "outline"),
    ghost: (e) => Cc(e, "ghost"),
    link: (e) => Cc(e, "link"),
    promptOverlay: zJ
  },
  defaultProps: {
    variant: "solid",
    colorScheme: "base",
    size: "md"
  }
}, { defineMultiStyleConfig: WJ, definePartsStyle: HJ } = ct(AJ.keys), jJ = HJ({
  container: {
    backgroundColor: "base.750",
    p: 4,
    gap: 2,
    borderRadius: "base",
    minW: 64,
    flexBasis: 1,
    flexGrow: 1
  },
  header: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    p: 0,
    fontSize: "md",
    fontWeight: "semibold"
  },
  body: {
    p: 0,
    display: "flex",
    alignItems: "center",
    gap: 4
  },
  footer: {
    p: 0
  }
}), XJ = WJ({
  variants: { lora: jJ }
}), { definePartsStyle: YJ, defineMultiStyleConfig: ZJ } = En(hJ.keys), UJ = (e) => {
  const { colorScheme: t } = e;
  return {
    bg: "base.700",
    borderColor: "base.600",
    color: "base.100",
    _checked: {
      bg: `${t}.500`,
      borderColor: `${t}.500`,
      color: `${t}.100`,
      _hover: {
        bg: `${t}.500`,
        borderColor: `${t}.500`
      },
      _disabled: {
        borderColor: "transparent",
        bg: "whiteAlpha.300",
        color: "whiteAlpha.500"
      }
    },
    _indeterminate: {
      bg: `${t}.600`,
      borderColor: `${t}.600`,
      color: `${t}.100`
    },
    _disabled: {
      bg: "whiteAlpha.100",
      borderColor: "transparent"
    },
    _focusVisible: {
      boxShadow: "none",
      outline: "none"
    },
    _invalid: {
      borderColor: "error.300"
    }
  };
}, JJ = YJ((e) => ({
  control: UJ(e)
})), KJ = ZJ({
  baseStyle: JJ,
  defaultProps: {
    colorScheme: "invokeBlue"
  }
}), qJ = En(["root", "content"]), kr = {
  transitionProperty: "common",
  transitionDuration: "normal"
}, QJ = qJ.defineMultiStyleConfig({
  baseStyle: {
    root: {
      ...kr,
      w: "full",
      '[data-part="control"]': {
        ...kr,
        w: "full",
        alignItems: "center",
        gap: 2
      },
      '[data-part="trigger"]': {
        ...kr,
        gap: 4,
        alignItems: "center",
        bg: "base.700",
        w: "full",
        h: "28px",
        py: 1,
        px: 4,
        borderRadius: "base",
        _hover: {
          bg: "base.650"
        },
        "&[data-disabled]": {
          opacity: 0.5,
          cursor: "not-allowed",
          _hover: {
            bg: "base.700"
          }
        },
        "&[data-invalid]": {
          borderWidth: "1px",
          borderStyle: "solid",
          borderColor: "error.500"
        }
      },
      "[data-placeholder-shown]": {
        '[data-part="value-text"]': {
          color: "base.400"
        }
      },
      '[data-part="value-text"]': {
        ...kr,
        w: "full",
        h: "full",
        alignItems: "center",
        fontSize: "sm"
      },
      '[data-part="indicator"]': { svg: { boxSize: 4 } },
      '[data-part="clear-trigger"]': {
        // unused - ark requires the clear trigger be within the trigger component, but this makes it difficult to control
        // the width of the content. we are manually handling the clear button by placing it outside the trigger. so, this
        // styling does not apply.
      }
    },
    content: {
      ...kr,
      outline: "none !important",
      flexDir: "column",
      bg: "base.800",
      p: 2,
      gap: 1,
      borderRadius: "base",
      maxH: 96,
      overflowY: "scroll",
      shadow: "dark-lg",
      "&[data-state='open']": {
        //
      },
      "&[data-state='closed']": {
        //
      },
      '[data-part="item-group"]': { ...kr, flexDir: "column", gap: 1 },
      '[data-part="item-group-label"]': {
        ...kr,
        py: 1,
        px: 2,
        color: "base.400",
        fontWeight: "semibold"
      },
      '[data-part="item"]': {
        ...kr,
        alignItems: "center",
        borderRadius: "base",
        py: 1,
        px: 2,
        cursor: "pointer",
        "&[data-highlighted]": {
          bg: "base.700"
        },
        '&[data-state="checked"]': {
          bg: "invokeBlue.300",
          '[data-part="item-text"]': {
            '[data-part="item-text-label"]': { color: "base.900" },
            '[data-part="item-text-description"]': { color: "base.900" }
          }
        },
        '&[data-state="checked"][data-highlighted]': {
          bg: "invokeBlue.200"
        },
        '[data-part="item-text"]': {
          ...kr,
          flexDir: "column",
          w: "full",
          '[data-part="item-text-label"]': {
            fontWeight: "semibold"
          },
          '[data-part="item-text-description"]': { color: "base.300" }
        },
        "&[data-disabled]": {
          cursor: "not-allowed",
          color: "base.500",
          '[data-part="item-text"]': {
            '[data-part="item-text-description"]': { color: "base.500" }
          }
        }
      }
    }
  }
}), { definePartsStyle: eK, defineMultiStyleConfig: tK } = En(mJ.keys), nK = {
  fontSize: "sm",
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  color: "base.100",
  _invalid: {
    color: "error.300"
  }
}, rK = () => ({
  color: "base.100",
  fontSize: "sm",
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "none" },
  _placeholder: { opacity: 0.6 },
  "::selection": {
    color: "blue.900",
    bg: "blue.300"
  }
}), oK = {
  borderRadius: "md",
  py: "1",
  transitionProperty: "common",
  transitionDuration: "normal",
  width: "full",
  _focusVisible: { boxShadow: "outline" },
  _placeholder: { opacity: 0.6 }
}, iK = eK(() => ({
  preview: nK,
  input: rK(),
  textarea: oK
})), sK = tK({
  variants: {
    invokeAI: iK
  },
  defaultProps: {
    size: "sm",
    variant: "invokeAI"
  }
}), { definePartsStyle: aK, defineMultiStyleConfig: cK } = En(gJ.keys), lK = aK((e) => ({
  container: {
    display: "flex",
    flexDirection: e.orientation === "vertical" ? "column" : "row",
    alignItems: e.orientation === "vertical" ? "flex-start" : "center",
    gap: e.orientation === "vertical" ? 2 : 4,
    h: "unset",
    minH: 8,
    w: "full"
  },
  helperText: {
    w: "full",
    fontSize: "sm",
    color: "base.400",
    m: 0
  }
})), uK = cK({
  baseStyle: lK
}), dK = (e) => ({
  mb: e.orientation === "vertical" ? void 0 : 0,
  fontSize: "sm",
  fontWeight: "semibold",
  transitionProperty: "common",
  transitionDuration: "normal",
  whiteSpace: "nowrap",
  userSelect: "none",
  alignItems: "center",
  _disabled: {
    opacity: 0.4
  },
  color: "base.300",
  _invalid: {
    color: "error.300"
  }
}), fK = {
  baseStyle: dK
}, { defineMultiStyleConfig: pK } = En(bJ.keys);
pK({
  baseStyle: {
    text: {
      color: "error.300"
    }
  }
});
const hK = () => ({
  color: "invokeBlue.300"
}), mK = {
  variants: {
    invokeBlue: hK
  }
}, rs = (e) => {
  const { variant: t } = e, n = t === "darkFilled" || t === "iterations" ? "base.800" : "base.700", r = t === "darkFilled" || t === "iterations" ? "base.750" : "base.650", o = "error.600", i = "error.500", a = {
    color: "base.100",
    bg: n,
    borderColor: n
  }, c = {
    borderColor: o,
    _hover: {
      borderColor: i
    }
  }, l = {
    bg: r,
    borderColor: r
  }, u = {
    ...l,
    _invalid: c
  };
  return {
    ...a,
    minH: "28px",
    borderWidth: 1,
    borderRadius: "base",
    outline: "none",
    boxShadow: "none",
    _hover: l,
    _focusVisible: u,
    _invalid: c,
    _disabled: {
      opacity: 0.35,
      _hover: a
    }
  };
}, { definePartsStyle: m0, defineMultiStyleConfig: gK } = En(vJ.keys), bK = gK({
  variants: {
    filled: m0((e) => ({
      field: rs(e)
    })),
    darkFilled: m0((e) => ({
      field: rs(e)
    }))
  },
  defaultProps: {
    size: "sm",
    variant: "filled"
  }
}), { definePartsStyle: vK, defineMultiStyleConfig: yK } = ct(yJ.keys), SK = vK(() => ({
  // define the part you're going to style
  button: {
    // this will style the MenuButton component
    bg: "base.500",
    color: "base.100",
    _hover: {
      bg: "base.600",
      color: "base.50",
      fontWeight: "semibold"
    }
  },
  list: {
    zIndex: 9999,
    color: "base.150",
    bg: "base.800",
    shadow: "dark-lg",
    border: "none",
    p: 2
  },
  item: {
    // this will style the MenuItem and MenuItemOption components
    borderRadius: "sm",
    fontSize: "sm",
    bg: "base.800",
    _hover: {
      bg: "base.700",
      svg: {
        opacity: 1
      }
    },
    _focus: {
      bg: "base.700"
    },
    svg: {
      opacity: 0.7,
      fontSize: 14
    },
    "&[data-destructive='true']": {
      color: "error.300",
      fill: "error.300",
      _hover: {
        bg: "error.600",
        color: "base.50",
        fill: "base.50"
      }
    },
    "&[aria-selected='true']": {
      fontWeight: "semibold",
      bg: "blue.300 !important",
      color: "base.800 !important",
      _hover: {
        color: "base.900 !important",
        bg: "blue.400 !important"
      }
    },
    "&[aria-selected='true'] [data-option-desc='true']": {
      color: "base.800"
    }
  },
  divider: {
    borderColor: "base.700"
  },
  groupTitle: {
    m: 0,
    px: 3,
    py: 2,
    color: "base.500"
  }
})), xK = yK({
  variants: {
    invokeAI: SK
  },
  defaultProps: {
    variant: "invokeAI"
  }
}), { defineMultiStyleConfig: CK, definePartsStyle: IK } = En(SJ.keys), wK = IK(() => ({
  overlay: {
    bg: "blackAlpha.700"
  },
  dialogContainer: {},
  dialog: {
    maxH: "80vh",
    bg: "base.800"
  },
  header: {
    fontWeight: "semibold",
    fontSize: "lg",
    color: "base.300"
  },
  closeButton: {
    opacity: 0.5
  },
  body: {
    overflowY: "scroll"
  },
  footer: {}
})), PK = CK({
  baseStyle: wK,
  defaultProps: { size: "lg" }
}), { defineMultiStyleConfig: kK, definePartsStyle: UP } = En(xJ.keys), g0 = UP((e) => ({
  root: { h: "28px" },
  field: { ...rs(e), pe: 6, h: "full" },
  stepperGroup: {
    border: "none",
    w: 6
  },
  stepper: {
    color: "base.200",
    _hover: {
      bg: "base.700",
      color: "base.100"
    },
    _disabled: {
      _hover: {
        bg: "base.800",
        color: "base.200"
      }
    },
    _first: {
      border: "none",
      margin: 0,
      borderTopEndRadius: "base",
      borderBottomStartRadius: "base"
    },
    _last: {
      border: "none",
      margin: 0,
      borderBottomEndRadius: "base",
      borderTopStartRadius: "base"
    }
  }
})), AK = UP((e) => ({
  root: { h: "28px" },
  field: {
    ...rs(e),
    pe: 6,
    ps: 6,
    borderInlineStartRadius: "base",
    h: "full",
    textAlign: "center",
    fontSize: "md",
    fontWeight: "semibold"
  },
  stepperGroup: {
    border: "none",
    w: 6
  },
  stepper: {
    color: "base.200",
    _hover: {
      bg: "base.700",
      color: "base.100"
    },
    _disabled: {
      _hover: {
        bg: "base.800",
        color: "base.200"
      }
    },
    _first: {
      border: "none",
      margin: 0,
      borderTopEndRadius: "base",
      borderBottomStartRadius: "base"
    },
    _last: {
      border: "none",
      margin: 0,
      borderBottomEndRadius: "base",
      borderTopStartRadius: "base"
    }
  }
})), TK = kK({
  variants: {
    filled: g0,
    darkFilled: g0,
    iterations: AK
  },
  defaultProps: {
    size: "sm",
    variant: "filled"
  }
}), EK = (e, t, n) => TJ(e, "colors", t) ?? n;
function RK(e = "1rem", t = "rgba(255, 255, 255, 0.15)") {
  return {
    backgroundImage: `linear-gradient(
    45deg,
    ${t} 25%,
    transparent 25%,
    transparent 50%,
    ${t} 50%,
    ${t} 75%,
    transparent 75%,
    transparent
  )`,
    backgroundSize: `${e} ${e}`
  };
}
function _K(e) {
  return !Number.isInteger(parseFloat(e.toString()));
}
function OK(e, t = "-") {
  return e.replace(/\s+/g, t);
}
function JP(e) {
  const t = OK(e.toString());
  return t.includes("\\.") ? e : _K(e) ? t.replace(".", "\\.") : e;
}
function NK(e, t = "") {
  return [t, JP(e)].filter(Boolean).join("-");
}
function MK(e, t) {
  return `var(${JP(e)}${t ? `, ${t}` : ""})`;
}
function BK(e, t = "") {
  return `--${NK(e, t)}`;
}
function Hu(e, t) {
  const n = BK(e, t?.prefix);
  return {
    variable: n,
    reference: MK(n, FK(t?.fallback))
  };
}
function FK(e) {
  return e?.reference;
}
const { defineMultiStyleConfig: DK, definePartsStyle: KP } = En(CJ.keys), qP = Hu("popper-bg"), QP = Hu("popper-arrow-bg"), ek = Hu("popper-arrow-shadow-color"), $K = () => ({
  [QP.variable]: "colors.base.800",
  [qP.variable]: "colors.base.800",
  [ek.variable]: "colors.base.600",
  minW: "unset",
  width: "unset",
  p: 4,
  bg: "base.800",
  border: "none",
  shadow: "dark-lg"
}), VK = () => ({
  [QP.variable]: "colors.base.700",
  [qP.variable]: "colors.base.700",
  [ek.variable]: "colors.base.400",
  p: 4,
  bg: "base.700",
  border: "none",
  shadow: "dark-lg"
}), LK = KP(() => ({
  content: $K(),
  body: { padding: 0 }
})), zK = KP(() => ({
  content: VK(),
  body: { padding: 0 }
})), GK = DK({
  variants: {
    invokeAI: LK,
    informational: zK
  },
  defaultProps: {
    variant: "invokeAI"
  }
}), { defineMultiStyleConfig: WK, definePartsStyle: HK } = En(IJ.keys), jK = WK({
  baseStyle: HK(({ theme: e, colorScheme: t, hasStripe: n, isIndeterminate: r }) => {
    const o = `${t}.300`, i = !r && n, s = `linear-gradient(
      to right,
      transparent 0%,
      ${EK(e, o)} 50%,
      transparent 100%
    )`;
    return {
      track: {
        borderRadius: "2px",
        bg: "base.800"
      },
      filledTrack: {
        borderRadius: "2px",
        ...i && RK(),
        ...r ? { bgImage: s } : { bgColor: o }
      }
    };
  })
}), XK = Te("skeleton-start-color"), YK = Te("skeleton-end-color"), ZK = {
  borderRadius: "base",
  maxW: "full",
  maxH: "full",
  [XK.variable]: "colors.base.700",
  [YK.variable]: "colors.base.500"
}, UK = {
  baseStyle: ZK
}, { definePartsStyle: JK, defineMultiStyleConfig: KK } = ct(wJ.keys), qK = () => ({
  h: "28px"
}), QK = () => ({
  bg: "base.600",
  h: 2
}), eq = (e) => ({
  bg: "base.400",
  h: 2
}), tq = (e) => {
  const { orientation: t } = e;
  return {
    w: 5,
    h: 5,
    bg: "base.400",
    borderColor: "base.200",
    borderWidth: 3,
    _hover: {
      transform: t === "vertical" ? "translateX(-50%) scale(1.15)" : "translateY(-50%) scale(1.15)",
      transition: "transform 0.1s",
      _active: {
        transform: t === "vertical" ? "translateX(-50%) scale(1.22)" : "translateY(-50%) scale(1.22)",
        transition: "transform 0.05s"
      }
    }
  };
}, nq = () => ({
  fontSize: "10px",
  color: "base.400",
  mt: 4
}), rq = JK((e) => ({
  container: qK(),
  track: QK(),
  filledTrack: eq(e),
  thumb: tq(e),
  mark: nq()
})), oq = KK({
  baseStyle: rq,
  defaultProps: {
    colorScheme: "base"
  }
}), { defineMultiStyleConfig: iq, definePartsStyle: sq } = En(PJ.keys), aq = (e) => ({
  bg: "base.600",
  p: 1,
  _focusVisible: {
    boxShadow: "none"
  },
  _checked: {
    bg: "blue.500"
  }
}), cq = (e) => ({
  bg: "base.50"
}), lq = sq((e) => ({
  container: {},
  track: aq(e),
  thumb: cq(e)
})), uq = iq({
  variants: { invokeAI: lq },
  defaultProps: {
    size: "md",
    variant: "invokeAI"
  }
}), { defineMultiStyleConfig: dq, definePartsStyle: ju } = En(kJ.keys), fq = () => ({
  display: "flex",
  gap: 4
}), pq = () => ({}), hq = (e) => ({
  display: "flex",
  flexDirection: "column",
  gap: 1
}), mq = () => ({
  padding: 0,
  height: "100%"
}), gq = ju((e) => ({
  root: fq(),
  tab: pq(),
  tablist: hq(e),
  tabpanel: mq()
})), bq = ju(() => ({
  tab: {
    borderTopRadius: "base",
    px: 4,
    py: 1,
    fontSize: "sm",
    color: "base.200",
    _selected: {
      color: "blue.200"
    }
  },
  tabpanel: {
    p: 0,
    pt: 4,
    w: "full",
    h: "full"
  },
  tabpanels: {
    w: "full",
    h: "full"
  }
})), vq = "base.750", Ic = "base.800", yq = ju(() => ({
  indicator: {},
  tablist: {
    bg: Ic,
    borderRadius: "base",
    display: "grid",
    gridAutoFlow: "column",
    gridAutoColumns: "1fr"
  },
  tab: {
    gap: 4,
    bg: vq,
    color: "base.400",
    fontSize: "sm",
    fontWeight: "semibold",
    borderInlineEnd: 1,
    borderInlineEndColor: Ic,
    borderInlineEndStyle: "solid",
    _first: {
      borderTopStartRadius: "base"
    },
    // select the tab next to the selected tab
    '&[aria-selected="true"] + button': { borderBottomStartRadius: "lg" },
    // select the tab prev to the selected tab
    ':has(+ [aria-selected="true"])': { borderBottomEndRadius: "lg" },
    _selected: {
      bg: Ic,
      color: "base.50"
    },
    _last: {
      borderTopEndRadius: "base",
      alignSelf: "start"
    },
    transitionProperty: "all"
  },
  tabpanels: { bg: Ic, borderBottomRadius: "base" },
  tabpanel: {
    p: 0
  }
})), Sq = ju(() => ({
  tab: {
    fontWeight: "semibold",
    fontSize: "sm",
    color: "base.300",
    _hover: {
      color: "base.100"
    },
    _selected: {
      borderColor: "base.800",
      borderBottomColor: "base.900",
      color: "invokeBlue.300",
      _hover: {
        color: "invokeBlue.100"
      }
    }
  }
})), xq = dq({
  variants: {
    line: bq,
    appTabs: gq,
    collapse: yq,
    enclosed: Sq
  },
  defaultProps: {
    variant: "enclosed",
    colorScheme: "blue"
  }
}), Cq = () => ({
  fontSize: "sm"
}), Iq = () => ({
  color: "error.400"
}), wq = () => ({
  color: "base.400"
}), Pq = {
  baseStyle: Cq,
  variants: {
    subtext: wq,
    error: Iq
  }
}, kq = {
  variants: {
    filled: (e) => rs(e),
    darkFilled: (e) => rs(e)
  },
  defaultProps: {
    size: "md",
    variant: "filled"
  }
}, Aq = Hu("popper-arrow-bg"), Tq = () => ({
  borderRadius: "md",
  shadow: "dark-lg",
  bg: "base.200",
  color: "base.800",
  [Aq.variable]: "colors.base.200",
  pt: 1,
  px: 2,
  pb: 1
}), Eq = { baseStyle: Tq }, Rq = {
  Accordion: FJ,
  Badge: $J,
  Button: GJ,
  Card: XJ,
  Checkbox: KJ,
  CustomSelect: QJ,
  Editable: sK,
  Form: uK,
  FormLabel: fK,
  Heading: mK,
  Input: bK,
  Menu: xK,
  Modal: PK,
  NumberInput: TK,
  Popover: GK,
  Progress: jK,
  Skeleton: UK,
  Slider: oq,
  Switch: uq,
  Tabs: xq,
  Text: Pq,
  Textarea: kq,
  Tooltip: Eq
}, _q = {
  body: {
    bg: "base.900",
    color: "base.50"
  },
  first: {
    bg: "base.850",
    color: "base.50"
  },
  second: {
    bg: "base.800",
    color: "base.50"
  },
  third: {
    bg: "base.700",
    color: "base.50"
  },
  nodeBody: {
    bg: "base.800",
    color: "base.100"
  },
  nodeHeader: {
    bg: "base.900",
    color: "base.100"
  },
  nodeFooter: {
    bg: "base.900",
    color: "base.100"
  },
  danger: {
    color: "error.500 !important"
  }
}, Oq = {
  "::-webkit-scrollbar": {
    display: "none"
  },
  scrollbarWidth: "none"
}, Nq = {
  ".os-scrollbar": {
    /*      The size of the scrollbar */
    "--os-size": "9px",
    /*      The axis-perpedicular padding of the scrollbar (horizontal: padding-y, vertical: padding-x) */
    /* --os-padding-perpendicular: 0; */
    /*      The axis padding of the scrollbar (horizontal: padding-x, vertical: padding-y) */
    /* --os-padding-axis: 0; */
    /*      The border radius of the scrollbar track */
    /* --os-track-border-radius: 0; */
    /*      The background of the scrollbar track */
    /* --os-track-bg: rgba(0, 0, 0, 0.3); */
    /*      The :hover background of the scrollbar track */
    /* --os-track-bg-hover: rgba(0, 0, 0, 0.3); */
    /*      The :active background of the scrollbar track */
    /* --os-track-bg-active: rgba(0, 0, 0, 0.3); */
    /*      The border of the scrollbar track */
    /* --os-track-border: none; */
    /*      The :hover background of the scrollbar track */
    /* --os-track-border-hover: none; */
    /*      The :active background of the scrollbar track */
    /* --os-track-border-active: none; */
    /*      The border radius of the scrollbar handle */
    /* --os-handle-border-radius: 2px; */
    /*      The background of the scrollbar handle */
    /* --os-handle-bg: var(--invoke-colors-accentAlpha-500); */
    /*      The :hover background of the scrollbar handle */
    /* --os-handle-bg-hover: var(--invoke-colors-accentAlpha-700); */
    /*      The :active background of the scrollbar handle */
    /* --os-handle-bg-active: var(--invoke-colors-accentAlpha-800); */
    /*      The border of the scrollbar handle */
    /* --os-handle-border: none; */
    /*      The :hover border of the scrollbar handle */
    /* --os-handle-border-hover: none; */
    /*      The :active border of the scrollbar handle */
    /* --os-handle-border-active: none; */
    /*      The min size of the scrollbar handle */
    "--os-handle-min-size": "50px"
    /*      The max size of the scrollbar handle */
    /* --os-handle-max-size: none; */
    /*      The axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size: 100%; */
    /*      The :hover axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size-hover: 100%; */
    /*      The :active axis-perpedicular size of the scrollbar handle (horizontal: height, vertical: width) */
    /* --os-handle-perpendicular-size-active: 100%; */
    /*      Increases the interactive area of the scrollbar handle. */
    /* --os-handle-interactive-area-offset: 0; */
  },
  ".os-scrollbar-handle": {
    cursor: "grab"
  },
  ".os-scrollbar-handle:active": {
    cursor: "grabbing"
  }
}, b0 = {
  backgroundColor: "blueAlpha.150 !important",
  borderColor: "blue.400 !important",
  borderRadius: "base !important",
  borderStyle: "dashed !important"
}, Mq = {
  ".react-flow__nodesselection-rect": {
    ...b0,
    padding: "1rem !important",
    boxSizing: "content-box !important",
    transform: "translate(-1rem, -1rem) !important"
  },
  ".react-flow__selection": b0
}, Bq = {
  blue: "0 0 10px 0 var(--invoke-colors-blue-600)",
  blueHover: "0 0 10px 0 var(--invoke-colors-blue-500)",
  ok: "0 0 7px var(--invoke-colors-ok-400)",
  working: "0 0 7px var(--invoke-colors-working-400)",
  error: "0 0 7px var(--invoke-colors-error-400)",
  selected: "0px 0px 0px 1px var(--invoke-colors-base-900), 0px 0px 0px 4px var(--invoke-colors-blue-500)",
  hoverSelected: "0px 0px 0px 1px var(--invoke-colors-base-900), 0px 0px 0px 4px var(--invoke-colors-blue-400)",
  hoverUnselected: "0px 0px 0px 1px var(--invoke-colors-base-900), 0px 0px 0px 3px var(--invoke-colors-blue-400)",
  nodeSelected: "0 0 0 3px var(--invoke-colors-blue-500)",
  nodeHovered: "0 0 0 2px var(--invoke-colors-blue-400)",
  nodeHoveredSelected: "0 0 0 3px var(--invoke-colors-blue-400)",
  nodeInProgress: "0 0 0 2px var(--invoke-colors-yellow-400), 0 0 20px 2px var(--invoke-colors-orange-700)"
}, Fq = (e = 0.75) => [
  0.5,
  1,
  1.5,
  2,
  2.5,
  3,
  3.5,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  52,
  56,
  60,
  64,
  72,
  80,
  96
].reduce(
  (r, o) => (r[o] = `${o * (0.25 * e)}rem`, r),
  { px: "1px" }
), v0 = Fq(0.75), dee = {
  config: {
    cssVarPrefix: "invoke"
  },
  direction: "ltr",
  colors: fJ,
  components: Rq,
  layerStyles: _q,
  shadows: Bq,
  space: v0,
  sizes: v0,
  styles: {
    global: {
      body: { bg: "base.900", color: "base.50" },
      "*": { ...Oq },
      ...Nq,
      ...Mq
    }
  },
  fonts: {
    body: "'Inter Variable', sans-serif",
    heading: "'Inter Variable', sans-serif"
  },
  radii: {
    base: "4px",
    lg: "8px",
    md: "4px",
    sm: "2px"
  },
  fontSizes: {
    xs: "0.65rem",
    sm: "0.75rem",
    md: "0.9rem",
    lg: "1.025rem",
    xl: "1.15rem",
    "2xl": "1.3rem",
    "3xl": "1.575rem",
    "4xl": "1.925rem",
    "5xl": "2.5rem",
    "6xl": "3.25rem",
    "7xl": "4rem",
    "8xl": "6rem",
    "9xl": "8rem"
  }
}, fee = {
  defaultOptions: { isClosable: !0, position: "bottom-right" }
}, Dq = ut(
  X((e, t) => {
    const { isDestructive: n = !1, isLoading: r = !1, isDisabled: o, icon: i, ...s } = e;
    return /* @__PURE__ */ b(
      QC,
      {
        ref: t,
        icon: r ? /* @__PURE__ */ b(cJ, { animation: uJ }) : i,
        isDisabled: r || o,
        "data-destructive": n,
        ...s
      }
    );
  })
);
Dq.displayName = "MenuItem";
const $q = {
  variants: {
    enter: {
      visibility: "visible",
      opacity: 1,
      scale: 1,
      transition: {
        duration: 0.07,
        ease: [0.4, 0, 0.2, 1]
      }
    },
    exit: {
      transitionEnd: {
        visibility: "hidden"
      },
      opacity: 0,
      scale: 0.8,
      transition: {
        duration: 0.07,
        easings: "easeOut"
      }
    }
  }
}, Vq = ut(
  X((e, t) => /* @__PURE__ */ b(Yo, { children: /* @__PURE__ */ b(tI, { ref: t, motionProps: $q, onContextMenu: T6, ...e }) }))
);
Vq.displayName = "MenuList";
const pee = ut(
  ({
    withLongPress: e = !0,
    longPressDelayMs: t = 500,
    longPressBailThreshold: n = 10,
    renderMenu: r,
    children: o,
    menuProps: i,
    portalProps: s,
    menuButtonProps: a,
    stopPropagation: c = !1,
    stopImmediatePropagation: l = !1
  }) => {
    const { isOpen: u, onOpen: d, onClose: f } = Hl(), [p, m] = ue([-1, -1]), h = se(null), g = se([-1, -1]), v = se(0), y = se(0);
    QU(f);
    const x = R(
      (P) => {
        if (P.shiftKey) {
          f();
          return;
        }
        (h.current?.contains(P.target) || P.target === h.current) && (l && P.stopImmediatePropagation(), c && P.stopPropagation(), window.clearTimeout(y.current), P.preventDefault(), g.current[0] !== P.pageX || g.current[1] !== P.pageY ? (f(), y.current = window.setTimeout(() => {
          d(), m([P.pageX, P.pageY]);
        }, 100)) : (d(), m([P.pageX, P.pageY]))), g.current = [P.pageX, P.pageY];
      },
      [f, d, l, c]
    ), S = R(
      (P) => {
        e && P.pointerType !== "mouse" && (v.current = window.setTimeout(() => {
          x(P);
        }, t ?? 500), g.current = [P.pageX, P.pageY]);
      },
      [e, t, x]
    ), C = R(
      (P) => {
        if (!e || v.current === null)
          return;
        const k = g.current;
        Math.hypot(P.pageX - k[0], P.pageY - k[1]) > n && clearTimeout(v.current);
      },
      [n, e]
    ), w = R(() => {
      e && v.current && clearTimeout(v.current);
    }, [e]), I = R(() => {
      e && v.current && clearTimeout(v.current);
    }, [e]);
    return ge(
      () => () => {
        window.clearTimeout(y.current);
      },
      []
    ), ge(() => {
      if (!e || !h.current)
        return;
      const P = new AbortController();
      return h.current.style.userSelect = "none", h.current.style.webkitUserSelect = "none", h.current.addEventListener("pointerdown", S, { signal: P.signal }), h.current.addEventListener("pointerup", w, { signal: P.signal }), h.current.addEventListener("pointercancel", I, { signal: P.signal }), h.current.addEventListener("pointermove", C, { signal: P.signal }), () => {
        P.abort();
      };
    }, [I, S, C, w, e]), Qr(window, "contextmenu", x), /* @__PURE__ */ Ae(Vr, { children: [
      o(h),
      /* @__PURE__ */ b(wu, { ...s, children: /* @__PURE__ */ Ae(Tm, { isLazy: !0, isOpen: u, gutter: 0, placement: "auto-end", onClose: f, ...i, children: [
        /* @__PURE__ */ b(
          UC,
          {
            "aria-hidden": !0,
            w: 1,
            h: 1,
            position: "absolute",
            left: p[0],
            top: p[1],
            cursor: "default",
            bg: "transparent",
            size: "sm",
            _hover: Lq,
            pointerEvents: "none",
            ...a
          }
        ),
        r()
      ] }) })
    ] });
  }
), Lq = { bg: "transparent" };
var tk = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, y0 = At.createContext && /* @__PURE__ */ At.createContext(tk), zq = ["attr", "size", "title"];
function Gq(e, t) {
  if (e == null) return {};
  var n = Wq(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Wq(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function Vl() {
  return Vl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Vl.apply(this, arguments);
}
function S0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ll(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S0(Object(n), !0).forEach(function(r) {
      Hq(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Hq(e, t, n) {
  return t = jq(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function jq(e) {
  var t = Xq(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Xq(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function nk(e) {
  return e && e.map((t, n) => /* @__PURE__ */ At.createElement(t.tag, Ll({
    key: n
  }, t.attr), nk(t.child)));
}
function fg(e) {
  return (t) => /* @__PURE__ */ At.createElement(Yq, Vl({
    attr: Ll({}, e.attr)
  }, t), nk(e.child));
}
function Yq(e) {
  var t = (n) => {
    var {
      attr: r,
      size: o,
      title: i
    } = e, s = Gq(e, zq), a = o || n.size || "1em", c;
    return n.className && (c = n.className), e.className && (c = (c ? c + " " : "") + e.className), /* @__PURE__ */ At.createElement("svg", Vl({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, s, {
      className: c,
      style: Ll(Ll({
        color: e.color || n.color
      }, n.style), e.style),
      height: a,
      width: a,
      xmlns: "http://www.w3.org/2000/svg"
    }), i && /* @__PURE__ */ At.createElement("title", null, i), e.children);
  };
  return y0 !== void 0 ? /* @__PURE__ */ At.createElement(y0.Consumer, null, (n) => t(n)) : t(tk);
}
function Zq(e) {
  return fg({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M12 7.59 7.05 2.64 5.64 4.05 12 10.41l6.36-6.36-1.41-1.41L12 7.59zM5.64 19.95l1.41 1.41L12 16.41l4.95 4.95 1.41-1.41L12 13.59l-6.36 6.36z" }, child: [] }] })(e);
}
function Uq(e) {
  return fg({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "m12 19.24-4.95-4.95-1.41 1.42L12 22.07l6.36-6.36-1.41-1.42L12 19.24zM5.64 8.29l1.41 1.42L12 4.76l4.95 4.95 1.41-1.42L12 1.93 5.64 8.29z" }, child: [] }] })(e);
}
const wc = {
  color: "base.400",
  borderColor: "base.400",
  transitionDuration: "normal",
  transitionProperty: "common",
  ":hover, :hover *": {
    transitionDuration: "normal",
    transitionProperty: "common",
    color: "base.300",
    borderColor: "base.300"
  }
}, Jq = ut((e) => {
  const { t } = xw(), { children: n, label: r = t("common.advancedOptions", "Advanced Options"), isOpen: o, onToggle: i } = e;
  return /* @__PURE__ */ Ae(Uc, { flexDir: "column", w: "full", children: [
    /* @__PURE__ */ Ae(Uc, { as: "button", flexDir: "row", alignItems: "center", gap: 3, py: 4, px: 2, onClick: i, sx: wc, children: [
      /* @__PURE__ */ b(dw, { w: "unset", flexGrow: 1, sx: wc }),
      /* @__PURE__ */ Ae(Uc, { flexDir: "row", alignItems: "center", gap: 2, children: [
        /* @__PURE__ */ b(It, { as: o ? Zq : Uq, fontSize: "14px", sx: wc }),
        /* @__PURE__ */ b(To, { variant: "subtext", fontSize: "sm", fontWeight: "semibold", flexShrink: 0, sx: wc, children: r })
      ] })
    ] }),
    /* @__PURE__ */ b(Jh, { in: o, animateOpacity: !0, children: n })
  ] });
});
Jq.displayName = "Expander";
const pg = an({}), Kq = ut(
  X((e, t) => {
    const { orientation: n, isDisabled: r, ...o } = e, i = at(pg), s = be(() => n ?? i.orientation, [n, i.orientation]), a = be(() => r ?? i.isDisabled, [r, i.isDisabled]);
    return /* @__PURE__ */ b(
      Vx,
      {
        ref: t,
        orientation: s,
        isDisabled: a,
        ...o,
        ...i.formControlProps
      }
    );
  })
);
Kq.displayName = "FormControl";
const qq = ut(({ children: e, ...t }) => /* @__PURE__ */ b(pg.Provider, { value: t, children: e }));
qq.displayName = "FormControlGroup";
const Qq = ut(
  X((e, t) => {
    const n = at(pg);
    return /* @__PURE__ */ b(kC, { ref: t, ...e, ...n.formLabelProps });
  })
);
Qq.displayName = "FormLabel";
const eQ = ut(
  X((e, t) => {
    const { setShift: n } = ug(), r = R(
      (o) => {
        n(o.shiftKey);
      },
      [n]
    );
    return /* @__PURE__ */ b(vm, { ref: t, onPaste: zm, onKeyUp: r, onKeyDown: r, ...e });
  })
);
eQ.displayName = "Input";
function tQ(e) {
  return fg({ attr: { viewBox: "0 0 256 256", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M228,104a12,12,0,0,1-24,0V69l-59.51,59.51a12,12,0,0,1-17-17L187,52H152a12,12,0,0,1,0-24h64a12,12,0,0,1,12,12Zm-44,24a12,12,0,0,0-12,12v64H52V84h64a12,12,0,0,0,0-24H48A20,20,0,0,0,28,80V208a20,20,0,0,0,20,20H176a20,20,0,0,0,20-20V140A12,12,0,0,0,184,128Z" }, child: [] }] })(e);
}
const hee = ({ label: e, ...t }) => /* @__PURE__ */ Ae(OC, { isExternal: !0, display: "flex", alignItems: "center", ...t, children: [
  e,
  /* @__PURE__ */ b(It, { display: "inline", verticalAlign: "middle", marginInlineStart: 2, as: tQ })
] });
var wf = { exports: {} }, Ps = {}, Pf = {}, x0;
function rk() {
  return x0 || (x0 = 1, (function(e) {
    function t() {
      return t = Object.assign ? Object.assign.bind() : function(o) {
        for (var i = 1; i < arguments.length; i++) {
          var s = arguments[i];
          for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a]);
        }
        return o;
      }, t.apply(this, arguments);
    }
    Object.defineProperty(e, "__esModule", { value: !0 });
    var n, r = { 0: 11, 1: 0, 2: 3, 3: 0, 4: 0, 5: 0, 6: 0, 7: 11, 8: 11, 9: 1, 10: 10, 11: 0, 12: 11, 13: 0, 14: -1 };
    e.tokenTypes = void 0, (n = e.tokenTypes || (e.tokenTypes = {}))[n.FUNCTION_WITH_ONE_ARG = 0] = "FUNCTION_WITH_ONE_ARG", n[n.NUMBER = 1] = "NUMBER", n[n.BINARY_OPERATOR_HIGH_PRECENDENCE = 2] = "BINARY_OPERATOR_HIGH_PRECENDENCE", n[n.CONSTANT = 3] = "CONSTANT", n[n.OPENING_PARENTHESIS = 4] = "OPENING_PARENTHESIS", n[n.CLOSING_PARENTHESIS = 5] = "CLOSING_PARENTHESIS", n[n.DECIMAL = 6] = "DECIMAL", n[n.POSTFIX_FUNCTION_WITH_ONE_ARG = 7] = "POSTFIX_FUNCTION_WITH_ONE_ARG", n[n.FUNCTION_WITH_N_ARGS = 8] = "FUNCTION_WITH_N_ARGS", n[n.BINARY_OPERATOR_LOW_PRECENDENCE = 9] = "BINARY_OPERATOR_LOW_PRECENDENCE", n[n.BINARY_OPERATOR_PERMUTATION = 10] = "BINARY_OPERATOR_PERMUTATION", n[n.COMMA = 11] = "COMMA", n[n.EVALUATED_FUNCTION = 12] = "EVALUATED_FUNCTION", n[n.EVALUATED_FUNCTION_PARAMETER = 13] = "EVALUATED_FUNCTION_PARAMETER", n[n.SPACE = 14] = "SPACE", e.createTokens = function(o) {
      return [{ token: "sin", show: "sin", type: 0, value: o.math.sin }, { token: "cos", show: "cos", type: 0, value: o.math.cos }, { token: "tan", show: "tan", type: 0, value: o.math.tan }, { token: "pi", show: "&pi;", type: 3, value: "PI" }, { token: "(", show: "(", type: 4, value: "(" }, { token: ")", show: ")", type: 5, value: ")" }, { token: "P", show: "P", type: 10, value: o.math.P }, { token: "C", show: "C", type: 10, value: o.math.C }, { token: " ", show: " ", type: 14, value: " ".anchor }, { token: "asin", show: "asin", type: 0, value: o.math.asin }, { token: "acos", show: "acos", type: 0, value: o.math.acos }, { token: "atan", show: "atan", type: 0, value: o.math.atan }, { token: "7", show: "7", type: 1, value: "7" }, { token: "8", show: "8", type: 1, value: "8" }, { token: "9", show: "9", type: 1, value: "9" }, { token: "int", show: "Int", type: 0, value: Math.floor }, { token: "cosh", show: "cosh", type: 0, value: o.math.cosh }, { token: "acosh", show: "acosh", type: 0, value: o.math.acosh }, { token: "ln", show: " ln", type: 0, value: Math.log }, { token: "^", show: "^", type: 10, value: Math.pow }, { token: "root", show: "root", type: 0, value: Math.sqrt }, { token: "4", show: "4", type: 1, value: "4" }, { token: "5", show: "5", type: 1, value: "5" }, { token: "6", show: "6", type: 1, value: "6" }, { token: "/", show: "&divide;", type: 2, value: o.math.div }, { token: "!", show: "!", type: 7, value: o.math.fact }, { token: "tanh", show: "tanh", type: 0, value: o.math.tanh }, { token: "atanh", show: "atanh", type: 0, value: o.math.atanh }, { token: "Mod", show: " Mod ", type: 2, value: o.math.mod }, { token: "1", show: "1", type: 1, value: "1" }, { token: "2", show: "2", type: 1, value: "2" }, { token: "3", show: "3", type: 1, value: "3" }, { token: "*", show: "&times;", type: 2, value: o.math.mul }, { token: "sinh", show: "sinh", type: 0, value: o.math.sinh }, { token: "asinh", show: "asinh", type: 0, value: o.math.asinh }, { token: "e", show: "e", type: 3, value: "E" }, { token: "log", show: " log", type: 0, value: o.math.log }, { token: "0", show: "0", type: 1, value: "0" }, { token: ".", show: ".", type: 6, value: "." }, { token: "+", show: "+", type: 9, value: o.math.add }, { token: "-", show: "-", type: 9, value: o.math.sub }, { token: ",", show: ",", type: 11, value: "," }, { token: "Sigma", show: "&Sigma;", type: 12, value: o.math.sigma }, { token: "n", show: "n", type: 13, value: "n" }, { token: "Pi", show: "&Pi;", type: 12, value: o.math.Pi }, { token: "pow", show: "pow", type: 8, value: Math.pow, numberOfArguments: 2 }, { token: "&", show: "&", type: 9, value: o.math.and }].map((function(i) {
        return t({}, i, { precedence: r[i.type] });
      }));
    }, e.preced = r;
  })(Pf)), Pf;
}
var C0;
function nQ() {
  if (C0) return Ps;
  C0 = 1, Object.defineProperty(Ps, "__esModule", { value: !0 });
  var e = rk();
  function t(d, f) {
    for (var p = 0; p < d.length; p++) d[p] += f;
    return d;
  }
  var n = { 0: !0, 1: !0, 3: !0, 4: !0, 6: !0, 8: !0, 9: !0, 12: !0, 13: !0, 14: !0 }, r = { 0: !0, 1: !0, 2: !0, 3: !0, 4: !0, 5: !0, 6: !0, 7: !0, 8: !0, 9: !0, 10: !0, 11: !0, 12: !0, 13: !0 }, o = { 0: !0, 3: !0, 4: !0, 8: !0, 12: !0, 13: !0 }, i = {}, s = { 0: !0, 1: !0, 3: !0, 4: !0, 6: !0, 8: !0, 12: !0, 13: !0 }, a = { 1: !0 }, c = [[], ["1", "2", "3", "7", "8", "9", "4", "5", "6", "+", "-", "*", "/", "(", ")", "^", "!", "P", "C", "e", "0", ".", ",", "n", " ", "&"], ["pi", "ln", "Pi"], ["sin", "cos", "tan", "Del", "int", "Mod", "log", "pow"], ["asin", "acos", "atan", "cosh", "root", "tanh", "sinh"], ["acosh", "atanh", "asinh", "Sigma"]];
  function l(d, f, p, m) {
    for (var h = 0; h < m; h++) if (d[p + h] !== f[h]) return !1;
    return !0;
  }
  function u(d, f) {
    for (var p = 0; p < f.length; p++) if (f[p].token === d) return p;
    return -1;
  }
  return Ps.addToken = function(d) {
    for (var f = 0; f < d.length; f++) {
      var p = d[f].token.length, m = -1;
      d[f].type === e.tokenTypes.FUNCTION_WITH_N_ARGS && d[f].numberOfArguments === void 0 && (d[f].numberOfArguments = 2), c[p] = c[p] || [];
      for (var h = 0; h < c[p].length; h++) if (d[f].token === c[p][h]) {
        m = u(c[p][h], this.tokens);
        break;
      }
      m === -1 ? (this.tokens.push(d[f]), d[f].precedence = e.preced[d[f].type], c.length <= d[f].token.length && (c[d[f].token.length] = []), c[d[f].token.length].push(d[f].token)) : (this.tokens[m] = d[f], d[f].precedence = e.preced[d[f].type]);
    }
  }, Ps.lex = function(d, f) {
    var p, m = { value: this.math.changeSign, type: e.tokenTypes.FUNCTION_WITH_ONE_ARG, precedence: 4, show: "-" }, h = { value: ")", show: ")", type: e.tokenTypes.CLOSING_PARENTHESIS, precedence: 0 }, g = { value: "(", type: e.tokenTypes.OPENING_PARENTHESIS, precedence: 0, show: "(" }, v = [g], y = [], x = d, S = n, C = 0, w = i, I = "";
    f !== void 0 && this.addToken(f);
    var P = (function(J, ee) {
      for (var H, _, j, E = [], M = ee.length, F = 0; F < M; F++) if (!(F < M - 1 && ee[F] === " " && ee[F + 1] === " ")) {
        for (H = "", _ = ee.length - F > c.length - 2 ? c.length - 1 : ee.length - F; _ > 0; _--) if (c[_] !== void 0) for (j = 0; j < c[_].length; j++) l(ee, c[_][j], F, _) && (H = c[_][j], j = c[_].length, _ = 0);
        if (F += H.length - 1, H === "") throw new Error("Can't understand after " + ee.slice(F));
        E.push(J.tokens[u(H, J.tokens)]);
      }
      return E;
    })(this, x);
    for (p = 0; p < P.length; p++) {
      var k = P[p];
      if (k.type !== 14) {
        var A, N = k.token, B = k.type, L = k.value, Z = k.precedence, ne = k.show, W = v[v.length - 1];
        for (A = y.length; A-- && y[A] === 0; ) if ([e.tokenTypes.FUNCTION_WITH_ONE_ARG, e.tokenTypes.BINARY_OPERATOR_HIGH_PRECENDENCE, e.tokenTypes.CONSTANT, e.tokenTypes.OPENING_PARENTHESIS, e.tokenTypes.CLOSING_PARENTHESIS, e.tokenTypes.BINARY_OPERATOR_LOW_PRECENDENCE, e.tokenTypes.BINARY_OPERATOR_PERMUTATION, e.tokenTypes.COMMA, e.tokenTypes.EVALUATED_FUNCTION, e.tokenTypes.EVALUATED_FUNCTION_PARAMETER].indexOf(B) !== -1) {
          if (S[B] !== !0) throw new Error(N + " is not allowed after " + I);
          v.push(h), S = r, w = s, y.pop();
        }
        if (S[B] !== !0) throw new Error(N + " is not allowed after " + I);
        w[B] === !0 && (B = e.tokenTypes.BINARY_OPERATOR_HIGH_PRECENDENCE, L = this.math.mul, ne = "&times;", Z = 3, p -= 1);
        var O = { value: L, type: B, precedence: Z, show: ne, numberOfArguments: k.numberOfArguments };
        if (B === e.tokenTypes.FUNCTION_WITH_ONE_ARG) S = n, w = i, t(y, 1), v.push(O), P[p + 1].type !== e.tokenTypes.OPENING_PARENTHESIS && (v.push(g), y.push(2));
        else if (B === e.tokenTypes.NUMBER) W.type === e.tokenTypes.NUMBER ? (W.value += L, t(y, 1)) : v.push(O), S = r, w = o;
        else if (B === e.tokenTypes.BINARY_OPERATOR_HIGH_PRECENDENCE) S = n, w = i, t(y, 2), v.push(O);
        else if (B === e.tokenTypes.CONSTANT) v.push(O), S = r, w = s;
        else if (B === e.tokenTypes.OPENING_PARENTHESIS) t(y, 1), C++, S = n, w = i, v.push(O);
        else if (B === e.tokenTypes.CLOSING_PARENTHESIS) {
          if (!C) throw new Error("Closing parenthesis are more than opening one, wait What!!!");
          C--, S = r, w = s, v.push(O), t(y, 1);
        } else if (B === e.tokenTypes.DECIMAL) {
          if (W.hasDec) throw new Error("Two decimals are not allowed in one number");
          W.type !== e.tokenTypes.NUMBER && (W = { show: "0", value: 0, type: e.tokenTypes.NUMBER, precedence: 0 }, v.push(W), t(y, -1)), S = a, t(y, 1), w = i, W.value += L, W.hasDec = !0;
        } else B === e.tokenTypes.POSTFIX_FUNCTION_WITH_ONE_ARG && (S = r, w = s, t(y, 1), v.push(O));
        B === e.tokenTypes.FUNCTION_WITH_N_ARGS ? (S = n, w = i, t(y, k.numberOfArguments + 2), v.push(O), P[p + 1].type !== e.tokenTypes.OPENING_PARENTHESIS && (v.push(g), y.push(k.numberOfArguments + 2))) : B === e.tokenTypes.BINARY_OPERATOR_LOW_PRECENDENCE ? (W.type === e.tokenTypes.BINARY_OPERATOR_LOW_PRECENDENCE ? W.value === this.math.add ? (W.value = L, W.show = ne, t(y, 1)) : W.value === this.math.sub && ne === "-" && (W.value = this.math.add, W.show = "+", t(y, 1)) : W.type !== e.tokenTypes.CLOSING_PARENTHESIS && W.type !== e.tokenTypes.POSTFIX_FUNCTION_WITH_ONE_ARG && W.type !== e.tokenTypes.NUMBER && W.type !== e.tokenTypes.CONSTANT && W.type !== e.tokenTypes.EVALUATED_FUNCTION_PARAMETER ? N === "-" && (S = n, w = i, t(y, 1), y.push(2), v.push(m), v.push(g)) : (v.push(O), t(y, 2)), S = n, w = i) : B === e.tokenTypes.BINARY_OPERATOR_PERMUTATION ? (S = n, w = i, t(y, 2), v.push(O)) : B === e.tokenTypes.COMMA ? (S = n, w = i, v.push(O)) : B === e.tokenTypes.EVALUATED_FUNCTION ? (S = n, w = i, t(y, 6), v.push(O), P[p + 1].type !== e.tokenTypes.OPENING_PARENTHESIS && (v.push(g), y.push(6))) : B === e.tokenTypes.EVALUATED_FUNCTION_PARAMETER && (S = r, w = s, v.push(O)), t(y, -1), I = N;
      } else if (p > 0 && p < P.length - 1 && P[p + 1].type === 1 && (P[p - 1].type === 1 || P[p - 1].type === 6)) throw new Error("Unexpected Space");
    }
    for (A = y.length; A--; ) v.push(h);
    if (S[5] !== !0) throw new Error("complete the expression");
    for (; C--; ) v.push(h);
    return v.push(h), v;
  }, Ps;
}
var kf = {}, I0;
function rQ() {
  return I0 || (I0 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.toPostfix = function(t) {
      for (var n, r, o, i = [], s = -1, a = -1, c = [{ value: "(", type: 4, precedence: 0, show: "(" }], l = 1; l < t.length; l++) if (t[l].type === 1 || t[l].type === 3 || t[l].type === 13) t[l].type === 1 && (t[l].value = Number(t[l].value)), i.push(t[l]);
      else if (t[l].type === 4) c.push(t[l]);
      else if (t[l].type === 5) for (; ((u = r = c.pop()) == null ? void 0 : u.type) !== 4; ) {
        var u;
        r && i.push(r);
      }
      else if (t[l].type === 11) {
        for (; ((d = r = c.pop()) == null ? void 0 : d.type) !== 4; ) {
          var d;
          r && i.push(r);
        }
        c.push(r);
      } else {
        a = (n = t[l]).precedence, s = (o = c[c.length - 1]).precedence;
        var f = o.value == "Math.pow" && n.value == "Math.pow";
        if (a > s) c.push(n);
        else {
          for (; s >= a && !f || f && a < s; ) r = c.pop(), o = c[c.length - 1], r && i.push(r), s = o.precedence, f = n.value == "Math.pow" && o.value == "Math.pow";
          c.push(n);
        }
      }
      return i;
    };
  })(kf)), kf;
}
var Af = {}, w0;
function oQ() {
  return w0 || (w0 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.postfixEval = function(t, n) {
      (n = n || {}).PI = Math.PI, n.E = Math.E;
      for (var r, o, i, s = [], a = n.n !== void 0, c = 0; c < t.length; c++) if (t[c].type === 1) s.push({ value: t[c].value, type: 1 });
      else if (t[c].type === 3) s.push({ value: n[t[c].value], type: 1 });
      else if (t[c].type === 0) {
        var l = s[s.length - 1];
        Array.isArray(l) ? l.push(t[c]) : l.value = t[c].value(l.value);
      } else if (t[c].type === 7) {
        var u = s[s.length - 1];
        Array.isArray(u) ? u.push(t[c]) : u.value = t[c].value(u.value);
      } else if (t[c].type === 8) {
        for (var d = [], f = 0; f < t[c].numberOfArguments; f++) {
          var p = s.pop();
          p && d.push(p.value);
        }
        s.push({ type: 1, value: t[c].value.apply(t[c], d.reverse()) });
      } else if (t[c].type === 10) r = s.pop(), o = s.pop(), Array.isArray(o) ? ((o = o.concat(r)).push(t[c]), s.push(o)) : Array.isArray(r) ? (r.unshift(o), r.push(t[c]), s.push(r)) : s.push({ type: 1, value: t[c].value(o.value, r.value) });
      else if (t[c].type === 2 || t[c].type === 9) r = s.pop(), o = s.pop(), Array.isArray(o) ? ((o = o.concat(r)).push(t[c]), s.push(o)) : Array.isArray(r) ? (r.unshift(o), r.push(t[c]), s.push(r)) : s.push({ type: 1, value: t[c].value(o.value, r.value) });
      else if (t[c].type === 12) {
        r = s.pop();
        var m = void 0;
        m = !Array.isArray(r) && r ? [r] : r || [], o = s.pop(), i = s.pop(), s.push({ type: 1, value: t[c].value(i.value, o.value, m) });
      } else t[c].type === 13 && (a ? s.push({ value: n[t[c].value], type: 3 }) : s.push([t[c]]));
      if (s.length > 1) throw new Error("Uncaught Syntax error");
      return parseFloat(s[0].value.toFixed(15));
    };
  })(Af)), Af;
}
var Pc = {}, P0;
function iQ() {
  return P0 || (P0 = 1, Object.defineProperty(Pc, "__esModule", { value: !0 }), Pc.createMathFunctions = function(e) {
    return { isDegree: !0, acos: function(t) {
      return e.math.isDegree ? 180 / Math.PI * Math.acos(t) : Math.acos(t);
    }, add: function(t, n) {
      return t + n;
    }, asin: function(t) {
      return e.math.isDegree ? 180 / Math.PI * Math.asin(t) : Math.asin(t);
    }, atan: function(t) {
      return e.math.isDegree ? 180 / Math.PI * Math.atan(t) : Math.atan(t);
    }, acosh: function(t) {
      return Math.log(t + Math.sqrt(t * t - 1));
    }, asinh: function(t) {
      return Math.log(t + Math.sqrt(t * t + 1));
    }, atanh: function(t) {
      return Math.log((1 + t) / (1 - t));
    }, C: function(t, n) {
      var r = 1, o = t - n, i = n;
      i < o && (i = o, o = n);
      for (var s = i + 1; s <= t; s++) r *= s;
      var a = e.math.fact(o);
      return a === "NaN" ? "NaN" : r / a;
    }, changeSign: function(t) {
      return -t;
    }, cos: function(t) {
      return e.math.isDegree && (t = e.math.toRadian(t)), Math.cos(t);
    }, cosh: function(t) {
      return (Math.pow(Math.E, t) + Math.pow(Math.E, -1 * t)) / 2;
    }, div: function(t, n) {
      return t / n;
    }, fact: function(t) {
      if (t % 1 != 0) return "NaN";
      for (var n = 1, r = 2; r <= t; r++) n *= r;
      return n;
    }, inverse: function(t) {
      return 1 / t;
    }, log: function(t) {
      return Math.log(t) / Math.log(10);
    }, mod: function(t, n) {
      return t % n;
    }, mul: function(t, n) {
      return t * n;
    }, P: function(t, n) {
      for (var r = 1, o = Math.floor(t) - Math.floor(n) + 1; o <= Math.floor(t); o++) r *= o;
      return r;
    }, Pi: function(t, n, r) {
      for (var o = 1, i = t; i <= n; i++) o *= Number(e.postfixEval(r, { n: i }));
      return o;
    }, pow10x: function(t) {
      for (var n = 1; t--; ) n *= 10;
      return n;
    }, sigma: function(t, n, r) {
      for (var o = 0, i = t; i <= n; i++) o += Number(e.postfixEval(r, { n: i }));
      return o;
    }, sin: function(t) {
      return e.math.isDegree && (t = e.math.toRadian(t)), Math.sin(t);
    }, sinh: function(t) {
      return (Math.pow(Math.E, t) - Math.pow(Math.E, -1 * t)) / 2;
    }, sub: function(t, n) {
      return t - n;
    }, tan: function(t) {
      return e.math.isDegree && (t = e.math.toRadian(t)), Math.tan(t);
    }, tanh: function(t) {
      return e.math.sinh(t) / e.math.cosh(t);
    }, toRadian: function(t) {
      return t * Math.PI / 180;
    }, and: function(t, n) {
      return t & n;
    } };
  }), Pc;
}
var k0;
function sQ() {
  if (k0) return wf.exports;
  k0 = 1;
  var e = nQ(), t = rk(), n = rQ(), r = oQ(), o = iQ(), i = (function() {
    function s() {
      this.toPostfix = n.toPostfix, this.addToken = e.addToken, this.lex = e.lex, this.postfixEval = r.postfixEval, this.math = o.createMathFunctions(this), this.tokens = t.createTokens(this);
    }
    return s.prototype.eval = function(a, c, l) {
      return this.postfixEval(this.toPostfix(this.lex(a, c)), l);
    }, s;
  })();
  return i.TOKEN_TYPES = t.tokenTypes, i.tokenTypes = t.tokenTypes, wf.exports = i, wf.exports;
}
var aQ = sQ();
const cQ = /* @__PURE__ */ Wl(aQ), ok = ut((e) => {
  const { onKeyUp: t, onKeyDown: n, children: r, ...o } = e, { setShift: i } = ug(), s = R(
    (c) => {
      t?.(c), i(c.key === "Shift");
    },
    [t, i]
  ), a = R(
    (c) => {
      n?.(c), i(c.key === "Shift");
    },
    [n, i]
  );
  return /* @__PURE__ */ b(CI, { onKeyUp: s, onKeyDown: a, ...o, children: r });
});
ok.displayName = "NumberInputField";
const lQ = (e, t) => Math.round(e / t) * t, uQ = new cQ(), dQ = (e) => !0, fQ = ut(
  X((e, t) => {
    const {
      value: n,
      min: r = 0,
      max: o,
      step: i = 1,
      fineStep: s,
      onChange: a,
      defaultValue: c,
      constrainValue: l,
      allowMath: u,
      ...d
    } = e, [f, p] = ue(String(n));
    ge(() => {
      p(String(n));
    }, [n]);
    const m = dg(), h = be(() => m ? s ?? i : i, [m, s, i]), g = be(() => Number.isInteger(i) && Number.isInteger(s ?? 1), [i, s]), v = be(() => g ? "numeric" : "decimal", [g]), y = be(() => g ? 0 : 3, [g]), x = R((I) => {
      p(I);
    }, []), S = R(() => {
      let I;
      if (u)
        try {
          I = uQ.eval(f);
        } catch {
          I = NaN;
        }
      else
        I = Number(f);
      if (isNaN(I)) {
        p(String(v6(c) ? c : r));
        return;
      }
      const P = g ? lQ(I, s ?? i) : Number(I.toFixed(y)), k = g6(P, r, o), A = l ? l(k) : k;
      a(A), p(String(A));
    }, [
      u,
      g,
      s,
      i,
      y,
      r,
      o,
      l,
      a,
      f,
      c
    ]), C = R(() => {
      S();
    }, [S]), w = R(
      (I) => {
        I.key === "Enter" ? S() : I.key === "Escape" && p(String(n));
      },
      [S, n]
    );
    return /* @__PURE__ */ Ae(
      SI,
      {
        ref: t,
        value: f,
        defaultValue: c,
        min: r,
        max: o,
        step: h,
        onChange: x,
        clampValueOnBlur: !1,
        focusInputOnChange: !1,
        onPaste: zm,
        inputMode: v,
        precision: y,
        variant: "filled",
        onKeyDown: w,
        isValidCharacter: u ? dQ : void 0,
        ...d,
        children: [
          /* @__PURE__ */ b(ok, { onBlur: S }),
          /* @__PURE__ */ Ae(xI, { children: [
            /* @__PURE__ */ b(PI, { onClick: C, children: /* @__PURE__ */ b(aJ, {}) }),
            /* @__PURE__ */ b(wI, { onClick: C, children: /* @__PURE__ */ b(sJ, {}) })
          ] })
        ]
      }
    );
  })
);
fQ.displayName = "CompositeNumberInput";
const ik = { opacity: 0, y: 10 }, pQ = { ...ik, x: "-50%" }, sk = {
  opacity: 1,
  y: 0,
  transition: { duration: 0.2, ease: "easeOut" }
}, hQ = { ...sk, x: "-50%" }, ak = {
  opacity: 0,
  y: 10,
  transition: { duration: 0.2, ease: "anticipate" }
}, mQ = { ...ak, x: "-50%" }, gQ = {
  insetInlineStart: "0 !important",
  insetInlineEnd: "unset !important"
}, bQ = {
  insetInlineStart: "unset !important",
  insetInlineEnd: "0 !important"
}, kt = {
  initialFirstLast: ik,
  initialOther: pQ,
  exitFirstLast: ak,
  exitOther: mQ,
  animateFirstLast: sk,
  animateOther: hQ,
  firstMarkStyle: gQ,
  lastMarkStyle: bQ
}, ck = ut(({ value: e, label: t, index: n, total: r }) => n === 0 ? /* @__PURE__ */ b(
  jc,
  {
    as: Jt.div,
    initial: kt.initialFirstLast,
    animate: kt.animateFirstLast,
    exit: kt.exitFirstLast,
    value: e,
    sx: kt.firstMarkStyle,
    children: t
  },
  e
) : n === r - 1 ? /* @__PURE__ */ b(
  jc,
  {
    as: Jt.div,
    initial: kt.initialFirstLast,
    animate: kt.animateFirstLast,
    exit: kt.exitFirstLast,
    value: e,
    sx: kt.lastMarkStyle,
    children: t
  },
  e
) : /* @__PURE__ */ b(
  jc,
  {
    as: Jt.div,
    initial: kt.initialOther,
    animate: kt.animateOther,
    exit: kt.exitOther,
    value: e,
    children: t
  },
  e
));
ck.displayName = "RangeSliderMark";
const vQ = ut(
  X((e, t) => {
    const {
      value: n,
      min: r,
      max: o,
      step: i = 1,
      fineStep: s,
      onChange: a,
      onReset: c,
      formatValue: l = (A) => A.toString(),
      marks: u,
      withThumbTooltip: d = !1,
      ...f
    } = e, [p, m] = ue(!1), [h, g] = ue(!1), v = dg(), y = be(() => v ? s ?? i : i, [v, s, i]), x = as({}), S = be(() => n.map(l), [l, n]), C = R(() => m(!0), []), w = R(() => m(!1), []), I = R(() => g(!0), []), P = R(() => g(!1), []), k = be(() => u === !0 ? [r, o].map((A) => ({ value: A, label: l(A) })) : u ? u?.map((A) => ({ value: A, label: l(A) })) : [], [u, l, o, r]);
    return /* @__PURE__ */ Ae(
      MI,
      {
        ref: t,
        value: n,
        min: r,
        max: o,
        step: y,
        onChange: a,
        onMouseEnter: C,
        onMouseLeave: w,
        focusThumbOnChange: !1,
        onChangeStart: I,
        onChangeEnd: P,
        ...f,
        ...x,
        children: [
          /* @__PURE__ */ b(Sr, { children: k?.length && (p || h) && k.map((A, N) => /* @__PURE__ */ b(ck, { value: A.value, label: A.label, index: N, total: k.length }, A.value)) }),
          /* @__PURE__ */ b(BI, { children: /* @__PURE__ */ b(FI, {}) }),
          /* @__PURE__ */ b(so, { isOpen: d && (p || h), label: S[0], children: /* @__PURE__ */ b(Pp, { index: 0, onDoubleClick: c, zIndex: 0 }) }),
          /* @__PURE__ */ b(so, { isOpen: d && (p || h), label: S[1], children: /* @__PURE__ */ b(Pp, { index: 1, onDoubleClick: c, zIndex: 0 }) })
        ]
      }
    );
  })
);
vQ.displayName = "CompositeRangeSlider";
const lk = ut(({ value: e, label: t, index: n, total: r }) => n === 0 ? /* @__PURE__ */ b(
  Xc,
  {
    as: Jt.div,
    initial: kt.initialFirstLast,
    animate: kt.animateFirstLast,
    exit: kt.exitFirstLast,
    value: e,
    sx: kt.firstMarkStyle,
    children: t
  },
  e
) : n === r - 1 ? /* @__PURE__ */ b(
  Xc,
  {
    as: Jt.div,
    initial: kt.initialFirstLast,
    animate: kt.animateFirstLast,
    exit: kt.exitFirstLast,
    value: e,
    sx: kt.lastMarkStyle,
    children: t
  },
  e
) : /* @__PURE__ */ b(
  Xc,
  {
    as: Jt.div,
    initial: kt.initialOther,
    animate: kt.animateOther,
    exit: kt.exitOther,
    value: e,
    children: t
  },
  e
));
lk.displayName = "SliderMark";
const yQ = (e) => e.toString(), SQ = ut(
  X((e, t) => {
    const {
      value: n,
      min: r,
      max: o,
      step: i = 1,
      fineStep: s,
      onChange: a,
      onReset: c,
      defaultValue: l,
      formatValue: u = yQ,
      marks: d,
      withThumbTooltip: f = !1,
      alwaysShowMarks: p = !1,
      ...m
    } = e, [h, g] = ue(!1), [v, y] = ue(!1), x = dg(), S = be(() => x ? s ?? i : i, [x, s, i]), C = as({}), w = be(() => u(n), [u, n]), I = R(() => g(!0), []), P = R(() => g(!1), []), k = R(() => y(!0), []), A = R(() => y(!1), []), N = be(() => d === !0 ? [r, o].map((L) => ({ value: L, label: u(L) })) : d ? d?.map((L) => ({ value: L, label: u(L) })) : [], [d, u, o, r]), B = R(() => {
      b6(l) || a(l), c && c();
    }, [l, a, c]);
    return /* @__PURE__ */ Ae(
      DI,
      {
        ref: t,
        value: n,
        min: r,
        max: o,
        step: S,
        onChange: a,
        onMouseEnter: I,
        onMouseLeave: P,
        focusThumbOnChange: !1,
        onChangeStart: k,
        onChangeEnd: A,
        ...m,
        ...C,
        children: [
          /* @__PURE__ */ b(Sr, { children: N?.length && (h || v || p) && N.map((L, Z) => /* @__PURE__ */ b(lk, { value: L.value, label: L.label, index: Z, total: N.length }, L.value)) }),
          /* @__PURE__ */ b(VI, { children: /* @__PURE__ */ b(LI, {}) }),
          /* @__PURE__ */ b(so, { isOpen: f && (h || v), label: w, children: /* @__PURE__ */ b($I, { onDoubleClick: B, zIndex: 0 }) })
        ]
      }
    );
  })
);
SQ.displayName = "CompositeSlider";
const xQ = ut(
  X((e, t) => {
    const { children: n, badges: r, ...o } = e;
    return /* @__PURE__ */ Ae(YI, { ref: t, ...o, children: [
      n,
      /* @__PURE__ */ b($m, {}),
      r?.map((i, s) => /* @__PURE__ */ b(Kh, { colorScheme: "invokeYellow", children: i }, `${i}.${s}`))
    ] });
  })
);
xQ.displayName = "Tab";
const CQ = ut(
  X((e, t) => {
    const { ...n } = e, { setShift: r } = ug(), o = R(
      (i) => {
        r(i.shiftKey);
      },
      [r]
    );
    return /* @__PURE__ */ b(
      JI,
      {
        ref: t,
        onPaste: zm,
        onKeyUp: o,
        onKeyDown: o,
        minH: 20,
        ...n
      }
    );
  })
);
CQ.displayName = "Textarea";
export {
  Wu as $alt,
  zu as $ctrl,
  Gu as $meta,
  Lu as $shift,
  Ix as Accordion,
  vw as AccordionButton,
  Px as AccordionIcon,
  kx as AccordionItem,
  Ax as AccordionPanel,
  gx as Alert,
  yx as AlertDescription,
  tW as AlertDialog,
  hI as AlertDialogBody,
  KG as AlertDialogCloseButton,
  nW as AlertDialogContent,
  mI as AlertDialogFooter,
  gI as AlertDialogHeader,
  vI as AlertDialogOverlay,
  bx as AlertIcon,
  vx as AlertTitle,
  f4 as AspectRatio,
  g4 as Avatar,
  v4 as AvatarBadge,
  y4 as AvatarGroup,
  Kh as Badge,
  Rt as Box,
  C4 as Breadcrumb,
  I4 as BreadcrumbItem,
  Bx as BreadcrumbLink,
  sp as BreadcrumbSeparator,
  Fp as Button,
  X6 as ButtonGroup,
  EQ as Card,
  RQ as CardBody,
  _Q as CardFooter,
  OQ as CardHeader,
  R4 as Center,
  AQ as ChakraProvider,
  nL as Checkbox,
  oL as CheckboxGroup,
  S4 as Circle,
  UW as CircularProgress,
  uu as CloseButton,
  iL as Code,
  Jh as Collapse,
  UU as Combobox,
  JU as ComboboxFallback,
  fQ as CompositeNumberInput,
  vQ as CompositeRangeSlider,
  SQ as CompositeSlider,
  oee as ConfirmationAlertDialog,
  sL as Container,
  pee as ContextMenu,
  MB as DarkMode,
  zx as Divider,
  FQ as Drawer,
  hI as DrawerBody,
  KG as DrawerCloseButton,
  lW as DrawerContent,
  mI as DrawerFooter,
  gI as DrawerHeader,
  vI as DrawerOverlay,
  uL as Editable,
  dL as EditableInput,
  fL as EditablePreview,
  pL as EditableTextarea,
  Jq as Expander,
  hee as ExternalLink,
  QG as Fade,
  Pi as Flex,
  Kq as FormControl,
  qq as FormControlGroup,
  Vz as FormErrorMessage,
  Z4 as FormHelperText,
  Qq as FormLabel,
  TC as Grid,
  zz as GridItem,
  kH as HStack,
  yj as Heading,
  c3 as Hide,
  BQ as Highlight,
  It as Icon,
  Y6 as IconButton,
  Kz as Image,
  eQ as Input,
  e3 as InputGroup,
  _C as InputRightElement,
  n3 as Kbd,
  OC as Link,
  ym as List,
  a3 as ListIcon,
  s3 as ListItem,
  Tm as Menu,
  UC as MenuButton,
  Q9 as MenuDivider,
  KC as MenuGroup,
  Dq as MenuItem,
  eI as MenuItemOption,
  Vq as MenuList,
  nG as MenuOptionGroup,
  Em as Modal,
  hI as ModalBody,
  KG as ModalCloseButton,
  pI as ModalContent,
  mI as ModalFooter,
  gI as ModalHeader,
  vI as ModalOverlay,
  wI as NumberDecrementStepper,
  PI as NumberIncrementStepper,
  SI as NumberInput,
  ok as NumberInputField,
  xI as NumberInputStepper,
  o3 as OrderedList,
  AW as PinInput,
  TW as PinInputField,
  OW as Popover,
  NW as PopoverAnchor,
  MW as PopoverArrow,
  BW as PopoverBody,
  FW as PopoverCloseButton,
  LW as PopoverContent,
  zW as PopoverFooter,
  GW as PopoverHeader,
  WW as PopoverTrigger,
  wu as Portal,
  QW as Progress,
  sH as Radio,
  rH as RadioGroup,
  MI as RangeSlider,
  FI as RangeSliderFilledTrack,
  Pp as RangeSliderThumb,
  BI as RangeSliderTrack,
  YG as ScaleFade,
  aH as Select,
  l3 as Show,
  Gz as SimpleGrid,
  hH as Skeleton,
  yI as Slide,
  jG as SlideFade,
  DI as Slider,
  LI as SliderFilledTrack,
  $I as SliderThumb,
  VI as SliderTrack,
  $m as Spacer,
  lu as Spinner,
  Mx as Square,
  E6 as StandaloneAccordion,
  EH as Stat,
  RH as StatArrow,
  _H as StatGroup,
  OH as StatHelpText,
  NH as StatLabel,
  MH as StatNumber,
  $Q as Step,
  VQ as StepDescription,
  LQ as StepIcon,
  WQ as StepIndicator,
  zQ as StepNumber,
  HQ as StepSeparator,
  GQ as StepStatus,
  jQ as StepTitle,
  XQ as Stepper,
  $H as Switch,
  fee as TOAST_OPTIONS,
  xQ as Tab,
  nj as TabIndicator,
  rj as TabList,
  oj as TabPanel,
  ij as TabPanels,
  LH as Table,
  zH as TableCaption,
  ZQ as TableContainer,
  tj as Tabs,
  aj as Tag,
  dj as TagCloseButton,
  cj as TagLabel,
  lj as TagLeftIcon,
  uj as TagRightIcon,
  UQ as Tbody,
  JQ as Td,
  To as Text,
  CQ as Textarea,
  KQ as Tfoot,
  qQ as Th,
  QQ as Thead,
  so as Tooltip,
  eee as Tr,
  i3 as UnorderedList,
  AH as VStack,
  Sj as VisuallyHidden,
  xj as VisuallyHiddenInput,
  Cj as Wrap,
  QI as WrapItem,
  z as chakra,
  fJ as colors,
  tee as createStandaloneToast,
  s1 as css,
  Te as cssVar,
  MQ as extendTheme,
  X as forwardRef,
  uee as getArbitraryBaseColor,
  An as keyframes,
  T6 as skipMouseEvent,
  uJ as spinAnimation,
  lJ as spinKeyframes,
  lee as spinWithPauseAnimation,
  dJ as spinWithPauseKeyframes,
  zm as stopPastePropagation,
  dee as theme,
  ut as typedMemo,
  aee as useAltModifier,
  Lx as useCheckbox,
  rL as useCheckboxGroup,
  see as useCtrlModifier,
  Hl as useDisclosure,
  NQ as useEditableControls,
  QU as useGlobalMenuClose,
  ug as useGlobalModifiersImperativeAPI,
  iee as useGlobalModifiersInit,
  cee as useMetaModifier,
  We as useMultiStyleConfig,
  U0 as useOutsideClick,
  oH as useRadio,
  tH as useRadioGroup,
  dg as useShiftModifier,
  YQ as useSteps,
  Gt as useStyleConfig,
  nee as useToast,
  k5 as useToken
};
//# sourceMappingURL=main.js.map
